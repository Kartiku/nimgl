# Copyright 2018, NimGL contributors.

import nimgl/glfw # used to get the glfwGetProcAddress procedure
import strutils

## OpenGL Bindings
## ====
## This code was automatically generated by `nimgl_gen<https://github.com/lmariscal/nimgl_gen>`_
## with the opengl generator.
##
## NimGL is completely unaffiliated with OpenGL and Khronos, each Doc is under individual copyright
## you can find it in their appropiate file in the official `repo<https://github.com/KhronosGroup/OpenGL-Refpages>`_
##
## NOTE: This bindings only support modern opengl (v3.2 >=) so fixed pipelines are not
## supported.

type
  GLvoid* = pointer
  GLeglImageOES* = distinct pointer
  GLsync* = distinct pointer
  ClContext* = distinct pointer
  ClEvent* = distinct pointer
  GLeglClientBufferEXT* = distinct pointer
  GLbyte* = int8
  GLshort* = int16
  GLintptr* = int
  GLintptrARB* = int
  GLsizeiptr* = int
  GLsizeiptrARB* = int
  GLclampx* = int32
  GLfixed* = int32
  GLint* = int32
  GLsizei* = int32
  GLvdpauSurfaceNV* = int32
  GLint64* = int64
  GLint64EXT* = int64
  GLubyte* = uint8
  GLhalf* = uint16
  GLhalfARB* = uint16
  GLhalfNV* = uint16
  GLushort* = uint16
  GLbitfield* = uint32
  GLhandleARB* = uint32
  GLenum* = uint32
  GLuint* = uint32
  GLuint64* = uint64
  GLuint64EXT* = uint64
  GLboolean* = bool
  GLchar* = char
  GLcharARB* = byte
  GLclampf* = float32
  GLfloat* = float32
  GLclampd* = float64
  GLdouble* = float64
  GLDEBUGPROC* = proc(source: GLenum, `type`: GLenum, id: GLuint, severity: GLenum, length: GLsizei, message: cstring, userParam: pointer): void {.cdecl.}
  GLDEBUGPROCARB* = GLDEBUGPROC
  GLDEBUGPROCKHR* = GLDEBUGPROC
  GLDEBUGPROCAMD* = GLDEBUGPROC
  GLVULKANPROCNV* = proc(): void {.cdecl.}
  GLPROCLOADERPROC* = proc(name: cstring): pointer {.cdecl.}

var
  glVersionMajor*: int
  glVersionMinor*: int

# Constants
const
  GL_INVALID_INDEX*: uint32 = high(uint32)
  GL_TIMEOUT_IGNORED*: uint64 = high(uint64)
  GL_TIMEOUT_IGNORED_APPLE*: uint64 = high(uint64)
  GL_MAX_VERTEX_HINT_PGI*: GLenum = GLenum(0x1A22D)
  GL_MATERIAL_SIDE_HINT_PGI*: GLenum = GLenum(0x1A22C)
  GL_VERTEX_CONSISTENT_HINT_PGI*: GLenum = GLenum(0x1A22B)
  GL_VERTEX_DATA_HINT_PGI*: GLenum = GLenum(0x1A22A)
  GL_BACK_NORMALS_HINT_PGI*: GLenum = GLenum(0x1A223)
  GL_WIDE_LINE_HINT_PGI*: GLenum = GLenum(0x1A222)
  GL_CLIP_FAR_HINT_PGI*: GLenum = GLenum(0x1A221)
  GL_CLIP_NEAR_HINT_PGI*: GLenum = GLenum(0x1A220)
  GL_DEPTH_BUFFER_BIT*: GLenum = GLenum(0x00000100)
  GL_FULL_STIPPLE_HINT_PGI*: GLenum = GLenum(0x1A219)
  GL_STENCIL_BUFFER_BIT*: GLenum = GLenum(0x00000400)
  GL_STRICT_SCISSOR_HINT_PGI*: GLenum = GLenum(0x1A218)
  GL_STRICT_LIGHTING_HINT_PGI*: GLenum = GLenum(0x1A217)
  GL_STRICT_DEPTHFUNC_HINT_PGI*: GLenum = GLenum(0x1A216)
  GL_COLOR_BUFFER_BIT*: GLenum = GLenum(0x00004000)
  GL_ALLOW_DRAW_MEM_HINT_PGI*: GLenum = GLenum(0x1A211)
  GL_ALLOW_DRAW_FRG_HINT_PGI*: GLenum = GLenum(0x1A210)
  GL_ALLOW_DRAW_WIN_HINT_PGI*: GLenum = GLenum(0x1A20F)
  GL_ALLOW_DRAW_OBJ_HINT_PGI*: GLenum = GLenum(0x1A20E)
  GL_ALWAYS_SOFT_HINT_PGI*: GLenum = GLenum(0x1A20D)
  GL_SAMPLE_LOCATION_SUBPIXEL_BITS_ARB*: GLenum = GLenum(0x933D)
  GL_MULTISAMPLE_BIT_ARB*: GLenum = GLenum(0x20000000)
  GL_MULTISAMPLE_BIT_EXT*: GLenum = GLenum(0x20000000)
  GL_MULTISAMPLE_BIT_3DFX*: GLenum = GLenum(0x20000000)
  GL_ALWAYS_FAST_HINT_PGI*: GLenum = GLenum(0x1A20C)
  GL_COVERAGE_BUFFER_BIT_NV*: GLenum = GLenum(0x00008000) ## Collides with AttribMask bit GL_HINT_BIT. OK since this token is for OpenGL ES 2, which doesn't have attribute groups.
  GL_NATIVE_GRAPHICS_END_HINT_PGI*: GLenum = GLenum(0x1A204)
  GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI*: GLenum = GLenum(0x1A203)
  GL_NATIVE_GRAPHICS_HANDLE_PGI*: GLenum = GLenum(0x1A202)
  GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT*: GLenum = GLenum(0x00000001)
  GL_CONTEXT_FLAG_DEBUG_BIT*: GLenum = GLenum(0x00000002)
  GL_CONTEXT_FLAG_DEBUG_BIT_KHR*: GLenum = GLenum(0x00000002)
  GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT*: GLenum = GLenum(0x00000004)
  GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB*: GLenum = GLenum(0x00000004)
  GL_CONTEXT_FLAG_NO_ERROR_BIT*: GLenum = GLenum(0x00000008)
  GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR*: GLenum = GLenum(0x00000008)
  GL_CONTEXT_FLAG_PROTECTED_CONTENT_BIT_EXT*: GLenum = GLenum(0x00000010)
  GL_CONTEXT_CORE_PROFILE_BIT*: GLenum = GLenum(0x00000001)
  GL_CONTEXT_COMPATIBILITY_PROFILE_BIT*: GLenum = GLenum(0x00000002)
  GL_MAP_READ_BIT*: GLenum = GLenum(0x0001)
  GL_MAP_READ_BIT_EXT*: GLenum = GLenum(0x0001)
  GL_MAP_WRITE_BIT*: GLenum = GLenum(0x0002)
  GL_MAP_WRITE_BIT_EXT*: GLenum = GLenum(0x0002)
  GL_MAP_INVALIDATE_RANGE_BIT*: GLenum = GLenum(0x0004)
  GL_MAP_INVALIDATE_RANGE_BIT_EXT*: GLenum = GLenum(0x0004)
  GL_MAP_INVALIDATE_BUFFER_BIT*: GLenum = GLenum(0x0008)
  GL_MAP_INVALIDATE_BUFFER_BIT_EXT*: GLenum = GLenum(0x0008)
  GL_MAP_FLUSH_EXPLICIT_BIT*: GLenum = GLenum(0x0010)
  GL_MAP_FLUSH_EXPLICIT_BIT_EXT*: GLenum = GLenum(0x0010)
  GL_MAP_UNSYNCHRONIZED_BIT*: GLenum = GLenum(0x0020)
  GL_MAP_UNSYNCHRONIZED_BIT_EXT*: GLenum = GLenum(0x0020)
  GL_MAP_PERSISTENT_BIT*: GLenum = GLenum(0x0040)
  GL_MAP_PERSISTENT_BIT_EXT*: GLenum = GLenum(0x0040)
  GL_MAP_COHERENT_BIT*: GLenum = GLenum(0x0080)
  GL_MAP_COHERENT_BIT_EXT*: GLenum = GLenum(0x0080)
  GL_DYNAMIC_STORAGE_BIT*: GLenum = GLenum(0x0100)
  GL_DYNAMIC_STORAGE_BIT_EXT*: GLenum = GLenum(0x0100)
  GL_CLIENT_STORAGE_BIT*: GLenum = GLenum(0x0200)
  GL_CLIENT_STORAGE_BIT_EXT*: GLenum = GLenum(0x0200)
  GL_SPARSE_STORAGE_BIT_ARB*: GLenum = GLenum(0x0400)
  GL_LGPU_SEPARATE_STORAGE_BIT_NVX*: GLenum = GLenum(0x0800)
  GL_PER_GPU_STORAGE_BIT_NV*: GLenum = GLenum(0x0800)
  GL_EXTERNAL_STORAGE_BIT_NVX*: GLenum = GLenum(0x2000)
  GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT*: GLenum = GLenum(0x00000001)
  GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT*: GLenum = GLenum(0x00000001)
  GL_ELEMENT_ARRAY_BARRIER_BIT*: GLenum = GLenum(0x00000002)
  GL_ELEMENT_ARRAY_BARRIER_BIT_EXT*: GLenum = GLenum(0x00000002)
  GL_UNIFORM_BARRIER_BIT*: GLenum = GLenum(0x00000004)
  GL_UNIFORM_BARRIER_BIT_EXT*: GLenum = GLenum(0x00000004)
  GL_TEXTURE_FETCH_BARRIER_BIT*: GLenum = GLenum(0x00000008)
  GL_TEXTURE_FETCH_BARRIER_BIT_EXT*: GLenum = GLenum(0x00000008)
  GL_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV*: GLenum = GLenum(0x00000010)
  GL_SHADER_IMAGE_ACCESS_BARRIER_BIT*: GLenum = GLenum(0x00000020)
  GL_SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT*: GLenum = GLenum(0x00000020)
  GL_COMMAND_BARRIER_BIT*: GLenum = GLenum(0x00000040)
  GL_COMMAND_BARRIER_BIT_EXT*: GLenum = GLenum(0x00000040)
  GL_PIXEL_BUFFER_BARRIER_BIT*: GLenum = GLenum(0x00000080)
  GL_PIXEL_BUFFER_BARRIER_BIT_EXT*: GLenum = GLenum(0x00000080)
  GL_TEXTURE_UPDATE_BARRIER_BIT*: GLenum = GLenum(0x00000100)
  GL_TEXTURE_UPDATE_BARRIER_BIT_EXT*: GLenum = GLenum(0x00000100)
  GL_BUFFER_UPDATE_BARRIER_BIT*: GLenum = GLenum(0x00000200)
  GL_BUFFER_UPDATE_BARRIER_BIT_EXT*: GLenum = GLenum(0x00000200)
  GL_FRAMEBUFFER_BARRIER_BIT*: GLenum = GLenum(0x00000400)
  GL_FRAMEBUFFER_BARRIER_BIT_EXT*: GLenum = GLenum(0x00000400)
  GL_TRANSFORM_FEEDBACK_BARRIER_BIT*: GLenum = GLenum(0x00000800)
  GL_TRANSFORM_FEEDBACK_BARRIER_BIT_EXT*: GLenum = GLenum(0x00000800)
  GL_ATOMIC_COUNTER_BARRIER_BIT*: GLenum = GLenum(0x00001000)
  GL_ATOMIC_COUNTER_BARRIER_BIT_EXT*: GLenum = GLenum(0x00001000)
  GL_SHADER_STORAGE_BARRIER_BIT*: GLenum = GLenum(0x00002000)
  GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT*: GLenum = GLenum(0x00004000)
  GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT_EXT*: GLenum = GLenum(0x00004000)
  GL_QUERY_BUFFER_BARRIER_BIT*: GLenum = GLenum(0x00008000)
  GL_ALL_BARRIER_BITS*: GLenum = GLenum(0xFFFFFFFF)
  GL_ALL_BARRIER_BITS_EXT*: GLenum = GLenum(0xFFFFFFFF)
  GL_QUERY_DEPTH_PASS_EVENT_BIT_AMD*: GLenum = GLenum(0x00000001)
  GL_QUERY_DEPTH_FAIL_EVENT_BIT_AMD*: GLenum = GLenum(0x00000002)
  GL_QUERY_STENCIL_FAIL_EVENT_BIT_AMD*: GLenum = GLenum(0x00000004)
  GL_QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT_AMD*: GLenum = GLenum(0x00000008)
  GL_QUERY_ALL_EVENT_BITS_AMD*: GLenum = GLenum(0xFFFFFFFF)
  GL_SYNC_FLUSH_COMMANDS_BIT*: GLenum = GLenum(0x00000001)
  GL_SYNC_FLUSH_COMMANDS_BIT_APPLE*: GLenum = GLenum(0x00000001)
  GL_VERTEX_SHADER_BIT*: GLenum = GLenum(0x00000001)
  GL_VERTEX_SHADER_BIT_EXT*: GLenum = GLenum(0x00000001)
  GL_FRAGMENT_SHADER_BIT*: GLenum = GLenum(0x00000002)
  GL_FRAGMENT_SHADER_BIT_EXT*: GLenum = GLenum(0x00000002)
  GL_GEOMETRY_SHADER_BIT*: GLenum = GLenum(0x00000004)
  GL_GEOMETRY_SHADER_BIT_EXT*: GLenum = GLenum(0x00000004)
  GL_GEOMETRY_SHADER_BIT_OES*: GLenum = GLenum(0x00000004)
  GL_TESS_CONTROL_SHADER_BIT*: GLenum = GLenum(0x00000008)
  GL_TESS_CONTROL_SHADER_BIT_EXT*: GLenum = GLenum(0x00000008)
  GL_TESS_CONTROL_SHADER_BIT_OES*: GLenum = GLenum(0x00000008)
  GL_TESS_EVALUATION_SHADER_BIT*: GLenum = GLenum(0x00000010)
  GL_TESS_EVALUATION_SHADER_BIT_EXT*: GLenum = GLenum(0x00000010)
  GL_TESS_EVALUATION_SHADER_BIT_OES*: GLenum = GLenum(0x00000010)
  GL_COMPUTE_SHADER_BIT*: GLenum = GLenum(0x00000020)
  GL_MESH_SHADER_BIT_NV*: GLenum = GLenum(0x00000040)
  GL_TASK_SHADER_BIT_NV*: GLenum = GLenum(0x00000080)
  GL_ALL_SHADER_BITS*: GLenum = GLenum(0xFFFFFFFF)
  GL_ALL_SHADER_BITS_EXT*: GLenum = GLenum(0xFFFFFFFF)
  GL_TEXTURE_STORAGE_SPARSE_BIT_AMD*: GLenum = GLenum(0x00000001)
  GL_RED_BIT_ATI*: GLenum = GLenum(0x00000001)
  GL_GREEN_BIT_ATI*: GLenum = GLenum(0x00000002)
  GL_BLUE_BIT_ATI*: GLenum = GLenum(0x00000004)
  GL_2X_BIT_ATI*: GLenum = GLenum(0x00000001)
  GL_4X_BIT_ATI*: GLenum = GLenum(0x00000002)
  GL_8X_BIT_ATI*: GLenum = GLenum(0x00000004)
  GL_HALF_BIT_ATI*: GLenum = GLenum(0x00000008)
  GL_QUARTER_BIT_ATI*: GLenum = GLenum(0x00000010)
  GL_EIGHTH_BIT_ATI*: GLenum = GLenum(0x00000020)
  GL_SATURATE_BIT_ATI*: GLenum = GLenum(0x00000040)
  GL_COMP_BIT_ATI*: GLenum = GLenum(0x00000002)
  GL_NEGATE_BIT_ATI*: GLenum = GLenum(0x00000004)
  GL_BIAS_BIT_ATI*: GLenum = GLenum(0x00000008)
  GL_TRACE_OPERATIONS_BIT_MESA*: GLenum = GLenum(0x0001)
  GL_TRACE_PRIMITIVES_BIT_MESA*: GLenum = GLenum(0x0002)
  GL_TRACE_ARRAYS_BIT_MESA*: GLenum = GLenum(0x0004)
  GL_TRACE_TEXTURES_BIT_MESA*: GLenum = GLenum(0x0008)
  GL_TRACE_PIXELS_BIT_MESA*: GLenum = GLenum(0x0010)
  GL_TRACE_ERRORS_BIT_MESA*: GLenum = GLenum(0x0020)
  GL_TRACE_ALL_BITS_MESA*: GLenum = GLenum(0xFFFF)
  GL_BOLD_BIT_NV*: GLenum = GLenum(0x01)
  GL_ITALIC_BIT_NV*: GLenum = GLenum(0x02)
  GL_GLYPH_WIDTH_BIT_NV*: GLenum = GLenum(0x01)
  GL_GLYPH_HEIGHT_BIT_NV*: GLenum = GLenum(0x02)
  GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV*: GLenum = GLenum(0x04)
  GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV*: GLenum = GLenum(0x08)
  GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV*: GLenum = GLenum(0x10)
  GL_GLYPH_VERTICAL_BEARING_X_BIT_NV*: GLenum = GLenum(0x20)
  GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV*: GLenum = GLenum(0x40)
  GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV*: GLenum = GLenum(0x80)
  GL_GLYPH_HAS_KERNING_BIT_NV*: GLenum = GLenum(0x100)
  GL_FONT_X_MIN_BOUNDS_BIT_NV*: GLenum = GLenum(0x00010000)
  GL_FONT_Y_MIN_BOUNDS_BIT_NV*: GLenum = GLenum(0x00020000)
  GL_FONT_X_MAX_BOUNDS_BIT_NV*: GLenum = GLenum(0x00040000)
  GL_FONT_Y_MAX_BOUNDS_BIT_NV*: GLenum = GLenum(0x00080000)
  GL_FONT_UNITS_PER_EM_BIT_NV*: GLenum = GLenum(0x00100000)
  GL_FONT_ASCENDER_BIT_NV*: GLenum = GLenum(0x00200000)
  GL_FONT_DESCENDER_BIT_NV*: GLenum = GLenum(0x00400000)
  GL_FONT_HEIGHT_BIT_NV*: GLenum = GLenum(0x00800000)
  GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV*: GLenum = GLenum(0x01000000)
  GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV*: GLenum = GLenum(0x02000000)
  GL_FONT_UNDERLINE_POSITION_BIT_NV*: GLenum = GLenum(0x04000000)
  GL_FONT_UNDERLINE_THICKNESS_BIT_NV*: GLenum = GLenum(0x08000000)
  GL_FONT_HAS_KERNING_BIT_NV*: GLenum = GLenum(0x10000000)
  GL_FONT_NUM_GLYPH_INDICES_BIT_NV*: GLenum = GLenum(0x20000000)
  GL_PERFQUERY_SINGLE_CONTEXT_INTEL*: GLenum = GLenum(0x00000000)
  GL_PERFQUERY_GLOBAL_CONTEXT_INTEL*: GLenum = GLenum(0x00000001)
  GL_VERTEX23_BIT_PGI*: GLenum = GLenum(0x00000004)
  GL_VERTEX4_BIT_PGI*: GLenum = GLenum(0x00000008)
  GL_COLOR3_BIT_PGI*: GLenum = GLenum(0x00010000)
  GL_COLOR4_BIT_PGI*: GLenum = GLenum(0x00020000)
  GL_EDGEFLAG_BIT_PGI*: GLenum = GLenum(0x00040000)
  GL_INDEX_BIT_PGI*: GLenum = GLenum(0x00080000)
  GL_MAT_AMBIENT_BIT_PGI*: GLenum = GLenum(0x00100000)
  GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI*: GLenum = GLenum(0x00200000)
  GL_MAT_DIFFUSE_BIT_PGI*: GLenum = GLenum(0x00400000)
  GL_MAT_EMISSION_BIT_PGI*: GLenum = GLenum(0x00800000)
  GL_MAT_COLOR_INDEXES_BIT_PGI*: GLenum = GLenum(0x01000000)
  GL_MAT_SHININESS_BIT_PGI*: GLenum = GLenum(0x02000000)
  GL_MAT_SPECULAR_BIT_PGI*: GLenum = GLenum(0x04000000)
  GL_NORMAL_BIT_PGI*: GLenum = GLenum(0x08000000)
  GL_TEXCOORD1_BIT_PGI*: GLenum = GLenum(0x10000000)
  GL_TEXCOORD2_BIT_PGI*: GLenum = GLenum(0x20000000)
  GL_TEXCOORD3_BIT_PGI*: GLenum = GLenum(0x40000000)
  GL_TEXCOORD4_BIT_PGI*: GLenum = GLenum(0x80000000)
  GL_COLOR_BUFFER_BIT0_QCOM*: GLenum = GLenum(0x00000001)
  GL_COLOR_BUFFER_BIT1_QCOM*: GLenum = GLenum(0x00000002)
  GL_COLOR_BUFFER_BIT2_QCOM*: GLenum = GLenum(0x00000004)
  GL_COLOR_BUFFER_BIT3_QCOM*: GLenum = GLenum(0x00000008)
  GL_COLOR_BUFFER_BIT4_QCOM*: GLenum = GLenum(0x00000010)
  GL_COLOR_BUFFER_BIT5_QCOM*: GLenum = GLenum(0x00000020)
  GL_COLOR_BUFFER_BIT6_QCOM*: GLenum = GLenum(0x00000040)
  GL_COLOR_BUFFER_BIT7_QCOM*: GLenum = GLenum(0x00000080)
  GL_DEPTH_BUFFER_BIT0_QCOM*: GLenum = GLenum(0x00000100)
  GL_DEPTH_BUFFER_BIT1_QCOM*: GLenum = GLenum(0x00000200)
  GL_DEPTH_BUFFER_BIT2_QCOM*: GLenum = GLenum(0x00000400)
  GL_DEPTH_BUFFER_BIT3_QCOM*: GLenum = GLenum(0x00000800)
  GL_DEPTH_BUFFER_BIT4_QCOM*: GLenum = GLenum(0x00001000)
  GL_DEPTH_BUFFER_BIT5_QCOM*: GLenum = GLenum(0x00002000)
  GL_DEPTH_BUFFER_BIT6_QCOM*: GLenum = GLenum(0x00004000)
  GL_DEPTH_BUFFER_BIT7_QCOM*: GLenum = GLenum(0x00008000)
  GL_STENCIL_BUFFER_BIT0_QCOM*: GLenum = GLenum(0x00010000)
  GL_STENCIL_BUFFER_BIT1_QCOM*: GLenum = GLenum(0x00020000)
  GL_STENCIL_BUFFER_BIT2_QCOM*: GLenum = GLenum(0x00040000)
  GL_STENCIL_BUFFER_BIT3_QCOM*: GLenum = GLenum(0x00080000)
  GL_STENCIL_BUFFER_BIT4_QCOM*: GLenum = GLenum(0x00100000)
  GL_STENCIL_BUFFER_BIT5_QCOM*: GLenum = GLenum(0x00200000)
  GL_STENCIL_BUFFER_BIT6_QCOM*: GLenum = GLenum(0x00400000)
  GL_STENCIL_BUFFER_BIT7_QCOM*: GLenum = GLenum(0x00800000)
  GL_MULTISAMPLE_BUFFER_BIT0_QCOM*: GLenum = GLenum(0x01000000)
  GL_MULTISAMPLE_BUFFER_BIT1_QCOM*: GLenum = GLenum(0x02000000)
  GL_MULTISAMPLE_BUFFER_BIT2_QCOM*: GLenum = GLenum(0x04000000)
  GL_MULTISAMPLE_BUFFER_BIT3_QCOM*: GLenum = GLenum(0x08000000)
  GL_MULTISAMPLE_BUFFER_BIT4_QCOM*: GLenum = GLenum(0x10000000)
  GL_MULTISAMPLE_BUFFER_BIT5_QCOM*: GLenum = GLenum(0x20000000)
  GL_MULTISAMPLE_BUFFER_BIT6_QCOM*: GLenum = GLenum(0x40000000)
  GL_MULTISAMPLE_BUFFER_BIT7_QCOM*: GLenum = GLenum(0x80000000)
  GL_FOVEATION_ENABLE_BIT_QCOM*: GLenum = GLenum(0x00000001)
  GL_FOVEATION_SCALED_BIN_METHOD_BIT_QCOM*: GLenum = GLenum(0x00000002)
  GL_FOVEATION_SUBSAMPLED_LAYOUT_METHOD_BIT_QCOM*: GLenum = GLenum(0x00000004)
  GL_TEXTURE_DEFORMATION_BIT_SGIX*: GLenum = GLenum(0x00000001)
  GL_GEOMETRY_DEFORMATION_BIT_SGIX*: GLenum = GLenum(0x00000002)
  GL_TERMINATE_SEQUENCE_COMMAND_NV*: GLenum = GLenum(0x0000)
  GL_NOP_COMMAND_NV*: GLenum = GLenum(0x0001)
  GL_DRAW_ELEMENTS_COMMAND_NV*: GLenum = GLenum(0x0002)
  GL_DRAW_ARRAYS_COMMAND_NV*: GLenum = GLenum(0x0003)
  GL_DRAW_ELEMENTS_STRIP_COMMAND_NV*: GLenum = GLenum(0x0004)
  GL_DRAW_ARRAYS_STRIP_COMMAND_NV*: GLenum = GLenum(0x0005)
  GL_DRAW_ELEMENTS_INSTANCED_COMMAND_NV*: GLenum = GLenum(0x0006)
  GL_DRAW_ARRAYS_INSTANCED_COMMAND_NV*: GLenum = GLenum(0x0007)
  GL_ELEMENT_ADDRESS_COMMAND_NV*: GLenum = GLenum(0x0008)
  GL_ATTRIBUTE_ADDRESS_COMMAND_NV*: GLenum = GLenum(0x0009)
  GL_UNIFORM_ADDRESS_COMMAND_NV*: GLenum = GLenum(0x000A)
  GL_BLEND_COLOR_COMMAND_NV*: GLenum = GLenum(0x000B)
  GL_STENCIL_REF_COMMAND_NV*: GLenum = GLenum(0x000C)
  GL_LINE_WIDTH_COMMAND_NV*: GLenum = GLenum(0x000D)
  GL_POLYGON_OFFSET_COMMAND_NV*: GLenum = GLenum(0x000E)
  GL_ALPHA_REF_COMMAND_NV*: GLenum = GLenum(0x000F)
  GL_VIEWPORT_COMMAND_NV*: GLenum = GLenum(0x0010)
  GL_SCISSOR_COMMAND_NV*: GLenum = GLenum(0x0011)
  GL_FRONT_FACE_COMMAND_NV*: GLenum = GLenum(0x0012)
  GL_LAYOUT_DEFAULT_INTEL*: GLenum = GLenum(0)
  GL_LAYOUT_LINEAR_INTEL*: GLenum = GLenum(1)
  GL_LAYOUT_LINEAR_CPU_CACHED_INTEL*: GLenum = GLenum(2)
  GL_CLOSE_PATH_NV*: GLenum = GLenum(0x00)
  GL_MOVE_TO_NV*: GLenum = GLenum(0x02)
  GL_RELATIVE_MOVE_TO_NV*: GLenum = GLenum(0x03)
  GL_LINE_TO_NV*: GLenum = GLenum(0x04)
  GL_RELATIVE_LINE_TO_NV*: GLenum = GLenum(0x05)
  GL_HORIZONTAL_LINE_TO_NV*: GLenum = GLenum(0x06)
  GL_RELATIVE_HORIZONTAL_LINE_TO_NV*: GLenum = GLenum(0x07)
  GL_VERTICAL_LINE_TO_NV*: GLenum = GLenum(0x08)
  GL_RELATIVE_VERTICAL_LINE_TO_NV*: GLenum = GLenum(0x09)
  GL_QUADRATIC_CURVE_TO_NV*: GLenum = GLenum(0x0A)
  GL_RELATIVE_QUADRATIC_CURVE_TO_NV*: GLenum = GLenum(0x0B)
  GL_CUBIC_CURVE_TO_NV*: GLenum = GLenum(0x0C)
  GL_RELATIVE_CUBIC_CURVE_TO_NV*: GLenum = GLenum(0x0D)
  GL_SMOOTH_QUADRATIC_CURVE_TO_NV*: GLenum = GLenum(0x0E)
  GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV*: GLenum = GLenum(0x0F)
  GL_SMOOTH_CUBIC_CURVE_TO_NV*: GLenum = GLenum(0x10)
  GL_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV*: GLenum = GLenum(0x11)
  GL_SMALL_CCW_ARC_TO_NV*: GLenum = GLenum(0x12)
  GL_RELATIVE_SMALL_CCW_ARC_TO_NV*: GLenum = GLenum(0x13)
  GL_SMALL_CW_ARC_TO_NV*: GLenum = GLenum(0x14)
  GL_RELATIVE_SMALL_CW_ARC_TO_NV*: GLenum = GLenum(0x15)
  GL_LARGE_CCW_ARC_TO_NV*: GLenum = GLenum(0x16)
  GL_RELATIVE_LARGE_CCW_ARC_TO_NV*: GLenum = GLenum(0x17)
  GL_LARGE_CW_ARC_TO_NV*: GLenum = GLenum(0x18)
  GL_RELATIVE_LARGE_CW_ARC_TO_NV*: GLenum = GLenum(0x19)
  GL_CONIC_CURVE_TO_NV*: GLenum = GLenum(0x1A)
  GL_RELATIVE_CONIC_CURVE_TO_NV*: GLenum = GLenum(0x1B)
  GL_SHARED_EDGE_NV*: GLenum = GLenum(0xC0)
  GL_ROUNDED_RECT_NV*: GLenum = GLenum(0xE8)
  GL_RELATIVE_ROUNDED_RECT_NV*: GLenum = GLenum(0xE9)
  GL_ROUNDED_RECT2_NV*: GLenum = GLenum(0xEA)
  GL_RELATIVE_ROUNDED_RECT2_NV*: GLenum = GLenum(0xEB)
  GL_ROUNDED_RECT4_NV*: GLenum = GLenum(0xEC)
  GL_RELATIVE_ROUNDED_RECT4_NV*: GLenum = GLenum(0xED)
  GL_ROUNDED_RECT8_NV*: GLenum = GLenum(0xEE)
  GL_RELATIVE_ROUNDED_RECT8_NV*: GLenum = GLenum(0xEF)
  GL_RESTART_PATH_NV*: GLenum = GLenum(0xF0)
  GL_DUP_FIRST_CUBIC_CURVE_TO_NV*: GLenum = GLenum(0xF2)
  GL_DUP_LAST_CUBIC_CURVE_TO_NV*: GLenum = GLenum(0xF4)
  GL_RECT_NV*: GLenum = GLenum(0xF6)
  GL_RELATIVE_RECT_NV*: GLenum = GLenum(0xF7)
  GL_CIRCULAR_CCW_ARC_TO_NV*: GLenum = GLenum(0xF8)
  GL_CIRCULAR_CW_ARC_TO_NV*: GLenum = GLenum(0xFA)
  GL_CIRCULAR_TANGENT_ARC_TO_NV*: GLenum = GLenum(0xFC)
  GL_ARC_TO_NV*: GLenum = GLenum(0xFE)
  GL_RELATIVE_ARC_TO_NV*: GLenum = GLenum(0xFF)
  GL_RESTART_SUN*: GLenum = GLenum(0x0001)
  GL_REPLACE_MIDDLE_SUN*: GLenum = GLenum(0x0002)
  GL_REPLACE_OLDEST_SUN*: GLenum = GLenum(0x0003)
  GL_FALSE*: GLenum = GLenum(0)
  GL_NO_ERROR*: GLenum = GLenum(0)
  GL_ZERO*: GLenum = GLenum(0)
  GL_NONE*: GLenum = GLenum(0)
  GL_NONE_OES*: GLenum = GLenum(0)
  GL_TRUE*: GLenum = GLenum(1)
  GL_ONE*: GLenum = GLenum(1)
  GL_ALL_PIXELS_AMD*: GLenum = GLenum(0xFFFFFFFF)
  GL_VERSION_ES_CL_1_0*: GLenum = GLenum(1) ## Not an API enum. API definition macro for ES 1.0/1.1 headers
  GL_VERSION_ES_CM_1_1*: GLenum = GLenum(1) ## Not an API enum. API definition macro for ES 1.0/1.1 headers
  GL_VERSION_ES_CL_1_1*: GLenum = GLenum(1) ## Not an API enum. API definition macro for ES 1.0/1.1 headers
  GL_UUID_SIZE_EXT*: GLenum = GLenum(16)
  GL_LUID_SIZE_EXT*: GLenum = GLenum(8)
  GL_POINTS*: GLenum = GLenum(0x0000)
  GL_LINES*: GLenum = GLenum(0x0001)
  GL_LINE_LOOP*: GLenum = GLenum(0x0002)
  GL_LINE_STRIP*: GLenum = GLenum(0x0003)
  GL_TRIANGLES*: GLenum = GLenum(0x0004)
  GL_TRIANGLE_STRIP*: GLenum = GLenum(0x0005)
  GL_TRIANGLE_FAN*: GLenum = GLenum(0x0006)
  GL_CONSERVE_MEMORY_HINT_PGI*: GLenum = GLenum(0x1A1FD)
  GL_QUADS_EXT*: GLenum = GLenum(0x0007)
  GL_QUADS_OES*: GLenum = GLenum(0x0007)
  GL_RECLAIM_MEMORY_HINT_PGI*: GLenum = GLenum(0x1A1FE)
  GL_PREFER_DOUBLEBUFFER_HINT_PGI*: GLenum = GLenum(0x1A1F8)
  GL_LINES_ADJACENCY*: GLenum = GLenum(0x000A)
  GL_LINES_ADJACENCY_ARB*: GLenum = GLenum(0x000A)
  GL_LINES_ADJACENCY_EXT*: GLenum = GLenum(0x000A)
  GL_LINES_ADJACENCY_OES*: GLenum = GLenum(0x000A)
  GL_LINE_STRIP_ADJACENCY*: GLenum = GLenum(0x000B)
  GL_LINE_STRIP_ADJACENCY_ARB*: GLenum = GLenum(0x000B)
  GL_LINE_STRIP_ADJACENCY_EXT*: GLenum = GLenum(0x000B)
  GL_LINE_STRIP_ADJACENCY_OES*: GLenum = GLenum(0x000B)
  GL_TRIANGLES_ADJACENCY*: GLenum = GLenum(0x000C)
  GL_TRIANGLES_ADJACENCY_ARB*: GLenum = GLenum(0x000C)
  GL_TRIANGLES_ADJACENCY_EXT*: GLenum = GLenum(0x000C)
  GL_TRIANGLES_ADJACENCY_OES*: GLenum = GLenum(0x000C)
  GL_TRIANGLE_STRIP_ADJACENCY*: GLenum = GLenum(0x000D)
  GL_TRIANGLE_STRIP_ADJACENCY_ARB*: GLenum = GLenum(0x000D)
  GL_TRIANGLE_STRIP_ADJACENCY_EXT*: GLenum = GLenum(0x000D)
  GL_TRIANGLE_STRIP_ADJACENCY_OES*: GLenum = GLenum(0x000D)
  GL_PATCHES*: GLenum = GLenum(0x000E)
  GL_PATCHES_EXT*: GLenum = GLenum(0x000E)
  GL_PATCHES_OES*: GLenum = GLenum(0x000E)
  GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM*: GLenum = GLenum(103087)
  GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM*: GLenum = GLenum(103086)
  GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM*: GLenum = GLenum(103085)
  GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM*: GLenum = GLenum(103084)
  GL_INDEX_ARRAY_LIST_STRIDE_IBM*: GLenum = GLenum(103083)
  GL_NEVER*: GLenum = GLenum(0x0200)
  GL_LESS*: GLenum = GLenum(0x0201)
  GL_EQUAL*: GLenum = GLenum(0x0202)
  GL_LEQUAL*: GLenum = GLenum(0x0203)
  GL_GREATER*: GLenum = GLenum(0x0204)
  GL_NOTEQUAL*: GLenum = GLenum(0x0205)
  GL_GEQUAL*: GLenum = GLenum(0x0206)
  GL_ALWAYS*: GLenum = GLenum(0x0207)
  GL_SRC_COLOR*: GLenum = GLenum(0x0300)
  GL_ONE_MINUS_SRC_COLOR*: GLenum = GLenum(0x0301)
  GL_SRC_ALPHA*: GLenum = GLenum(0x0302)
  GL_ONE_MINUS_SRC_ALPHA*: GLenum = GLenum(0x0303)
  GL_DST_ALPHA*: GLenum = GLenum(0x0304)
  GL_ONE_MINUS_DST_ALPHA*: GLenum = GLenum(0x0305)
  GL_DST_COLOR*: GLenum = GLenum(0x0306)
  GL_ONE_MINUS_DST_COLOR*: GLenum = GLenum(0x0307)
  GL_SRC_ALPHA_SATURATE*: GLenum = GLenum(0x0308)
  GL_SRC_ALPHA_SATURATE_EXT*: GLenum = GLenum(0x0308)
  GL_FRONT_LEFT*: GLenum = GLenum(0x0400)
  GL_FRONT_RIGHT*: GLenum = GLenum(0x0401)
  GL_BACK_LEFT*: GLenum = GLenum(0x0402)
  GL_BACK_RIGHT*: GLenum = GLenum(0x0403)
  GL_FRONT*: GLenum = GLenum(0x0404)
  GL_BACK*: GLenum = GLenum(0x0405)
  GL_LEFT*: GLenum = GLenum(0x0406)
  GL_RIGHT*: GLenum = GLenum(0x0407)
  GL_FRONT_AND_BACK*: GLenum = GLenum(0x0408)
  GL_VERTEX_ARRAY_LIST_STRIDE_IBM*: GLenum = GLenum(103080)
  GL_SECONDARY_COLOR_ARRAY_LIST_IBM*: GLenum = GLenum(103077)
  GL_FOG_COORDINATE_ARRAY_LIST_IBM*: GLenum = GLenum(103076)
  GL_EDGE_FLAG_ARRAY_LIST_IBM*: GLenum = GLenum(103075)
  GL_INVALID_ENUM*: GLenum = GLenum(0x0500)
  GL_INVALID_VALUE*: GLenum = GLenum(0x0501)
  GL_INVALID_OPERATION*: GLenum = GLenum(0x0502)
  GL_COLOR_ARRAY_LIST_STRIDE_IBM*: GLenum = GLenum(103082)
  GL_STACK_OVERFLOW_KHR*: GLenum = GLenum(0x0503)
  GL_NORMAL_ARRAY_LIST_STRIDE_IBM*: GLenum = GLenum(103081)
  GL_STACK_UNDERFLOW_KHR*: GLenum = GLenum(0x0504)
  GL_OUT_OF_MEMORY*: GLenum = GLenum(0x0505)
  GL_INVALID_FRAMEBUFFER_OPERATION*: GLenum = GLenum(0x0506)
  GL_INVALID_FRAMEBUFFER_OPERATION_EXT*: GLenum = GLenum(0x0506)
  GL_INVALID_FRAMEBUFFER_OPERATION_OES*: GLenum = GLenum(0x0506)
  GL_CONTEXT_LOST*: GLenum = GLenum(0x0507)
  GL_CONTEXT_LOST_KHR*: GLenum = GLenum(0x0507)
  GL_TEXTURE_COORD_ARRAY_LIST_IBM*: GLenum = GLenum(103074)
  GL_INDEX_ARRAY_LIST_IBM*: GLenum = GLenum(103073)
  GL_COLOR_ARRAY_LIST_IBM*: GLenum = GLenum(103072)
  GL_NORMAL_ARRAY_LIST_IBM*: GLenum = GLenum(103071)
  GL_VERTEX_ARRAY_LIST_IBM*: GLenum = GLenum(103070)
  GL_STATIC_VERTEX_ARRAY_IBM*: GLenum = GLenum(103061)
  GL_ALL_STATIC_DATA_IBM*: GLenum = GLenum(103060)
  GL_CULL_VERTEX_IBM*: GLenum = GLenum(103050)
  GL_RASTER_POSITION_UNCLIPPED_IBM*: GLenum = GLenum(0x19262)
  GL_FRAMEBUFFER_FETCH_NONCOHERENT_QCOM*: GLenum = GLenum(0x96A2)
  GL_FRAMEBUFFER_INCOMPLETE_INSUFFICIENT_SHADER_COMBINED_LOCAL_STORAGE_EXT*: GLenum = GLenum(0x9652)
  GL_MAX_SHADER_COMBINED_LOCAL_STORAGE_SIZE_EXT*: GLenum = GLenum(0x9651)
  GL_MAX_SHADER_COMBINED_LOCAL_STORAGE_FAST_SIZE_EXT*: GLenum = GLenum(0x9650)
  GL_GS_PROGRAM_BINARY_MTK*: GLenum = GLenum(0x9641)
  GL_GS_SHADER_BINARY_MTK*: GLenum = GLenum(0x9640)
  GL_CW*: GLenum = GLenum(0x0900)
  GL_CCW*: GLenum = GLenum(0x0901)
  GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR*: GLenum = GLenum(0x9633)
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR*: GLenum = GLenum(0x9632)
  GL_MAX_VIEWS_OVR*: GLenum = GLenum(0x9631)
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TASK_SHADER_NV*: GLenum = GLenum(0x959F)
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_MESH_SHADER_NV*: GLenum = GLenum(0x959E)
  GL_UNIFORM_BLOCK_REFERENCED_BY_TASK_SHADER_NV*: GLenum = GLenum(0x959D)
  GL_UNIFORM_BLOCK_REFERENCED_BY_MESH_SHADER_NV*: GLenum = GLenum(0x959C)
  GL_PROTECTED_MEMORY_OBJECT_EXT*: GLenum = GLenum(0x959B)
  GL_DEVICE_NODE_MASK_EXT*: GLenum = GLenum(0x959A)
  GL_DEVICE_LUID_EXT*: GLenum = GLenum(0x9599)
  GL_DRIVER_UUID_EXT*: GLenum = GLenum(0x9598)
  GL_DEVICE_UUID_EXT*: GLenum = GLenum(0x9597)
  GL_NUM_DEVICE_UUIDS_EXT*: GLenum = GLenum(0x9596)
  GL_D3D12_FENCE_VALUE_EXT*: GLenum = GLenum(0x9595)
  GL_POINT_SIZE*: GLenum = GLenum(0x0B11)
  GL_POINT_SIZE_RANGE*: GLenum = GLenum(0x0B12)
  GL_SMOOTH_POINT_SIZE_RANGE*: GLenum = GLenum(0x0B12)
  GL_POINT_SIZE_GRANULARITY*: GLenum = GLenum(0x0B13)
  GL_SMOOTH_POINT_SIZE_GRANULARITY*: GLenum = GLenum(0x0B13)
  GL_LINE_SMOOTH*: GLenum = GLenum(0x0B20)
  GL_LINE_WIDTH*: GLenum = GLenum(0x0B21)
  GL_LINE_WIDTH_RANGE*: GLenum = GLenum(0x0B22)
  GL_SMOOTH_LINE_WIDTH_RANGE*: GLenum = GLenum(0x0B22)
  GL_LINE_WIDTH_GRANULARITY*: GLenum = GLenum(0x0B23)
  GL_SMOOTH_LINE_WIDTH_GRANULARITY*: GLenum = GLenum(0x0B23)
  GL_HANDLE_TYPE_D3D12_FENCE_EXT*: GLenum = GLenum(0x9594)
  GL_LAYOUT_TRANSFER_DST_EXT*: GLenum = GLenum(0x9593)
  GL_LAYOUT_TRANSFER_SRC_EXT*: GLenum = GLenum(0x9592)
  GL_LAYOUT_SHADER_READ_ONLY_EXT*: GLenum = GLenum(0x9591)
  GL_LAYOUT_DEPTH_STENCIL_READ_ONLY_EXT*: GLenum = GLenum(0x9590)
  GL_LAYOUT_DEPTH_STENCIL_ATTACHMENT_EXT*: GLenum = GLenum(0x958F)
  GL_LAYOUT_COLOR_ATTACHMENT_EXT*: GLenum = GLenum(0x958E)
  GL_POLYGON_MODE*: GLenum = GLenum(0x0B40)
  GL_POLYGON_MODE_NV*: GLenum = GLenum(0x0B40)
  GL_POLYGON_SMOOTH*: GLenum = GLenum(0x0B41)
  GL_LAYOUT_GENERAL_EXT*: GLenum = GLenum(0x958D)
  GL_HANDLE_TYPE_D3D11_IMAGE_KMT_EXT*: GLenum = GLenum(0x958C)
  GL_CULL_FACE*: GLenum = GLenum(0x0B44)
  GL_CULL_FACE_MODE*: GLenum = GLenum(0x0B45)
  GL_FRONT_FACE*: GLenum = GLenum(0x0B46)
  GL_HANDLE_TYPE_D3D11_IMAGE_EXT*: GLenum = GLenum(0x958B)
  GL_HANDLE_TYPE_D3D12_RESOURCE_EXT*: GLenum = GLenum(0x958A)
  GL_HANDLE_TYPE_D3D12_TILEPOOL_EXT*: GLenum = GLenum(0x9589)
  GL_HANDLE_TYPE_OPAQUE_WIN32_KMT_EXT*: GLenum = GLenum(0x9588)
  GL_HANDLE_TYPE_OPAQUE_WIN32_EXT*: GLenum = GLenum(0x9587)
  GL_HANDLE_TYPE_OPAQUE_FD_EXT*: GLenum = GLenum(0x9586)
  GL_LINEAR_TILING_EXT*: GLenum = GLenum(0x9585)
  GL_OPTIMAL_TILING_EXT*: GLenum = GLenum(0x9584)
  GL_TILING_TYPES_EXT*: GLenum = GLenum(0x9583)
  GL_NUM_TILING_TYPES_EXT*: GLenum = GLenum(0x9582)
  GL_DEDICATED_MEMORY_OBJECT_EXT*: GLenum = GLenum(0x9581)
  GL_TEXTURE_TILING_EXT*: GLenum = GLenum(0x9580)
  GL_TASK_SUBROUTINE_UNIFORM_NV*: GLenum = GLenum(0x957F)
  GL_MESH_SUBROUTINE_UNIFORM_NV*: GLenum = GLenum(0x957E)
  GL_TASK_SUBROUTINE_NV*: GLenum = GLenum(0x957D)
  GL_DEPTH_RANGE*: GLenum = GLenum(0x0B70)
  GL_DEPTH_TEST*: GLenum = GLenum(0x0B71)
  GL_DEPTH_WRITEMASK*: GLenum = GLenum(0x0B72)
  GL_DEPTH_CLEAR_VALUE*: GLenum = GLenum(0x0B73)
  GL_DEPTH_FUNC*: GLenum = GLenum(0x0B74)
  GL_MESH_SUBROUTINE_NV*: GLenum = GLenum(0x957C)
  GL_STENCIL_TEST*: GLenum = GLenum(0x0B90)
  GL_STENCIL_CLEAR_VALUE*: GLenum = GLenum(0x0B91)
  GL_STENCIL_FUNC*: GLenum = GLenum(0x0B92)
  GL_STENCIL_VALUE_MASK*: GLenum = GLenum(0x0B93)
  GL_STENCIL_FAIL*: GLenum = GLenum(0x0B94)
  GL_STENCIL_PASS_DEPTH_FAIL*: GLenum = GLenum(0x0B95)
  GL_STENCIL_PASS_DEPTH_PASS*: GLenum = GLenum(0x0B96)
  GL_STENCIL_REF*: GLenum = GLenum(0x0B97)
  GL_STENCIL_WRITEMASK*: GLenum = GLenum(0x0B98)
  GL_MESH_OUTPUT_TYPE_NV*: GLenum = GLenum(0x957B)
  GL_MESH_PRIMITIVES_OUT_NV*: GLenum = GLenum(0x957A)
  GL_VIEWPORT*: GLenum = GLenum(0x0BA2)
  GL_MESH_VERTICES_OUT_NV*: GLenum = GLenum(0x9579)
  GL_MODELVIEW0_STACK_DEPTH_EXT*: GLenum = GLenum(0x0BA3)
  GL_PATH_MODELVIEW_STACK_DEPTH_NV*: GLenum = GLenum(0x0BA3)
  GL_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV*: GLenum = GLenum(0x956F)
  GL_PATH_PROJECTION_STACK_DEPTH_NV*: GLenum = GLenum(0x0BA4)
  GL_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV*: GLenum = GLenum(0x956E)
  GL_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV*: GLenum = GLenum(0x956D)
  GL_MODELVIEW0_MATRIX_EXT*: GLenum = GLenum(0x0BA6)
  GL_PATH_MODELVIEW_MATRIX_NV*: GLenum = GLenum(0x0BA6)
  GL_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV*: GLenum = GLenum(0x956C)
  GL_PATH_PROJECTION_MATRIX_NV*: GLenum = GLenum(0x0BA7)
  GL_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV*: GLenum = GLenum(0x956B)
  GL_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV*: GLenum = GLenum(0x956A)
  GL_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV*: GLenum = GLenum(0x9569)
  GL_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV*: GLenum = GLenum(0x9568)
  GL_ALPHA_TEST_QCOM*: GLenum = GLenum(0x0BC0)
  GL_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV*: GLenum = GLenum(0x9567)
  GL_ALPHA_TEST_FUNC_QCOM*: GLenum = GLenum(0x0BC1)
  GL_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV*: GLenum = GLenum(0x9566)
  GL_ALPHA_TEST_REF_QCOM*: GLenum = GLenum(0x0BC2)
  GL_DITHER*: GLenum = GLenum(0x0BD0)
  GL_BLEND_DST*: GLenum = GLenum(0x0BE0)
  GL_BLEND_SRC*: GLenum = GLenum(0x0BE1)
  GL_BLEND*: GLenum = GLenum(0x0BE2)
  GL_LOGIC_OP_MODE*: GLenum = GLenum(0x0BF0)
  GL_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV*: GLenum = GLenum(0x9565)
  GL_SHADING_RATE_NO_INVOCATIONS_NV*: GLenum = GLenum(0x9564)
  GL_COLOR_LOGIC_OP*: GLenum = GLenum(0x0BF2)
  GL_SHADING_RATE_IMAGE_NV*: GLenum = GLenum(0x9563)
  GL_DRAW_BUFFER*: GLenum = GLenum(0x0C01)
  GL_DRAW_BUFFER_EXT*: GLenum = GLenum(0x0C01)
  GL_READ_BUFFER*: GLenum = GLenum(0x0C02)
  GL_READ_BUFFER_EXT*: GLenum = GLenum(0x0C02)
  GL_READ_BUFFER_NV*: GLenum = GLenum(0x0C02)
  GL_SCISSOR_BOX*: GLenum = GLenum(0x0C10)
  GL_SCISSOR_TEST*: GLenum = GLenum(0x0C11)
  GL_MAX_COARSE_FRAGMENT_SAMPLES_NV*: GLenum = GLenum(0x955F)
  GL_SHADING_RATE_IMAGE_PALETTE_SIZE_NV*: GLenum = GLenum(0x955E)
  GL_COLOR_CLEAR_VALUE*: GLenum = GLenum(0x0C22)
  GL_COLOR_WRITEMASK*: GLenum = GLenum(0x0C23)
  GL_SHADING_RATE_IMAGE_TEXEL_HEIGHT_NV*: GLenum = GLenum(0x955D)
  GL_SHADING_RATE_IMAGE_TEXEL_WIDTH_NV*: GLenum = GLenum(0x955C)
  GL_DOUBLEBUFFER*: GLenum = GLenum(0x0C32)
  GL_STEREO*: GLenum = GLenum(0x0C33)
  GL_SHADING_RATE_IMAGE_BINDING_NV*: GLenum = GLenum(0x955B)
  GL_TASK_SHADER_NV*: GLenum = GLenum(0x955A)
  GL_MESH_SHADER_NV*: GLenum = GLenum(0x9559)
  GL_LINE_SMOOTH_HINT*: GLenum = GLenum(0x0C52)
  GL_POLYGON_SMOOTH_HINT*: GLenum = GLenum(0x0C53)
  GL_RENDER_GPU_MASK_NV*: GLenum = GLenum(0x9558)
  GL_MAX_MESH_VIEWS_NV*: GLenum = GLenum(0x9557)
  GL_SCISSOR_BOX_EXCLUSIVE_NV*: GLenum = GLenum(0x9556)
  GL_SCISSOR_TEST_EXCLUSIVE_NV*: GLenum = GLenum(0x9555)
  GL_NUM_SPIR_V_EXTENSIONS*: GLenum = GLenum(0x9554)
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR*: GLenum = GLenum(0x9630)
  GL_SHADING_RATE_SAMPLE_ORDER_SAMPLE_MAJOR_NV*: GLenum = GLenum(0x95B0)
  GL_SHADING_RATE_SAMPLE_ORDER_PIXEL_MAJOR_NV*: GLenum = GLenum(0x95AF)
  GL_SHADING_RATE_SAMPLE_ORDER_DEFAULT_NV*: GLenum = GLenum(0x95AE)
  GL_MAX_DETACHED_BUFFERS_NV*: GLenum = GLenum(0x95AD)
  GL_MAX_DETACHED_TEXTURES_NV*: GLenum = GLenum(0x95AC)
  GL_DETACHED_BUFFERS_NV*: GLenum = GLenum(0x95AB)
  GL_DETACHED_TEXTURES_NV*: GLenum = GLenum(0x95AA)
  GL_DETACHED_MEMORY_INCARNATION_NV*: GLenum = GLenum(0x95A9)
  GL_MEMORY_ATTACHABLE_NV*: GLenum = GLenum(0x95A8)
  GL_SPIR_V_EXTENSIONS*: GLenum = GLenum(0x9553)
  GL_SPIR_V_BINARY_ARB*: GLenum = GLenum(0x9552)
  GL_SPIR_V_BINARY*: GLenum = GLenum(0x9552)
  GL_SHADER_BINARY_FORMAT_SPIR_V_ARB*: GLenum = GLenum(0x9551)
  GL_SHADER_BINARY_FORMAT_SPIR_V*: GLenum = GLenum(0x9551)
  GL_CONSERVATIVE_RASTER_MODE_PRE_SNAP_NV*: GLenum = GLenum(0x9550)
  GL_CONSERVATIVE_RASTER_MODE_PRE_SNAP_TRIANGLES_NV*: GLenum = GLenum(0x954F)
  GL_CONSERVATIVE_RASTER_MODE_POST_SNAP_NV*: GLenum = GLenum(0x954E)
  GL_CONSERVATIVE_RASTER_MODE_NV*: GLenum = GLenum(0x954D)
  GL_MULTICAST_PROGRAMMABLE_SAMPLE_LOCATION_NV*: GLenum = GLenum(0x9549)
  GL_UNPACK_SWAP_BYTES*: GLenum = GLenum(0x0CF0)
  GL_UNPACK_LSB_FIRST*: GLenum = GLenum(0x0CF1)
  GL_UNPACK_ROW_LENGTH*: GLenum = GLenum(0x0CF2)
  GL_UNPACK_ROW_LENGTH_EXT*: GLenum = GLenum(0x0CF2)
  GL_UNPACK_SKIP_ROWS*: GLenum = GLenum(0x0CF3)
  GL_UNPACK_SKIP_ROWS_EXT*: GLenum = GLenum(0x0CF3)
  GL_UNPACK_SKIP_PIXELS*: GLenum = GLenum(0x0CF4)
  GL_UNPACK_SKIP_PIXELS_EXT*: GLenum = GLenum(0x0CF4)
  GL_UNPACK_ALIGNMENT*: GLenum = GLenum(0x0CF5)
  GL_PACK_SWAP_BYTES*: GLenum = GLenum(0x0D00)
  GL_PACK_LSB_FIRST*: GLenum = GLenum(0x0D01)
  GL_PACK_ROW_LENGTH*: GLenum = GLenum(0x0D02)
  GL_PACK_SKIP_ROWS*: GLenum = GLenum(0x0D03)
  GL_PACK_SKIP_PIXELS*: GLenum = GLenum(0x0D04)
  GL_PACK_ALIGNMENT*: GLenum = GLenum(0x0D05)
  GL_PER_GPU_STORAGE_NV*: GLenum = GLenum(0x9548)
  GL_QUERY_RESOURCE_BUFFEROBJECT_NV*: GLenum = GLenum(0x9547)
  GL_QUERY_RESOURCE_RENDERBUFFER_NV*: GLenum = GLenum(0x9546)
  GL_QUERY_RESOURCE_TEXTURE_NV*: GLenum = GLenum(0x9545)
  GL_QUERY_RESOURCE_SYS_RESERVED_NV*: GLenum = GLenum(0x9544)
  GL_MESH_OUTPUT_PER_PRIMITIVE_GRANULARITY_NV*: GLenum = GLenum(0x9543)
  GL_QUERY_RESOURCE_MEMTYPE_VIDMEM_NV*: GLenum = GLenum(0x9542)
  GL_QUERY_RESOURCE_TYPE_VIDMEM_ALLOC_NV*: GLenum = GLenum(0x9540)
  GL_TASK_WORK_GROUP_SIZE_NV*: GLenum = GLenum(0x953F)
  GL_MESH_WORK_GROUP_SIZE_NV*: GLenum = GLenum(0x953E)
  GL_MAX_DRAW_MESH_TASKS_COUNT_NV*: GLenum = GLenum(0x953D)
  GL_MAX_TASK_WORK_GROUP_SIZE_NV*: GLenum = GLenum(0x953C)
  GL_MAX_MESH_WORK_GROUP_SIZE_NV*: GLenum = GLenum(0x953B)
  GL_MAX_TASK_OUTPUT_COUNT_NV*: GLenum = GLenum(0x953A)
  GL_MAX_MESH_OUTPUT_PRIMITIVES_NV*: GLenum = GLenum(0x9539)
  GL_MAX_MESH_OUTPUT_VERTICES_NV*: GLenum = GLenum(0x9538)
  GL_MAX_TASK_TOTAL_MEMORY_SIZE_NV*: GLenum = GLenum(0x9537)
  GL_MAX_MESH_TOTAL_MEMORY_SIZE_NV*: GLenum = GLenum(0x9536)
  GL_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_EXT*: GLenum = GLenum(0x9531)
  GL_MAX_CLIP_PLANES_IMG*: GLenum = GLenum(0x0D32)
  GL_MAX_CLIP_DISTANCES*: GLenum = GLenum(0x0D32)
  GL_MAX_CLIP_DISTANCES_EXT*: GLenum = GLenum(0x0D32)
  GL_MAX_CLIP_DISTANCES_APPLE*: GLenum = GLenum(0x0D32)
  GL_MAX_TEXTURE_SIZE*: GLenum = GLenum(0x0D33)
  GL_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_EXT*: GLenum = GLenum(0x9530)
  GL_PERFQUERY_GPA_EXTENDED_COUNTERS_INTEL*: GLenum = GLenum(0x9500)
  GL_PERFQUERY_COUNTER_DESC_LENGTH_MAX_INTEL*: GLenum = GLenum(0x94FF)
  GL_PATH_MAX_MODELVIEW_STACK_DEPTH_NV*: GLenum = GLenum(0x0D36)
  GL_PERFQUERY_COUNTER_NAME_LENGTH_MAX_INTEL*: GLenum = GLenum(0x94FE)
  GL_PERFQUERY_QUERY_NAME_LENGTH_MAX_INTEL*: GLenum = GLenum(0x94FD)
  GL_PATH_MAX_PROJECTION_STACK_DEPTH_NV*: GLenum = GLenum(0x0D38)
  GL_PERFQUERY_COUNTER_DATA_BOOL32_INTEL*: GLenum = GLenum(0x94FC)
  GL_MAX_VIEWPORT_DIMS*: GLenum = GLenum(0x0D3A)
  GL_PERFQUERY_COUNTER_DATA_DOUBLE_INTEL*: GLenum = GLenum(0x94FB)
  GL_SUBPIXEL_BITS*: GLenum = GLenum(0x0D50)
  GL_PERFQUERY_COUNTER_DATA_FLOAT_INTEL*: GLenum = GLenum(0x94FA)
  GL_PERFQUERY_COUNTER_DATA_UINT64_INTEL*: GLenum = GLenum(0x94F9)
  GL_PERFQUERY_COUNTER_DATA_UINT32_INTEL*: GLenum = GLenum(0x94F8)
  GL_PERFQUERY_COUNTER_TIMESTAMP_INTEL*: GLenum = GLenum(0x94F5)
  GL_PERFQUERY_COUNTER_RAW_INTEL*: GLenum = GLenum(0x94F4)
  GL_PERFQUERY_COUNTER_THROUGHPUT_INTEL*: GLenum = GLenum(0x94F3)
  GL_PERFQUERY_COUNTER_DURATION_RAW_INTEL*: GLenum = GLenum(0x94F2)
  GL_PERFQUERY_COUNTER_DURATION_NORM_INTEL*: GLenum = GLenum(0x94F1)
  GL_PERFQUERY_COUNTER_EVENT_INTEL*: GLenum = GLenum(0x94F0)
  GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2_IMG*: GLenum = GLenum(0x93F1)
  GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2_IMG*: GLenum = GLenum(0x93F0)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES*: GLenum = GLenum(0x93E9)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES*: GLenum = GLenum(0x93E8)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES*: GLenum = GLenum(0x93E7)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES*: GLenum = GLenum(0x93E6)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES*: GLenum = GLenum(0x93E5)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES*: GLenum = GLenum(0x93E4)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES*: GLenum = GLenum(0x93E3)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES*: GLenum = GLenum(0x93E2)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES*: GLenum = GLenum(0x93E1)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES*: GLenum = GLenum(0x93E0)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR*: GLenum = GLenum(0x93DD)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12*: GLenum = GLenum(0x93DD)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR*: GLenum = GLenum(0x93DC)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10*: GLenum = GLenum(0x93DC)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR*: GLenum = GLenum(0x93DB)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10*: GLenum = GLenum(0x93DB)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR*: GLenum = GLenum(0x93DA)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8*: GLenum = GLenum(0x93DA)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR*: GLenum = GLenum(0x93D9)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6*: GLenum = GLenum(0x93D9)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR*: GLenum = GLenum(0x93D8)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5*: GLenum = GLenum(0x93D8)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR*: GLenum = GLenum(0x93D7)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8*: GLenum = GLenum(0x93D7)
  GL_TEXTURE_1D*: GLenum = GLenum(0x0DE0)
  GL_TEXTURE_2D*: GLenum = GLenum(0x0DE1)
  GL_REFERENCED_BY_TASK_SHADER_NV*: GLenum = GLenum(0x95A1)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR*: GLenum = GLenum(0x93D6)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6*: GLenum = GLenum(0x93D6)
  GL_REFERENCED_BY_MESH_SHADER_NV*: GLenum = GLenum(0x95A0)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR*: GLenum = GLenum(0x93D5)
  GL_TEXTURE_WIDTH*: GLenum = GLenum(0x1000)
  GL_TEXTURE_HEIGHT*: GLenum = GLenum(0x1001)
  GL_TEXTURE_INTERNAL_FORMAT*: GLenum = GLenum(0x1003)
  GL_COMPRESSED_RGBA_ASTC_3x3x3_OES*: GLenum = GLenum(0x93C0)
  GL_TEXTURE_BORDER_COLOR*: GLenum = GLenum(0x1004)
  GL_TEXTURE_BORDER_COLOR_EXT*: GLenum = GLenum(0x1004)
  GL_TEXTURE_BORDER_COLOR_NV*: GLenum = GLenum(0x1004)
  GL_TEXTURE_BORDER_COLOR_OES*: GLenum = GLenum(0x1004)
  GL_COMPRESSED_RGBA_ASTC_12x12_KHR*: GLenum = GLenum(0x93BD)
  GL_TEXTURE_TARGET*: GLenum = GLenum(0x1006)
  GL_DONT_CARE*: GLenum = GLenum(0x1100)
  GL_FASTEST*: GLenum = GLenum(0x1101)
  GL_NICEST*: GLenum = GLenum(0x1102)
  GL_COMPRESSED_RGBA_ASTC_10x10*: GLenum = GLenum(0x93BB)
  GL_COMPRESSED_RGBA_ASTC_10x8_KHR*: GLenum = GLenum(0x93BA)
  GL_COMPRESSED_RGBA_ASTC_10x8*: GLenum = GLenum(0x93BA)
  GL_COMPRESSED_RGBA_ASTC_10x6_KHR*: GLenum = GLenum(0x93B9)
  GL_COMPRESSED_RGBA_ASTC_10x6*: GLenum = GLenum(0x93B9)
  GL_COMPRESSED_RGBA_ASTC_10x5_KHR*: GLenum = GLenum(0x93B8)
  GL_COMPRESSED_RGBA_ASTC_10x5*: GLenum = GLenum(0x93B8)
  GL_COMPRESSED_RGBA_ASTC_8x8_KHR*: GLenum = GLenum(0x93B7)
  GL_COMPRESSED_RGBA_ASTC_8x8*: GLenum = GLenum(0x93B7)
  GL_COMPRESSED_RGBA_ASTC_8x6_KHR*: GLenum = GLenum(0x93B6)
  GL_COMPRESSED_RGBA_ASTC_8x6*: GLenum = GLenum(0x93B6)
  GL_COMPRESSED_RGBA_ASTC_8x5_KHR*: GLenum = GLenum(0x93B5)
  EGL_BYTE*: GLenum = GLenum(0x1400)
  GL_UNSIGNED_BYTE*: GLenum = GLenum(0x1401)
  EGL_SHORT*: GLenum = GLenum(0x1402)
  GL_UNSIGNED_SHORT*: GLenum = GLenum(0x1403)
  EGL_INT*: GLenum = GLenum(0x1404)
  GL_UNSIGNED_INT*: GLenum = GLenum(0x1405)
  EGL_FLOAT*: GLenum = GLenum(0x1406)
  GL_COMPRESSED_RGBA_ASTC_8x5*: GLenum = GLenum(0x93B5)
  GL_2_BYTES_NV*: GLenum = GLenum(0x1407)
  GL_COMPRESSED_RGBA_ASTC_6x6_KHR*: GLenum = GLenum(0x93B4)
  GL_3_BYTES_NV*: GLenum = GLenum(0x1408)
  GL_COMPRESSED_RGBA_ASTC_6x6*: GLenum = GLenum(0x93B4)
  GL_4_BYTES_NV*: GLenum = GLenum(0x1409)
  EGL_DOUBLE*: GLenum = GLenum(0x140A)
  GL_DOUBLE_EXT*: GLenum = GLenum(0x140A)
  GL_HALF_FLOAT*: GLenum = GLenum(0x140B)
  GL_HALF_FLOAT_ARB*: GLenum = GLenum(0x140B)
  GL_HALF_FLOAT_NV*: GLenum = GLenum(0x140B)
  GL_HALF_APPLE*: GLenum = GLenum(0x140B)
  EGL_FIXED*: GLenum = GLenum(0x140C)
  GL_FIXED_OES*: GLenum = GLenum(0x140C)
  GL_INT64_ARB*: GLenum = GLenum(0x140E)
  GL_INT64_NV*: GLenum = GLenum(0x140E)
  GL_UNSIGNED_INT64_ARB*: GLenum = GLenum(0x140F)
  GL_UNSIGNED_INT64_NV*: GLenum = GLenum(0x140F)
  GL_CLEAR*: GLenum = GLenum(0x1500)
  GL_AND*: GLenum = GLenum(0x1501)
  GL_AND_REVERSE*: GLenum = GLenum(0x1502)
  GL_COPY*: GLenum = GLenum(0x1503)
  GL_AND_INVERTED*: GLenum = GLenum(0x1504)
  GL_NOOP*: GLenum = GLenum(0x1505)
  GL_XOR*: GLenum = GLenum(0x1506)
  GL_XOR_NV*: GLenum = GLenum(0x1506)
  GL_OR*: GLenum = GLenum(0x1507)
  GL_NOR*: GLenum = GLenum(0x1508)
  GL_EQUIV*: GLenum = GLenum(0x1509)
  GL_INVERT*: GLenum = GLenum(0x150A)
  GL_OR_REVERSE*: GLenum = GLenum(0x150B)
  GL_COPY_INVERTED*: GLenum = GLenum(0x150C)
  GL_OR_INVERTED*: GLenum = GLenum(0x150D)
  GL_NAND*: GLenum = GLenum(0x150E)
  GL_SET*: GLenum = GLenum(0x150F)
  GL_COMPRESSED_RGBA_ASTC_6x5_KHR*: GLenum = GLenum(0x93B3)
  GL_COMPRESSED_RGBA_ASTC_6x5*: GLenum = GLenum(0x93B3)
  GL_COMPRESSED_RGBA_ASTC_5x5_KHR*: GLenum = GLenum(0x93B2)
  GL_COMPRESSED_RGBA_ASTC_5x5*: GLenum = GLenum(0x93B2)
  GL_COMPRESSED_RGBA_ASTC_5x4_KHR*: GLenum = GLenum(0x93B1)
  GL_MODELVIEW0_ARB*: GLenum = GLenum(0x1700)
  GL_MODELVIEW0_EXT*: GLenum = GLenum(0x1700)
  GL_PATH_MODELVIEW_NV*: GLenum = GLenum(0x1700)
  GL_COMPRESSED_RGBA_ASTC_5x4*: GLenum = GLenum(0x93B1)
  GL_PATH_PROJECTION_NV*: GLenum = GLenum(0x1701)
  GL_TEXTURE*: GLenum = GLenum(0x1702)
  GL_COLOR*: GLenum = GLenum(0x1800)
  GL_COLOR_EXT*: GLenum = GLenum(0x1800)
  GL_DEPTH*: GLenum = GLenum(0x1801)
  GL_DEPTH_EXT*: GLenum = GLenum(0x1801)
  GL_STENCIL*: GLenum = GLenum(0x1802)
  GL_STENCIL_EXT*: GLenum = GLenum(0x1802)
  GL_COMPRESSED_RGBA_ASTC_4x4_KHR*: GLenum = GLenum(0x93B0)
  GL_STENCIL_INDEX*: GLenum = GLenum(0x1901)
  GL_STENCIL_INDEX_OES*: GLenum = GLenum(0x1901)
  GL_DEPTH_COMPONENT*: GLenum = GLenum(0x1902)
  GL_RED*: GLenum = GLenum(0x1903)
  GL_RED_EXT*: GLenum = GLenum(0x1903)
  GL_RED_NV*: GLenum = GLenum(0x1903)
  GL_GREEN*: GLenum = GLenum(0x1904)
  GL_GREEN_NV*: GLenum = GLenum(0x1904)
  GL_BLUE*: GLenum = GLenum(0x1905)
  GL_BLUE_NV*: GLenum = GLenum(0x1905)
  GL_ALPHA*: GLenum = GLenum(0x1906)
  GL_RGB*: GLenum = GLenum(0x1907)
  GL_RGBA*: GLenum = GLenum(0x1908)
  GL_COMPRESSED_RGBA_ASTC_4x4*: GLenum = GLenum(0x93B0)
  GL_PROGRAM_BINARY_ANGLE*: GLenum = GLenum(0x93A6)
  GL_PACK_REVERSE_ROW_ORDER_ANGLE*: GLenum = GLenum(0x93A4)
  GL_POINT*: GLenum = GLenum(0x1B00)
  GL_POINT_NV*: GLenum = GLenum(0x1B00)
  GL_LINE*: GLenum = GLenum(0x1B01)
  GL_LINE_NV*: GLenum = GLenum(0x1B01)
  GL_FILL*: GLenum = GLenum(0x1B02)
  GL_FILL_NV*: GLenum = GLenum(0x1B02)
  GL_FRAMEBUFFER_ATTACHMENT_ANGLE*: GLenum = GLenum(0x93A3)
  GL_TEXTURE_USAGE_ANGLE*: GLenum = GLenum(0x93A2)
  GL_BGRA8_EXT*: GLenum = GLenum(0x93A1)
  GL_TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE*: GLenum = GLenum(0x93A0)
  GL_MULTISAMPLE_LINE_WIDTH_GRANULARITY*: GLenum = GLenum(0x9382)
  GL_KEEP*: GLenum = GLenum(0x1E00)
  GL_REPLACE*: GLenum = GLenum(0x1E01)
  GL_INCR*: GLenum = GLenum(0x1E02)
  GL_DECR*: GLenum = GLenum(0x1E03)
  GL_VENDOR*: GLenum = GLenum(0x1F00)
  GL_RENDERER*: GLenum = GLenum(0x1F01)
  GL_VERSION*: GLenum = GLenum(0x1F02)
  GL_EXTENSIONS*: GLenum = GLenum(0x1F03)
  GL_MULTISAMPLE_LINE_WIDTH_GRANULARITY_ARB*: GLenum = GLenum(0x9382)
  GL_MULTISAMPLE_LINE_WIDTH_RANGE*: GLenum = GLenum(0x9381)
  GL_MULTISAMPLE_LINE_WIDTH_RANGE_ARB*: GLenum = GLenum(0x9381)
  GL_NUM_SAMPLE_COUNTS*: GLenum = GLenum(0x9380)
  GL_REPRESENTATIVE_FRAGMENT_TEST_NV*: GLenum = GLenum(0x937F)
  GL_VIEWPORT_POSITION_W_SCALE_Y_COEFF_NV*: GLenum = GLenum(0x937E)
  GL_VIEWPORT_POSITION_W_SCALE_X_COEFF_NV*: GLenum = GLenum(0x937D)
  GL_VIEWPORT_POSITION_W_SCALE_NV*: GLenum = GLenum(0x937C)
  GL_CONSERVATIVE_RASTER_DILATE_GRANULARITY_NV*: GLenum = GLenum(0x937B)
  GL_CONSERVATIVE_RASTER_DILATE_RANGE_NV*: GLenum = GLenum(0x937A)
  GL_EYE_LINEAR_NV*: GLenum = GLenum(0x2400)
  GL_CONSERVATIVE_RASTER_DILATE_NV*: GLenum = GLenum(0x9379)
  GL_OBJECT_LINEAR_NV*: GLenum = GLenum(0x2401)
  GL_CONFORMANT_NV*: GLenum = GLenum(0x9374)
  GL_SUPERSAMPLE_SCALE_Y_NV*: GLenum = GLenum(0x9373)
  GL_TEXTURE_GEN_MODE_OES*: GLenum = GLenum(0x2500)
  GL_SUPERSAMPLE_SCALE_X_NV*: GLenum = GLenum(0x9372)
  GL_MULTISAMPLES_NV*: GLenum = GLenum(0x9371)
  GL_NEAREST*: GLenum = GLenum(0x2600)
  GL_LINEAR*: GLenum = GLenum(0x2601)
  GL_NEAREST_MIPMAP_NEAREST*: GLenum = GLenum(0x2700)
  GL_LINEAR_MIPMAP_NEAREST*: GLenum = GLenum(0x2701)
  GL_NEAREST_MIPMAP_LINEAR*: GLenum = GLenum(0x2702)
  GL_LINEAR_MIPMAP_LINEAR*: GLenum = GLenum(0x2703)
  GL_TEXTURE_MAG_FILTER*: GLenum = GLenum(0x2800)
  GL_TEXTURE_MIN_FILTER*: GLenum = GLenum(0x2801)
  GL_TEXTURE_WRAP_S*: GLenum = GLenum(0x2802)
  GL_TEXTURE_WRAP_T*: GLenum = GLenum(0x2803)
  GL_UNIFORM_BUFFER_LENGTH_NV*: GLenum = GLenum(0x9370)
  GL_REPEAT*: GLenum = GLenum(0x2901)
  GL_POLYGON_OFFSET_UNITS*: GLenum = GLenum(0x2A00)
  GL_POLYGON_OFFSET_POINT*: GLenum = GLenum(0x2A01)
  GL_POLYGON_OFFSET_POINT_NV*: GLenum = GLenum(0x2A01)
  GL_POLYGON_OFFSET_LINE*: GLenum = GLenum(0x2A02)
  GL_POLYGON_OFFSET_LINE_NV*: GLenum = GLenum(0x2A02)
  GL_R3_G3_B2*: GLenum = GLenum(0x2A10)
  GL_CLIP_ORIGIN_EXT*: GLenum = GLenum(0x935C)
  GL_CLIP_ORIGIN*: GLenum = GLenum(0x935C)
  GL_VIEWPORT_SWIZZLE_W_NV*: GLenum = GLenum(0x935B)
  GL_VIEWPORT_SWIZZLE_Z_NV*: GLenum = GLenum(0x935A)
  GL_VIEWPORT_SWIZZLE_Y_NV*: GLenum = GLenum(0x9359)
  GL_VIEWPORT_SWIZZLE_X_NV*: GLenum = GLenum(0x9358)
  GL_VIEWPORT_SWIZZLE_NEGATIVE_W_NV*: GLenum = GLenum(0x9357)
  GL_VIEWPORT_SWIZZLE_POSITIVE_W_NV*: GLenum = GLenum(0x9356)
  GL_VIEWPORT_SWIZZLE_NEGATIVE_Z_NV*: GLenum = GLenum(0x9355)
  GL_VIEWPORT_SWIZZLE_POSITIVE_Z_NV*: GLenum = GLenum(0x9354)
  GL_VIEWPORT_SWIZZLE_NEGATIVE_Y_NV*: GLenum = GLenum(0x9353)
  GL_VIEWPORT_SWIZZLE_POSITIVE_Y_NV*: GLenum = GLenum(0x9352)
  GL_VIEWPORT_SWIZZLE_NEGATIVE_X_NV*: GLenum = GLenum(0x9351)
  GL_VIEWPORT_SWIZZLE_POSITIVE_X_NV*: GLenum = GLenum(0x9350)
  GL_ALPHA_TO_COVERAGE_DITHER_DISABLE_NV*: GLenum = GLenum(0x934F)
  GL_CLIP_PLANE0_IMG*: GLenum = GLenum(0x3000)
  GL_CLIP_DISTANCE0*: GLenum = GLenum(0x3000)
  GL_CLIP_DISTANCE0_EXT*: GLenum = GLenum(0x3000)
  GL_CLIP_DISTANCE0_APPLE*: GLenum = GLenum(0x3000)
  GL_ALPHA_TO_COVERAGE_DITHER_ENABLE_NV*: GLenum = GLenum(0x934E)
  GL_CLIP_PLANE1_IMG*: GLenum = GLenum(0x3001)
  GL_CLIP_DISTANCE1*: GLenum = GLenum(0x3001)
  GL_CLIP_DISTANCE1_EXT*: GLenum = GLenum(0x3001)
  GL_CLIP_DISTANCE1_APPLE*: GLenum = GLenum(0x3001)
  GL_ALPHA_TO_COVERAGE_DITHER_DEFAULT_NV*: GLenum = GLenum(0x934D)
  GL_CLIP_PLANE2_IMG*: GLenum = GLenum(0x3002)
  GL_CLIP_DISTANCE2*: GLenum = GLenum(0x3002)
  GL_CLIP_DISTANCE2_EXT*: GLenum = GLenum(0x3002)
  GL_CLIP_DISTANCE2_APPLE*: GLenum = GLenum(0x3002)
  GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE*: GLenum = GLenum(0x934C)
  GL_CLIP_PLANE3_IMG*: GLenum = GLenum(0x3003)
  GL_CLIP_DISTANCE3*: GLenum = GLenum(0x3003)
  GL_CLIP_DISTANCE3_EXT*: GLenum = GLenum(0x3003)
  GL_CLIP_DISTANCE3_APPLE*: GLenum = GLenum(0x3003)
  GL_TRANSFORM_FEEDBACK_BUFFER_INDEX*: GLenum = GLenum(0x934B)
  GL_CLIP_PLANE4_IMG*: GLenum = GLenum(0x3004)
  GL_CLIP_DISTANCE4*: GLenum = GLenum(0x3004)
  GL_CLIP_DISTANCE4_EXT*: GLenum = GLenum(0x3004)
  GL_CLIP_DISTANCE4_APPLE*: GLenum = GLenum(0x3004)
  GL_LOCATION_COMPONENT*: GLenum = GLenum(0x934A)
  GL_CLIP_PLANE5_IMG*: GLenum = GLenum(0x3005)
  GL_CLIP_DISTANCE5*: GLenum = GLenum(0x3005)
  GL_CLIP_DISTANCE5_EXT*: GLenum = GLenum(0x3005)
  GL_CLIP_DISTANCE5_APPLE*: GLenum = GLenum(0x3005)
  GL_CLIP_DISTANCE6*: GLenum = GLenum(0x3006)
  GL_CLIP_DISTANCE6_EXT*: GLenum = GLenum(0x3006)
  GL_CLIP_DISTANCE6_APPLE*: GLenum = GLenum(0x3006)
  GL_CLIP_DISTANCE7*: GLenum = GLenum(0x3007)
  GL_CLIP_DISTANCE7_EXT*: GLenum = GLenum(0x3007)
  GL_CLIP_DISTANCE7_APPLE*: GLenum = GLenum(0x3007)
  GL_MAX_SUBPIXEL_PRECISION_BIAS_BITS_NV*: GLenum = GLenum(0x9349)
  GL_SUBPIXEL_PRECISION_BIAS_Y_BITS_NV*: GLenum = GLenum(0x9348)
  GL_SUBPIXEL_PRECISION_BIAS_X_BITS_NV*: GLenum = GLenum(0x9347)
  GL_CONSERVATIVE_RASTERIZATION_NV*: GLenum = GLenum(0x9346)
  GL_MAX_COMPUTE_VARIABLE_GROUP_SIZE_ARB*: GLenum = GLenum(0x9345)
  GL_MAX_COMPUTE_VARIABLE_GROUP_INVOCATIONS_ARB*: GLenum = GLenum(0x9344)
  GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_NV*: GLenum = GLenum(0x9343)
  GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_ARB*: GLenum = GLenum(0x9343)
  GL_ABGR_EXT*: GLenum = GLenum(0x8000)
  GL_CONSTANT_COLOR*: GLenum = GLenum(0x8001)
  GL_CONSTANT_COLOR_EXT*: GLenum = GLenum(0x8001)
  GL_ONE_MINUS_CONSTANT_COLOR*: GLenum = GLenum(0x8002)
  GL_ONE_MINUS_CONSTANT_COLOR_EXT*: GLenum = GLenum(0x8002)
  GL_CONSTANT_ALPHA*: GLenum = GLenum(0x8003)
  GL_CONSTANT_ALPHA_EXT*: GLenum = GLenum(0x8003)
  GL_ONE_MINUS_CONSTANT_ALPHA*: GLenum = GLenum(0x8004)
  GL_ONE_MINUS_CONSTANT_ALPHA_EXT*: GLenum = GLenum(0x8004)
  GL_BLEND_COLOR*: GLenum = GLenum(0x8005)
  GL_BLEND_COLOR_EXT*: GLenum = GLenum(0x8005)
  GL_FUNC_ADD*: GLenum = GLenum(0x8006)
  GL_FUNC_ADD_EXT*: GLenum = GLenum(0x8006)
  GL_FUNC_ADD_OES*: GLenum = GLenum(0x8006)
  GL_MIN*: GLenum = GLenum(0x8007)
  GL_MIN_EXT*: GLenum = GLenum(0x8007)
  GL_MAX*: GLenum = GLenum(0x8008)
  GL_MAX_EXT*: GLenum = GLenum(0x8008)
  GL_BLEND_EQUATION*: GLenum = GLenum(0x8009)
  GL_BLEND_EQUATION_EXT*: GLenum = GLenum(0x8009)
  GL_BLEND_EQUATION_OES*: GLenum = GLenum(0x8009)
  GL_BLEND_EQUATION_RGB*: GLenum = GLenum(0x8009)
  GL_BLEND_EQUATION_RGB_EXT*: GLenum = GLenum(0x8009)
  GL_BLEND_EQUATION_RGB_OES*: GLenum = GLenum(0x8009)
  GL_FUNC_SUBTRACT*: GLenum = GLenum(0x800A)
  GL_FUNC_SUBTRACT_EXT*: GLenum = GLenum(0x800A)
  GL_FUNC_SUBTRACT_OES*: GLenum = GLenum(0x800A)
  GL_FUNC_REVERSE_SUBTRACT*: GLenum = GLenum(0x800B)
  GL_FUNC_REVERSE_SUBTRACT_EXT*: GLenum = GLenum(0x800B)
  GL_FUNC_REVERSE_SUBTRACT_OES*: GLenum = GLenum(0x800B)
  GL_CMYK_EXT*: GLenum = GLenum(0x800C)
  GL_CMYKA_EXT*: GLenum = GLenum(0x800D)
  GL_PACK_CMYK_HINT_EXT*: GLenum = GLenum(0x800E)
  GL_UNPACK_CMYK_HINT_EXT*: GLenum = GLenum(0x800F)
  GL_CONVOLUTION_1D*: GLenum = GLenum(0x8010)
  GL_CONVOLUTION_1D_EXT*: GLenum = GLenum(0x8010)
  GL_CONVOLUTION_2D*: GLenum = GLenum(0x8011)
  GL_CONVOLUTION_2D_EXT*: GLenum = GLenum(0x8011)
  GL_SEPARABLE_2D*: GLenum = GLenum(0x8012)
  GL_SEPARABLE_2D_EXT*: GLenum = GLenum(0x8012)
  GL_CONVOLUTION_BORDER_MODE*: GLenum = GLenum(0x8013)
  GL_CONVOLUTION_BORDER_MODE_EXT*: GLenum = GLenum(0x8013)
  GL_CONVOLUTION_FILTER_SCALE*: GLenum = GLenum(0x8014)
  GL_CONVOLUTION_FILTER_SCALE_EXT*: GLenum = GLenum(0x8014)
  GL_CONVOLUTION_FILTER_BIAS*: GLenum = GLenum(0x8015)
  GL_CONVOLUTION_FILTER_BIAS_EXT*: GLenum = GLenum(0x8015)
  GL_REDUCE*: GLenum = GLenum(0x8016)
  GL_REDUCE_EXT*: GLenum = GLenum(0x8016)
  GL_CONVOLUTION_FORMAT*: GLenum = GLenum(0x8017)
  GL_CONVOLUTION_FORMAT_EXT*: GLenum = GLenum(0x8017)
  GL_CONVOLUTION_WIDTH*: GLenum = GLenum(0x8018)
  GL_CONVOLUTION_WIDTH_EXT*: GLenum = GLenum(0x8018)
  GL_CONVOLUTION_HEIGHT*: GLenum = GLenum(0x8019)
  GL_CONVOLUTION_HEIGHT_EXT*: GLenum = GLenum(0x8019)
  GL_MAX_CONVOLUTION_WIDTH*: GLenum = GLenum(0x801A)
  GL_MAX_CONVOLUTION_WIDTH_EXT*: GLenum = GLenum(0x801A)
  GL_MAX_CONVOLUTION_HEIGHT*: GLenum = GLenum(0x801B)
  GL_MAX_CONVOLUTION_HEIGHT_EXT*: GLenum = GLenum(0x801B)
  GL_POST_CONVOLUTION_RED_SCALE*: GLenum = GLenum(0x801C)
  GL_POST_CONVOLUTION_RED_SCALE_EXT*: GLenum = GLenum(0x801C)
  GL_POST_CONVOLUTION_GREEN_SCALE*: GLenum = GLenum(0x801D)
  GL_POST_CONVOLUTION_GREEN_SCALE_EXT*: GLenum = GLenum(0x801D)
  GL_POST_CONVOLUTION_BLUE_SCALE*: GLenum = GLenum(0x801E)
  GL_POST_CONVOLUTION_BLUE_SCALE_EXT*: GLenum = GLenum(0x801E)
  GL_POST_CONVOLUTION_ALPHA_SCALE*: GLenum = GLenum(0x801F)
  GL_POST_CONVOLUTION_ALPHA_SCALE_EXT*: GLenum = GLenum(0x801F)
  GL_POST_CONVOLUTION_RED_BIAS*: GLenum = GLenum(0x8020)
  GL_POST_CONVOLUTION_RED_BIAS_EXT*: GLenum = GLenum(0x8020)
  GL_POST_CONVOLUTION_GREEN_BIAS*: GLenum = GLenum(0x8021)
  GL_POST_CONVOLUTION_GREEN_BIAS_EXT*: GLenum = GLenum(0x8021)
  GL_POST_CONVOLUTION_BLUE_BIAS*: GLenum = GLenum(0x8022)
  GL_POST_CONVOLUTION_BLUE_BIAS_EXT*: GLenum = GLenum(0x8022)
  GL_POST_CONVOLUTION_ALPHA_BIAS*: GLenum = GLenum(0x8023)
  GL_POST_CONVOLUTION_ALPHA_BIAS_EXT*: GLenum = GLenum(0x8023)
  GL_HISTOGRAM*: GLenum = GLenum(0x8024)
  GL_HISTOGRAM_EXT*: GLenum = GLenum(0x8024)
  GL_PROXY_HISTOGRAM*: GLenum = GLenum(0x8025)
  GL_PROXY_HISTOGRAM_EXT*: GLenum = GLenum(0x8025)
  GL_HISTOGRAM_WIDTH*: GLenum = GLenum(0x8026)
  GL_HISTOGRAM_WIDTH_EXT*: GLenum = GLenum(0x8026)
  GL_HISTOGRAM_FORMAT*: GLenum = GLenum(0x8027)
  GL_HISTOGRAM_FORMAT_EXT*: GLenum = GLenum(0x8027)
  GL_HISTOGRAM_RED_SIZE*: GLenum = GLenum(0x8028)
  GL_HISTOGRAM_RED_SIZE_EXT*: GLenum = GLenum(0x8028)
  GL_HISTOGRAM_GREEN_SIZE*: GLenum = GLenum(0x8029)
  GL_HISTOGRAM_GREEN_SIZE_EXT*: GLenum = GLenum(0x8029)
  GL_HISTOGRAM_BLUE_SIZE*: GLenum = GLenum(0x802A)
  GL_HISTOGRAM_BLUE_SIZE_EXT*: GLenum = GLenum(0x802A)
  GL_HISTOGRAM_ALPHA_SIZE*: GLenum = GLenum(0x802B)
  GL_HISTOGRAM_ALPHA_SIZE_EXT*: GLenum = GLenum(0x802B)
  GL_HISTOGRAM_LUMINANCE_SIZE*: GLenum = GLenum(0x802C)
  GL_HISTOGRAM_LUMINANCE_SIZE_EXT*: GLenum = GLenum(0x802C)
  GL_HISTOGRAM_SINK*: GLenum = GLenum(0x802D)
  GL_HISTOGRAM_SINK_EXT*: GLenum = GLenum(0x802D)
  GL_MINMAX*: GLenum = GLenum(0x802E)
  GL_MINMAX_EXT*: GLenum = GLenum(0x802E)
  GL_MINMAX_FORMAT*: GLenum = GLenum(0x802F)
  GL_MINMAX_FORMAT_EXT*: GLenum = GLenum(0x802F)
  GL_MINMAX_SINK*: GLenum = GLenum(0x8030)
  GL_MINMAX_SINK_EXT*: GLenum = GLenum(0x8030)
  GL_TABLE_TOO_LARGE_EXT*: GLenum = GLenum(0x8031)
  GL_TABLE_TOO_LARGE*: GLenum = GLenum(0x8031)
  GL_UNSIGNED_BYTE_3_3_2*: GLenum = GLenum(0x8032)
  GL_UNSIGNED_BYTE_3_3_2_EXT*: GLenum = GLenum(0x8032)
  GL_UNSIGNED_SHORT_4_4_4_4*: GLenum = GLenum(0x8033)
  GL_UNSIGNED_SHORT_4_4_4_4_EXT*: GLenum = GLenum(0x8033)
  GL_UNSIGNED_SHORT_5_5_5_1*: GLenum = GLenum(0x8034)
  GL_UNSIGNED_SHORT_5_5_5_1_EXT*: GLenum = GLenum(0x8034)
  GL_UNSIGNED_INT_8_8_8_8*: GLenum = GLenum(0x8035)
  GL_UNSIGNED_INT_8_8_8_8_EXT*: GLenum = GLenum(0x8035)
  GL_UNSIGNED_INT_10_10_10_2*: GLenum = GLenum(0x8036)
  GL_UNSIGNED_INT_10_10_10_2_EXT*: GLenum = GLenum(0x8036)
  GL_POLYGON_OFFSET_EXT*: GLenum = GLenum(0x8037)
  GL_POLYGON_OFFSET_FILL*: GLenum = GLenum(0x8037)
  GL_POLYGON_OFFSET_FACTOR*: GLenum = GLenum(0x8038)
  GL_POLYGON_OFFSET_FACTOR_EXT*: GLenum = GLenum(0x8038)
  GL_POLYGON_OFFSET_BIAS_EXT*: GLenum = GLenum(0x8039)
  GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_NV*: GLenum = GLenum(0x9342)
  GL_RESCALE_NORMAL_EXT*: GLenum = GLenum(0x803A)
  GL_UNIFORM_BUFFER_ADDRESS_NV*: GLenum = GLenum(0x936F)
  GL_ALPHA4_EXT*: GLenum = GLenum(0x803B)
  GL_UNIFORM_BUFFER_UNIFIED_NV*: GLenum = GLenum(0x936E)
  GL_ALPHA8_EXT*: GLenum = GLenum(0x803C)
  GL_ALPHA8_OES*: GLenum = GLenum(0x803C)
  GL_FRAGMENT_INPUT_NV*: GLenum = GLenum(0x936D)
  GL_ALPHA12_EXT*: GLenum = GLenum(0x803D)
  GL_STANDARD_FONT_FORMAT_NV*: GLenum = GLenum(0x936C)
  GL_ALPHA16_EXT*: GLenum = GLenum(0x803E)
  GL_FONT_UNINTELLIGIBLE_NV*: GLenum = GLenum(0x936B)
  GL_LUMINANCE4_EXT*: GLenum = GLenum(0x803F)
  GL_FONT_UNAVAILABLE_NV*: GLenum = GLenum(0x936A)
  GL_LUMINANCE8_EXT*: GLenum = GLenum(0x8040)
  GL_LUMINANCE8_OES*: GLenum = GLenum(0x8040)
  GL_FONT_TARGET_UNAVAILABLE_NV*: GLenum = GLenum(0x9369)
  GL_LUMINANCE12_EXT*: GLenum = GLenum(0x8041)
  GL_FONT_GLYPHS_AVAILABLE_NV*: GLenum = GLenum(0x9368)
  GL_LUMINANCE16_EXT*: GLenum = GLenum(0x8042)
  GL_WEIGHTED_AVERAGE_EXT*: GLenum = GLenum(0x9367)
  GL_LUMINANCE4_ALPHA4_EXT*: GLenum = GLenum(0x8043)
  GL_LUMINANCE4_ALPHA4_OES*: GLenum = GLenum(0x8043)
  GL_WEIGHTED_AVERAGE_ARB*: GLenum = GLenum(0x9367)
  GL_LUMINANCE6_ALPHA2_EXT*: GLenum = GLenum(0x8044)
  GL_TEXTURE_REDUCTION_MODE_EXT*: GLenum = GLenum(0x9366)
  GL_LUMINANCE8_ALPHA8_EXT*: GLenum = GLenum(0x8045)
  GL_LUMINANCE8_ALPHA8_OES*: GLenum = GLenum(0x8045)
  GL_TEXTURE_REDUCTION_MODE_ARB*: GLenum = GLenum(0x9366)
  GL_LUMINANCE12_ALPHA4_EXT*: GLenum = GLenum(0x8046)
  GL_CLEAR_TEXTURE*: GLenum = GLenum(0x9365)
  GL_LUMINANCE12_ALPHA12_EXT*: GLenum = GLenum(0x8047)
  GL_ZERO_TO_ONE_EXT*: GLenum = GLenum(0x935F)
  GL_LUMINANCE16_ALPHA16_EXT*: GLenum = GLenum(0x8048)
  GL_ZERO_TO_ONE*: GLenum = GLenum(0x935F)
  GL_INTENSITY_EXT*: GLenum = GLenum(0x8049)
  GL_NEGATIVE_ONE_TO_ONE_EXT*: GLenum = GLenum(0x935E)
  GL_INTENSITY4_EXT*: GLenum = GLenum(0x804A)
  GL_NEGATIVE_ONE_TO_ONE*: GLenum = GLenum(0x935E)
  GL_INTENSITY8_EXT*: GLenum = GLenum(0x804B)
  GL_CLIP_DEPTH_MODE_EXT*: GLenum = GLenum(0x935D)
  GL_INTENSITY12_EXT*: GLenum = GLenum(0x804C)
  GL_CLIP_DEPTH_MODE*: GLenum = GLenum(0x935D)
  GL_INTENSITY16_EXT*: GLenum = GLenum(0x804D)
  GL_RGB2_EXT*: GLenum = GLenum(0x804E)
  GL_RGB4*: GLenum = GLenum(0x804F)
  GL_RGB4_EXT*: GLenum = GLenum(0x804F)
  GL_RGB5*: GLenum = GLenum(0x8050)
  GL_RGB5_EXT*: GLenum = GLenum(0x8050)
  GL_RGB8*: GLenum = GLenum(0x8051)
  GL_RGB8_EXT*: GLenum = GLenum(0x8051)
  GL_RGB8_OES*: GLenum = GLenum(0x8051)
  GL_RGB10*: GLenum = GLenum(0x8052)
  GL_RGB10_EXT*: GLenum = GLenum(0x8052)
  GL_RGB12*: GLenum = GLenum(0x8053)
  GL_RGB12_EXT*: GLenum = GLenum(0x8053)
  GL_RGB16*: GLenum = GLenum(0x8054)
  GL_RGB16_EXT*: GLenum = GLenum(0x8054)
  GL_RGBA2*: GLenum = GLenum(0x8055)
  GL_RGBA2_EXT*: GLenum = GLenum(0x8055)
  GL_RGBA4*: GLenum = GLenum(0x8056)
  GL_RGBA4_EXT*: GLenum = GLenum(0x8056)
  GL_RGBA4_OES*: GLenum = GLenum(0x8056)
  GL_RGB5_A1*: GLenum = GLenum(0x8057)
  GL_RGB5_A1_EXT*: GLenum = GLenum(0x8057)
  GL_RGB5_A1_OES*: GLenum = GLenum(0x8057)
  GL_RGBA8*: GLenum = GLenum(0x8058)
  GL_RGBA8_EXT*: GLenum = GLenum(0x8058)
  GL_RGBA8_OES*: GLenum = GLenum(0x8058)
  GL_RGB10_A2*: GLenum = GLenum(0x8059)
  GL_RGB10_A2_EXT*: GLenum = GLenum(0x8059)
  GL_RGBA12*: GLenum = GLenum(0x805A)
  GL_RGBA12_EXT*: GLenum = GLenum(0x805A)
  GL_RGBA16*: GLenum = GLenum(0x805B)
  GL_RGBA16_EXT*: GLenum = GLenum(0x805B)
  GL_TEXTURE_RED_SIZE*: GLenum = GLenum(0x805C)
  GL_TEXTURE_RED_SIZE_EXT*: GLenum = GLenum(0x805C)
  GL_TEXTURE_GREEN_SIZE*: GLenum = GLenum(0x805D)
  GL_TEXTURE_GREEN_SIZE_EXT*: GLenum = GLenum(0x805D)
  GL_TEXTURE_BLUE_SIZE*: GLenum = GLenum(0x805E)
  GL_TEXTURE_BLUE_SIZE_EXT*: GLenum = GLenum(0x805E)
  GL_TEXTURE_ALPHA_SIZE*: GLenum = GLenum(0x805F)
  GL_TEXTURE_ALPHA_SIZE_EXT*: GLenum = GLenum(0x805F)
  GL_COMPRESSED_RGBA_ASTC_12x12*: GLenum = GLenum(0x93BD)
  GL_TEXTURE_LUMINANCE_SIZE_EXT*: GLenum = GLenum(0x8060)
  GL_COMPRESSED_RGBA_ASTC_12x10_KHR*: GLenum = GLenum(0x93BC)
  GL_TEXTURE_INTENSITY_SIZE_EXT*: GLenum = GLenum(0x8061)
  GL_REPLACE_EXT*: GLenum = GLenum(0x8062)
  GL_PROXY_TEXTURE_1D*: GLenum = GLenum(0x8063)
  GL_PROXY_TEXTURE_1D_EXT*: GLenum = GLenum(0x8063)
  GL_PROXY_TEXTURE_2D*: GLenum = GLenum(0x8064)
  GL_PROXY_TEXTURE_2D_EXT*: GLenum = GLenum(0x8064)
  GL_TEXTURE_TOO_LARGE_EXT*: GLenum = GLenum(0x8065)
  GL_COMPRESSED_RGBA_ASTC_12x10*: GLenum = GLenum(0x93BC)
  GL_TEXTURE_PRIORITY_EXT*: GLenum = GLenum(0x8066)
  GL_COMPRESSED_RGBA_ASTC_10x10_KHR*: GLenum = GLenum(0x93BB)
  GL_TEXTURE_RESIDENT_EXT*: GLenum = GLenum(0x8067)
  GL_TEXTURE_1D_BINDING_EXT*: GLenum = GLenum(0x8068)
  GL_TEXTURE_BINDING_1D*: GLenum = GLenum(0x8068)
  GL_TEXTURE_2D_BINDING_EXT*: GLenum = GLenum(0x8069)
  GL_TEXTURE_BINDING_2D*: GLenum = GLenum(0x8069)
  GL_TEXTURE_3D_BINDING_EXT*: GLenum = GLenum(0x806A)
  GL_TEXTURE_3D_BINDING_OES*: GLenum = GLenum(0x806A)
  GL_TEXTURE_BINDING_3D*: GLenum = GLenum(0x806A)
  GL_TEXTURE_BINDING_3D_OES*: GLenum = GLenum(0x806A)
  GL_PACK_SKIP_IMAGES*: GLenum = GLenum(0x806B)
  GL_PACK_SKIP_IMAGES_EXT*: GLenum = GLenum(0x806B)
  GL_PACK_IMAGE_HEIGHT*: GLenum = GLenum(0x806C)
  GL_PACK_IMAGE_HEIGHT_EXT*: GLenum = GLenum(0x806C)
  GL_UNPACK_SKIP_IMAGES*: GLenum = GLenum(0x806D)
  GL_UNPACK_SKIP_IMAGES_EXT*: GLenum = GLenum(0x806D)
  GL_UNPACK_IMAGE_HEIGHT*: GLenum = GLenum(0x806E)
  GL_UNPACK_IMAGE_HEIGHT_EXT*: GLenum = GLenum(0x806E)
  GL_TEXTURE_3D*: GLenum = GLenum(0x806F)
  GL_TEXTURE_3D_EXT*: GLenum = GLenum(0x806F)
  GL_TEXTURE_3D_OES*: GLenum = GLenum(0x806F)
  GL_PROXY_TEXTURE_3D*: GLenum = GLenum(0x8070)
  GL_PROXY_TEXTURE_3D_EXT*: GLenum = GLenum(0x8070)
  GL_TEXTURE_DEPTH*: GLenum = GLenum(0x8071)
  GL_TEXTURE_DEPTH_EXT*: GLenum = GLenum(0x8071)
  GL_TEXTURE_WRAP_R*: GLenum = GLenum(0x8072)
  GL_TEXTURE_WRAP_R_EXT*: GLenum = GLenum(0x8072)
  GL_TEXTURE_WRAP_R_OES*: GLenum = GLenum(0x8072)
  GL_MAX_3D_TEXTURE_SIZE*: GLenum = GLenum(0x8073)
  GL_MAX_3D_TEXTURE_SIZE_EXT*: GLenum = GLenum(0x8073)
  GL_MAX_3D_TEXTURE_SIZE_OES*: GLenum = GLenum(0x8073)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5*: GLenum = GLenum(0x93D5)
  GL_VERTEX_ARRAY_EXT*: GLenum = GLenum(0x8074)
  GL_VERTEX_ARRAY_KHR*: GLenum = GLenum(0x8074)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR*: GLenum = GLenum(0x93D4)
  GL_NORMAL_ARRAY_EXT*: GLenum = GLenum(0x8075)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6*: GLenum = GLenum(0x93D4)
  GL_COLOR_ARRAY_EXT*: GLenum = GLenum(0x8076)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR*: GLenum = GLenum(0x93D3)
  GL_INDEX_ARRAY_EXT*: GLenum = GLenum(0x8077)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5*: GLenum = GLenum(0x93D3)
  GL_TEXTURE_COORD_ARRAY_EXT*: GLenum = GLenum(0x8078)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR*: GLenum = GLenum(0x93D2)
  GL_EDGE_FLAG_ARRAY_EXT*: GLenum = GLenum(0x8079)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5*: GLenum = GLenum(0x93D2)
  GL_VERTEX_ARRAY_SIZE_EXT*: GLenum = GLenum(0x807A)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR*: GLenum = GLenum(0x93D1)
  GL_VERTEX_ARRAY_TYPE_EXT*: GLenum = GLenum(0x807B)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4*: GLenum = GLenum(0x93D1)
  GL_VERTEX_ARRAY_STRIDE_EXT*: GLenum = GLenum(0x807C)
  GL_VERTEX_ARRAY_COUNT_EXT*: GLenum = GLenum(0x807D)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR*: GLenum = GLenum(0x93D0)
  GL_NORMAL_ARRAY_TYPE_EXT*: GLenum = GLenum(0x807E)
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4*: GLenum = GLenum(0x93D0)
  GL_NORMAL_ARRAY_STRIDE_EXT*: GLenum = GLenum(0x807F)
  GL_NORMAL_ARRAY_COUNT_EXT*: GLenum = GLenum(0x8080)
  GL_COMPRESSED_RGBA_ASTC_6x6x6_OES*: GLenum = GLenum(0x93C9)
  GL_COLOR_ARRAY_SIZE_EXT*: GLenum = GLenum(0x8081)
  GL_COMPRESSED_RGBA_ASTC_6x6x5_OES*: GLenum = GLenum(0x93C8)
  GL_COLOR_ARRAY_TYPE_EXT*: GLenum = GLenum(0x8082)
  GL_COMPRESSED_RGBA_ASTC_6x5x5_OES*: GLenum = GLenum(0x93C7)
  GL_COLOR_ARRAY_STRIDE_EXT*: GLenum = GLenum(0x8083)
  GL_COLOR_ARRAY_COUNT_EXT*: GLenum = GLenum(0x8084)
  GL_COMPRESSED_RGBA_ASTC_5x5x5_OES*: GLenum = GLenum(0x93C6)
  GL_INDEX_ARRAY_TYPE_EXT*: GLenum = GLenum(0x8085)
  GL_COMPRESSED_RGBA_ASTC_5x5x4_OES*: GLenum = GLenum(0x93C5)
  GL_INDEX_ARRAY_STRIDE_EXT*: GLenum = GLenum(0x8086)
  GL_INDEX_ARRAY_COUNT_EXT*: GLenum = GLenum(0x8087)
  GL_COMPRESSED_RGBA_ASTC_5x4x4_OES*: GLenum = GLenum(0x93C4)
  GL_TEXTURE_COORD_ARRAY_SIZE_EXT*: GLenum = GLenum(0x8088)
  GL_COMPRESSED_RGBA_ASTC_4x4x4_OES*: GLenum = GLenum(0x93C3)
  GL_TEXTURE_COORD_ARRAY_TYPE_EXT*: GLenum = GLenum(0x8089)
  GL_COMPRESSED_RGBA_ASTC_4x4x3_OES*: GLenum = GLenum(0x93C2)
  GL_TEXTURE_COORD_ARRAY_STRIDE_EXT*: GLenum = GLenum(0x808A)
  GL_TEXTURE_COORD_ARRAY_COUNT_EXT*: GLenum = GLenum(0x808B)
  GL_COMPRESSED_RGBA_ASTC_4x3x3_OES*: GLenum = GLenum(0x93C1)
  GL_EDGE_FLAG_ARRAY_STRIDE_EXT*: GLenum = GLenum(0x808C)
  GL_EDGE_FLAG_ARRAY_COUNT_EXT*: GLenum = GLenum(0x808D)
  GL_MEMORY_ATTACHABLE_SIZE_NV*: GLenum = GLenum(0x95A7)
  GL_VERTEX_ARRAY_POINTER_EXT*: GLenum = GLenum(0x808E)
  GL_MEMORY_ATTACHABLE_ALIGNMENT_NV*: GLenum = GLenum(0x95A6)
  GL_NORMAL_ARRAY_POINTER_EXT*: GLenum = GLenum(0x808F)
  GL_ATTACHED_MEMORY_OFFSET_NV*: GLenum = GLenum(0x95A5)
  GL_COLOR_ARRAY_POINTER_EXT*: GLenum = GLenum(0x8090)
  GL_ATTACHED_MEMORY_OBJECT_NV*: GLenum = GLenum(0x95A4)
  GL_INDEX_ARRAY_POINTER_EXT*: GLenum = GLenum(0x8091)
  GL_MAX_TASK_WORK_GROUP_INVOCATIONS_NV*: GLenum = GLenum(0x95A3)
  GL_TEXTURE_COORD_ARRAY_POINTER_EXT*: GLenum = GLenum(0x8092)
  GL_MAX_MESH_WORK_GROUP_INVOCATIONS_NV*: GLenum = GLenum(0x95A2)
  GL_EDGE_FLAG_ARRAY_POINTER_EXT*: GLenum = GLenum(0x8093)
  GL_INTERLACE_SGIX*: GLenum = GLenum(0x8094)
  GL_DETAIL_TEXTURE_2D_SGIS*: GLenum = GLenum(0x8095)
  GL_DETAIL_TEXTURE_2D_BINDING_SGIS*: GLenum = GLenum(0x8096)
  GL_LINEAR_DETAIL_SGIS*: GLenum = GLenum(0x8097)
  GL_LINEAR_DETAIL_ALPHA_SGIS*: GLenum = GLenum(0x8098)
  GL_LINEAR_DETAIL_COLOR_SGIS*: GLenum = GLenum(0x8099)
  GL_DETAIL_TEXTURE_LEVEL_SGIS*: GLenum = GLenum(0x809A)
  GL_DETAIL_TEXTURE_MODE_SGIS*: GLenum = GLenum(0x809B)
  GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS*: GLenum = GLenum(0x809C)
  GL_MULTISAMPLE*: GLenum = GLenum(0x809D)
  GL_MULTISAMPLE_ARB*: GLenum = GLenum(0x809D)
  GL_MULTISAMPLE_EXT*: GLenum = GLenum(0x809D)
  GL_MULTISAMPLE_SGIS*: GLenum = GLenum(0x809D)
  GL_SAMPLE_ALPHA_TO_COVERAGE*: GLenum = GLenum(0x809E)
  GL_SAMPLE_ALPHA_TO_COVERAGE_ARB*: GLenum = GLenum(0x809E)
  GL_SAMPLE_ALPHA_TO_MASK_EXT*: GLenum = GLenum(0x809E)
  GL_SAMPLE_ALPHA_TO_MASK_SGIS*: GLenum = GLenum(0x809E)
  GL_SAMPLE_ALPHA_TO_ONE*: GLenum = GLenum(0x809F)
  GL_SAMPLE_ALPHA_TO_ONE_ARB*: GLenum = GLenum(0x809F)
  GL_SAMPLE_ALPHA_TO_ONE_EXT*: GLenum = GLenum(0x809F)
  GL_SAMPLE_ALPHA_TO_ONE_SGIS*: GLenum = GLenum(0x809F)
  GL_SAMPLE_COVERAGE*: GLenum = GLenum(0x80A0)
  GL_SAMPLE_COVERAGE_ARB*: GLenum = GLenum(0x80A0)
  GL_SAMPLE_MASK_EXT*: GLenum = GLenum(0x80A0)
  GL_SAMPLE_MASK_SGIS*: GLenum = GLenum(0x80A0)
  GL_1PASS_EXT*: GLenum = GLenum(0x80A1)
  GL_1PASS_SGIS*: GLenum = GLenum(0x80A1)
  GL_2PASS_0_EXT*: GLenum = GLenum(0x80A2)
  GL_2PASS_0_SGIS*: GLenum = GLenum(0x80A2)
  GL_2PASS_1_EXT*: GLenum = GLenum(0x80A3)
  GL_2PASS_1_SGIS*: GLenum = GLenum(0x80A3)
  GL_4PASS_0_EXT*: GLenum = GLenum(0x80A4)
  GL_4PASS_0_SGIS*: GLenum = GLenum(0x80A4)
  GL_4PASS_1_EXT*: GLenum = GLenum(0x80A5)
  GL_4PASS_1_SGIS*: GLenum = GLenum(0x80A5)
  GL_4PASS_2_EXT*: GLenum = GLenum(0x80A6)
  GL_4PASS_2_SGIS*: GLenum = GLenum(0x80A6)
  GL_4PASS_3_EXT*: GLenum = GLenum(0x80A7)
  GL_4PASS_3_SGIS*: GLenum = GLenum(0x80A7)
  GL_SAMPLE_BUFFERS*: GLenum = GLenum(0x80A8)
  GL_SAMPLE_BUFFERS_ARB*: GLenum = GLenum(0x80A8)
  GL_SAMPLE_BUFFERS_EXT*: GLenum = GLenum(0x80A8)
  GL_SAMPLE_BUFFERS_SGIS*: GLenum = GLenum(0x80A8)
  GL_SAMPLES*: GLenum = GLenum(0x80A9)
  GL_SAMPLES_ARB*: GLenum = GLenum(0x80A9)
  GL_SAMPLES_EXT*: GLenum = GLenum(0x80A9)
  GL_SAMPLES_SGIS*: GLenum = GLenum(0x80A9)
  GL_SAMPLE_COVERAGE_VALUE*: GLenum = GLenum(0x80AA)
  GL_SAMPLE_COVERAGE_VALUE_ARB*: GLenum = GLenum(0x80AA)
  GL_SAMPLE_MASK_VALUE_EXT*: GLenum = GLenum(0x80AA)
  GL_SAMPLE_MASK_VALUE_SGIS*: GLenum = GLenum(0x80AA)
  GL_SAMPLE_COVERAGE_INVERT*: GLenum = GLenum(0x80AB)
  GL_SAMPLE_COVERAGE_INVERT_ARB*: GLenum = GLenum(0x80AB)
  GL_SAMPLE_MASK_INVERT_EXT*: GLenum = GLenum(0x80AB)
  GL_SAMPLE_MASK_INVERT_SGIS*: GLenum = GLenum(0x80AB)
  GL_SAMPLE_PATTERN_EXT*: GLenum = GLenum(0x80AC)
  GL_SAMPLE_PATTERN_SGIS*: GLenum = GLenum(0x80AC)
  GL_LINEAR_SHARPEN_SGIS*: GLenum = GLenum(0x80AD)
  GL_LINEAR_SHARPEN_ALPHA_SGIS*: GLenum = GLenum(0x80AE)
  GL_LINEAR_SHARPEN_COLOR_SGIS*: GLenum = GLenum(0x80AF)
  GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS*: GLenum = GLenum(0x80B0)
  GL_COLOR_MATRIX*: GLenum = GLenum(0x80B1)
  GL_COLOR_MATRIX_SGI*: GLenum = GLenum(0x80B1)
  GL_COLOR_MATRIX_STACK_DEPTH*: GLenum = GLenum(0x80B2)
  GL_COLOR_MATRIX_STACK_DEPTH_SGI*: GLenum = GLenum(0x80B2)
  GL_MAX_COLOR_MATRIX_STACK_DEPTH*: GLenum = GLenum(0x80B3)
  GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI*: GLenum = GLenum(0x80B3)
  GL_POST_COLOR_MATRIX_RED_SCALE*: GLenum = GLenum(0x80B4)
  GL_POST_COLOR_MATRIX_RED_SCALE_SGI*: GLenum = GLenum(0x80B4)
  GL_POST_COLOR_MATRIX_GREEN_SCALE*: GLenum = GLenum(0x80B5)
  GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI*: GLenum = GLenum(0x80B5)
  GL_POST_COLOR_MATRIX_BLUE_SCALE*: GLenum = GLenum(0x80B6)
  GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI*: GLenum = GLenum(0x80B6)
  GL_POST_COLOR_MATRIX_ALPHA_SCALE*: GLenum = GLenum(0x80B7)
  GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI*: GLenum = GLenum(0x80B7)
  GL_POST_COLOR_MATRIX_RED_BIAS*: GLenum = GLenum(0x80B8)
  GL_POST_COLOR_MATRIX_RED_BIAS_SGI*: GLenum = GLenum(0x80B8)
  GL_POST_COLOR_MATRIX_GREEN_BIAS*: GLenum = GLenum(0x80B9)
  GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI*: GLenum = GLenum(0x80B9)
  GL_POST_COLOR_MATRIX_BLUE_BIAS*: GLenum = GLenum(0x80BA)
  GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI*: GLenum = GLenum(0x80BA)
  GL_POST_COLOR_MATRIX_ALPHA_BIAS*: GLenum = GLenum(0x80BB)
  GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI*: GLenum = GLenum(0x80BB)
  GL_TEXTURE_COLOR_TABLE_SGI*: GLenum = GLenum(0x80BC)
  GL_PROXY_TEXTURE_COLOR_TABLE_SGI*: GLenum = GLenum(0x80BD)
  GL_TEXTURE_ENV_BIAS_SGIX*: GLenum = GLenum(0x80BE)
  GL_SHADOW_AMBIENT_SGIX*: GLenum = GLenum(0x80BF)
  GL_TEXTURE_COMPARE_FAIL_VALUE_ARB*: GLenum = GLenum(0x80BF)
  GL_BLEND_DST_RGB*: GLenum = GLenum(0x80C8)
  GL_BLEND_DST_RGB_EXT*: GLenum = GLenum(0x80C8)
  GL_BLEND_DST_RGB_OES*: GLenum = GLenum(0x80C8)
  GL_BLEND_SRC_RGB*: GLenum = GLenum(0x80C9)
  GL_BLEND_SRC_RGB_EXT*: GLenum = GLenum(0x80C9)
  GL_BLEND_SRC_RGB_OES*: GLenum = GLenum(0x80C9)
  GL_BLEND_DST_ALPHA*: GLenum = GLenum(0x80CA)
  GL_BLEND_DST_ALPHA_EXT*: GLenum = GLenum(0x80CA)
  GL_BLEND_DST_ALPHA_OES*: GLenum = GLenum(0x80CA)
  GL_BLEND_SRC_ALPHA*: GLenum = GLenum(0x80CB)
  GL_BLEND_SRC_ALPHA_EXT*: GLenum = GLenum(0x80CB)
  GL_BLEND_SRC_ALPHA_OES*: GLenum = GLenum(0x80CB)
  GL_422_EXT*: GLenum = GLenum(0x80CC)
  GL_422_REV_EXT*: GLenum = GLenum(0x80CD)
  GL_422_AVERAGE_EXT*: GLenum = GLenum(0x80CE)
  GL_422_REV_AVERAGE_EXT*: GLenum = GLenum(0x80CF)
  GL_COLOR_TABLE*: GLenum = GLenum(0x80D0)
  GL_COLOR_TABLE_SGI*: GLenum = GLenum(0x80D0)
  GL_POST_CONVOLUTION_COLOR_TABLE*: GLenum = GLenum(0x80D1)
  GL_POST_CONVOLUTION_COLOR_TABLE_SGI*: GLenum = GLenum(0x80D1)
  GL_POST_COLOR_MATRIX_COLOR_TABLE*: GLenum = GLenum(0x80D2)
  GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI*: GLenum = GLenum(0x80D2)
  GL_PROXY_COLOR_TABLE*: GLenum = GLenum(0x80D3)
  GL_PROXY_COLOR_TABLE_SGI*: GLenum = GLenum(0x80D3)
  GL_PROXY_POST_CONVOLUTION_COLOR_TABLE*: GLenum = GLenum(0x80D4)
  GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI*: GLenum = GLenum(0x80D4)
  GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE*: GLenum = GLenum(0x80D5)
  GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI*: GLenum = GLenum(0x80D5)
  GL_COLOR_TABLE_SCALE*: GLenum = GLenum(0x80D6)
  GL_COLOR_TABLE_SCALE_SGI*: GLenum = GLenum(0x80D6)
  GL_COLOR_TABLE_BIAS*: GLenum = GLenum(0x80D7)
  GL_COLOR_TABLE_BIAS_SGI*: GLenum = GLenum(0x80D7)
  GL_COLOR_TABLE_FORMAT*: GLenum = GLenum(0x80D8)
  GL_COLOR_TABLE_FORMAT_SGI*: GLenum = GLenum(0x80D8)
  GL_COLOR_TABLE_WIDTH*: GLenum = GLenum(0x80D9)
  GL_COLOR_TABLE_WIDTH_SGI*: GLenum = GLenum(0x80D9)
  GL_COLOR_TABLE_RED_SIZE*: GLenum = GLenum(0x80DA)
  GL_COLOR_TABLE_RED_SIZE_SGI*: GLenum = GLenum(0x80DA)
  GL_COLOR_TABLE_GREEN_SIZE*: GLenum = GLenum(0x80DB)
  GL_COLOR_TABLE_GREEN_SIZE_SGI*: GLenum = GLenum(0x80DB)
  GL_COLOR_TABLE_BLUE_SIZE*: GLenum = GLenum(0x80DC)
  GL_COLOR_TABLE_BLUE_SIZE_SGI*: GLenum = GLenum(0x80DC)
  GL_COLOR_TABLE_ALPHA_SIZE*: GLenum = GLenum(0x80DD)
  GL_COLOR_TABLE_ALPHA_SIZE_SGI*: GLenum = GLenum(0x80DD)
  GL_COLOR_TABLE_LUMINANCE_SIZE*: GLenum = GLenum(0x80DE)
  GL_COLOR_TABLE_LUMINANCE_SIZE_SGI*: GLenum = GLenum(0x80DE)
  GL_COLOR_TABLE_INTENSITY_SIZE*: GLenum = GLenum(0x80DF)
  GL_COLOR_TABLE_INTENSITY_SIZE_SGI*: GLenum = GLenum(0x80DF)
  GL_BGR*: GLenum = GLenum(0x80E0)
  GL_BGR_EXT*: GLenum = GLenum(0x80E0)
  GL_BGRA*: GLenum = GLenum(0x80E1)
  GL_BGRA_EXT*: GLenum = GLenum(0x80E1)
  GL_BGRA_IMG*: GLenum = GLenum(0x80E1)
  GL_COLOR_INDEX1_EXT*: GLenum = GLenum(0x80E2)
  GL_COLOR_INDEX2_EXT*: GLenum = GLenum(0x80E3)
  GL_COLOR_INDEX4_EXT*: GLenum = GLenum(0x80E4)
  GL_COLOR_INDEX8_EXT*: GLenum = GLenum(0x80E5)
  GL_COLOR_INDEX12_EXT*: GLenum = GLenum(0x80E6)
  GL_COLOR_INDEX16_EXT*: GLenum = GLenum(0x80E7)
  GL_MAX_ELEMENTS_VERTICES*: GLenum = GLenum(0x80E8)
  GL_MAX_ELEMENTS_VERTICES_EXT*: GLenum = GLenum(0x80E8)
  GL_MAX_ELEMENTS_INDICES*: GLenum = GLenum(0x80E9)
  GL_MAX_ELEMENTS_INDICES_EXT*: GLenum = GLenum(0x80E9)
  GL_PHONG_WIN*: GLenum = GLenum(0x80EA)
  GL_PHONG_HINT_WIN*: GLenum = GLenum(0x80EB)
  GL_FOG_SPECULAR_TEXTURE_WIN*: GLenum = GLenum(0x80EC)
  GL_TEXTURE_INDEX_SIZE_EXT*: GLenum = GLenum(0x80ED)
  GL_PARAMETER_BUFFER*: GLenum = GLenum(0x80EE)
  GL_PARAMETER_BUFFER_ARB*: GLenum = GLenum(0x80EE)
  GL_PARAMETER_BUFFER_BINDING*: GLenum = GLenum(0x80EF)
  GL_PARAMETER_BUFFER_BINDING_ARB*: GLenum = GLenum(0x80EF)
  GL_CLIP_VOLUME_CLIPPING_HINT_EXT*: GLenum = GLenum(0x80F0)
  GL_DUAL_ALPHA4_SGIS*: GLenum = GLenum(0x8110)
  GL_DUAL_ALPHA8_SGIS*: GLenum = GLenum(0x8111)
  GL_DUAL_ALPHA12_SGIS*: GLenum = GLenum(0x8112)
  GL_DUAL_ALPHA16_SGIS*: GLenum = GLenum(0x8113)
  GL_DUAL_LUMINANCE4_SGIS*: GLenum = GLenum(0x8114)
  GL_DUAL_LUMINANCE8_SGIS*: GLenum = GLenum(0x8115)
  GL_DUAL_LUMINANCE12_SGIS*: GLenum = GLenum(0x8116)
  GL_DUAL_LUMINANCE16_SGIS*: GLenum = GLenum(0x8117)
  GL_DUAL_INTENSITY4_SGIS*: GLenum = GLenum(0x8118)
  GL_DUAL_INTENSITY8_SGIS*: GLenum = GLenum(0x8119)
  GL_DUAL_INTENSITY12_SGIS*: GLenum = GLenum(0x811A)
  GL_DUAL_INTENSITY16_SGIS*: GLenum = GLenum(0x811B)
  GL_DUAL_LUMINANCE_ALPHA4_SGIS*: GLenum = GLenum(0x811C)
  GL_DUAL_LUMINANCE_ALPHA8_SGIS*: GLenum = GLenum(0x811D)
  GL_QUAD_ALPHA4_SGIS*: GLenum = GLenum(0x811E)
  GL_QUAD_ALPHA8_SGIS*: GLenum = GLenum(0x811F)
  GL_QUAD_LUMINANCE4_SGIS*: GLenum = GLenum(0x8120)
  GL_QUAD_LUMINANCE8_SGIS*: GLenum = GLenum(0x8121)
  GL_QUAD_INTENSITY4_SGIS*: GLenum = GLenum(0x8122)
  GL_QUAD_INTENSITY8_SGIS*: GLenum = GLenum(0x8123)
  GL_DUAL_TEXTURE_SELECT_SGIS*: GLenum = GLenum(0x8124)
  GL_QUAD_TEXTURE_SELECT_SGIS*: GLenum = GLenum(0x8125)
  GL_LOCATION_INDEX_EXT*: GLenum = GLenum(0x930F)
  GL_POINT_SIZE_MIN_ARB*: GLenum = GLenum(0x8126)
  GL_POINT_SIZE_MIN_EXT*: GLenum = GLenum(0x8126)
  GL_POINT_SIZE_MIN_SGIS*: GLenum = GLenum(0x8126)
  GL_LOCATION_INDEX*: GLenum = GLenum(0x930F)
  GL_POINT_SIZE_MAX_ARB*: GLenum = GLenum(0x8127)
  GL_POINT_SIZE_MAX_EXT*: GLenum = GLenum(0x8127)
  GL_POINT_SIZE_MAX_SGIS*: GLenum = GLenum(0x8127)
  GL_POINT_FADE_THRESHOLD_SIZE*: GLenum = GLenum(0x8128)
  GL_POINT_FADE_THRESHOLD_SIZE_ARB*: GLenum = GLenum(0x8128)
  GL_POINT_FADE_THRESHOLD_SIZE_EXT*: GLenum = GLenum(0x8128)
  GL_POINT_FADE_THRESHOLD_SIZE_SGIS*: GLenum = GLenum(0x8128)
  GL_DISTANCE_ATTENUATION_EXT*: GLenum = GLenum(0x8129)
  GL_DISTANCE_ATTENUATION_SGIS*: GLenum = GLenum(0x8129)
  GL_LOCATION*: GLenum = GLenum(0x930E)
  GL_POINT_DISTANCE_ATTENUATION_ARB*: GLenum = GLenum(0x8129)
  GL_FOG_FUNC_SGIS*: GLenum = GLenum(0x812A)
  GL_FOG_FUNC_POINTS_SGIS*: GLenum = GLenum(0x812B)
  GL_MAX_FOG_FUNC_POINTS_SGIS*: GLenum = GLenum(0x812C)
  GL_CLAMP_TO_BORDER*: GLenum = GLenum(0x812D)
  GL_CLAMP_TO_BORDER_ARB*: GLenum = GLenum(0x812D)
  GL_CLAMP_TO_BORDER_EXT*: GLenum = GLenum(0x812D)
  GL_CLAMP_TO_BORDER_NV*: GLenum = GLenum(0x812D)
  GL_CLAMP_TO_BORDER_SGIS*: GLenum = GLenum(0x812D)
  GL_CLAMP_TO_BORDER_OES*: GLenum = GLenum(0x812D)
  GL_TEXTURE_MULTI_BUFFER_HINT_SGIX*: GLenum = GLenum(0x812E)
  GL_CLAMP_TO_EDGE*: GLenum = GLenum(0x812F)
  GL_CLAMP_TO_EDGE_SGIS*: GLenum = GLenum(0x812F)
  GL_PACK_SKIP_VOLUMES_SGIS*: GLenum = GLenum(0x8130)
  GL_PACK_IMAGE_DEPTH_SGIS*: GLenum = GLenum(0x8131)
  GL_UNPACK_SKIP_VOLUMES_SGIS*: GLenum = GLenum(0x8132)
  GL_UNPACK_IMAGE_DEPTH_SGIS*: GLenum = GLenum(0x8133)
  GL_TEXTURE_4D_SGIS*: GLenum = GLenum(0x8134)
  GL_PROXY_TEXTURE_4D_SGIS*: GLenum = GLenum(0x8135)
  GL_TEXTURE_4DSIZE_SGIS*: GLenum = GLenum(0x8136)
  GL_TEXTURE_WRAP_Q_SGIS*: GLenum = GLenum(0x8137)
  GL_MAX_4D_TEXTURE_SIZE_SGIS*: GLenum = GLenum(0x8138)
  GL_PIXEL_TEX_GEN_SGIX*: GLenum = GLenum(0x8139)
  GL_TEXTURE_MIN_LOD*: GLenum = GLenum(0x813A)
  GL_TEXTURE_MIN_LOD_SGIS*: GLenum = GLenum(0x813A)
  GL_TEXTURE_MAX_LOD*: GLenum = GLenum(0x813B)
  GL_TEXTURE_MAX_LOD_SGIS*: GLenum = GLenum(0x813B)
  GL_TEXTURE_BASE_LEVEL*: GLenum = GLenum(0x813C)
  GL_TEXTURE_BASE_LEVEL_SGIS*: GLenum = GLenum(0x813C)
  GL_TEXTURE_MAX_LEVEL*: GLenum = GLenum(0x813D)
  GL_TEXTURE_MAX_LEVEL_APPLE*: GLenum = GLenum(0x813D)
  GL_TEXTURE_MAX_LEVEL_SGIS*: GLenum = GLenum(0x813D)
  GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX*: GLenum = GLenum(0x813E)
  GL_PIXEL_TILE_CACHE_INCREMENT_SGIX*: GLenum = GLenum(0x813F)
  GL_PIXEL_TILE_WIDTH_SGIX*: GLenum = GLenum(0x8140)
  GL_PIXEL_TILE_HEIGHT_SGIX*: GLenum = GLenum(0x8141)
  GL_PIXEL_TILE_GRID_WIDTH_SGIX*: GLenum = GLenum(0x8142)
  GL_PIXEL_TILE_GRID_HEIGHT_SGIX*: GLenum = GLenum(0x8143)
  GL_PIXEL_TILE_GRID_DEPTH_SGIX*: GLenum = GLenum(0x8144)
  GL_PIXEL_TILE_CACHE_SIZE_SGIX*: GLenum = GLenum(0x8145)
  GL_FILTER4_SGIS*: GLenum = GLenum(0x8146)
  GL_TEXTURE_FILTER4_SIZE_SGIS*: GLenum = GLenum(0x8147)
  GL_SPRITE_SGIX*: GLenum = GLenum(0x8148)
  GL_SPRITE_MODE_SGIX*: GLenum = GLenum(0x8149)
  GL_SPRITE_AXIS_SGIX*: GLenum = GLenum(0x814A)
  GL_SPRITE_TRANSLATION_SGIX*: GLenum = GLenum(0x814B)
  GL_SPRITE_AXIAL_SGIX*: GLenum = GLenum(0x814C)
  GL_SPRITE_OBJECT_ALIGNED_SGIX*: GLenum = GLenum(0x814D)
  GL_SPRITE_EYE_ALIGNED_SGIX*: GLenum = GLenum(0x814E)
  GL_TEXTURE_4D_BINDING_SGIS*: GLenum = GLenum(0x814F)
  GL_IGNORE_BORDER_HP*: GLenum = GLenum(0x8150)
  GL_CONSTANT_BORDER*: GLenum = GLenum(0x8151)
  GL_CONSTANT_BORDER_HP*: GLenum = GLenum(0x8151)
  GL_REPLICATE_BORDER*: GLenum = GLenum(0x8153)
  GL_REPLICATE_BORDER_HP*: GLenum = GLenum(0x8153)
  GL_CONVOLUTION_BORDER_COLOR*: GLenum = GLenum(0x8154)
  GL_CONVOLUTION_BORDER_COLOR_HP*: GLenum = GLenum(0x8154)
  GL_IMAGE_SCALE_X_HP*: GLenum = GLenum(0x8155)
  GL_IMAGE_SCALE_Y_HP*: GLenum = GLenum(0x8156)
  GL_IMAGE_TRANSLATE_X_HP*: GLenum = GLenum(0x8157)
  GL_IMAGE_TRANSLATE_Y_HP*: GLenum = GLenum(0x8158)
  GL_IMAGE_ROTATE_ANGLE_HP*: GLenum = GLenum(0x8159)
  GL_IMAGE_ROTATE_ORIGIN_X_HP*: GLenum = GLenum(0x815A)
  GL_IMAGE_ROTATE_ORIGIN_Y_HP*: GLenum = GLenum(0x815B)
  GL_IMAGE_MAG_FILTER_HP*: GLenum = GLenum(0x815C)
  GL_IMAGE_MIN_FILTER_HP*: GLenum = GLenum(0x815D)
  GL_IMAGE_CUBIC_WEIGHT_HP*: GLenum = GLenum(0x815E)
  GL_CUBIC_HP*: GLenum = GLenum(0x815F)
  GL_AVERAGE_HP*: GLenum = GLenum(0x8160)
  GL_IMAGE_TRANSFORM_2D_HP*: GLenum = GLenum(0x8161)
  GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP*: GLenum = GLenum(0x8162)
  GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP*: GLenum = GLenum(0x8163)
  GL_OCCLUSION_TEST_HP*: GLenum = GLenum(0x8165)
  GL_OCCLUSION_TEST_RESULT_HP*: GLenum = GLenum(0x8166)
  GL_TEXTURE_LIGHTING_MODE_HP*: GLenum = GLenum(0x8167)
  GL_TEXTURE_POST_SPECULAR_HP*: GLenum = GLenum(0x8168)
  GL_TEXTURE_PRE_SPECULAR_HP*: GLenum = GLenum(0x8169)
  GL_LINEAR_CLIPMAP_LINEAR_SGIX*: GLenum = GLenum(0x8170)
  GL_TEXTURE_CLIPMAP_CENTER_SGIX*: GLenum = GLenum(0x8171)
  GL_TEXTURE_CLIPMAP_FRAME_SGIX*: GLenum = GLenum(0x8172)
  GL_TEXTURE_CLIPMAP_OFFSET_SGIX*: GLenum = GLenum(0x8173)
  GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX*: GLenum = GLenum(0x8174)
  GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX*: GLenum = GLenum(0x8175)
  GL_TEXTURE_CLIPMAP_DEPTH_SGIX*: GLenum = GLenum(0x8176)
  GL_MAX_CLIPMAP_DEPTH_SGIX*: GLenum = GLenum(0x8177)
  GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX*: GLenum = GLenum(0x8178)
  GL_POST_TEXTURE_FILTER_BIAS_SGIX*: GLenum = GLenum(0x8179)
  GL_POST_TEXTURE_FILTER_SCALE_SGIX*: GLenum = GLenum(0x817A)
  GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX*: GLenum = GLenum(0x817B)
  GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX*: GLenum = GLenum(0x817C)
  GL_REFERENCE_PLANE_SGIX*: GLenum = GLenum(0x817D)
  GL_REFERENCE_PLANE_EQUATION_SGIX*: GLenum = GLenum(0x817E)
  GL_IR_INSTRUMENT1_SGIX*: GLenum = GLenum(0x817F)
  GL_INSTRUMENT_BUFFER_POINTER_SGIX*: GLenum = GLenum(0x8180)
  GL_INSTRUMENT_MEASUREMENTS_SGIX*: GLenum = GLenum(0x8181)
  GL_LIST_PRIORITY_SGIX*: GLenum = GLenum(0x8182)
  GL_CALLIGRAPHIC_FRAGMENT_SGIX*: GLenum = GLenum(0x8183)
  GL_PIXEL_TEX_GEN_Q_CEILING_SGIX*: GLenum = GLenum(0x8184)
  GL_PIXEL_TEX_GEN_Q_ROUND_SGIX*: GLenum = GLenum(0x8185)
  GL_PIXEL_TEX_GEN_Q_FLOOR_SGIX*: GLenum = GLenum(0x8186)
  GL_PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX*: GLenum = GLenum(0x8187)
  GL_PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX*: GLenum = GLenum(0x8188)
  GL_PIXEL_TEX_GEN_ALPHA_LS_SGIX*: GLenum = GLenum(0x8189)
  GL_PIXEL_TEX_GEN_ALPHA_MS_SGIX*: GLenum = GLenum(0x818A)
  GL_FRAMEZOOM_SGIX*: GLenum = GLenum(0x818B)
  GL_FRAMEZOOM_FACTOR_SGIX*: GLenum = GLenum(0x818C)
  GL_MAX_FRAMEZOOM_FACTOR_SGIX*: GLenum = GLenum(0x818D)
  GL_TEXTURE_LOD_BIAS_S_SGIX*: GLenum = GLenum(0x818E)
  GL_TEXTURE_LOD_BIAS_T_SGIX*: GLenum = GLenum(0x818F)
  GL_TEXTURE_LOD_BIAS_R_SGIX*: GLenum = GLenum(0x8190)
  GL_TOP_LEVEL_ARRAY_STRIDE*: GLenum = GLenum(0x930D)
  GL_GENERATE_MIPMAP_SGIS*: GLenum = GLenum(0x8191)
  GL_TOP_LEVEL_ARRAY_SIZE*: GLenum = GLenum(0x930C)
  GL_GENERATE_MIPMAP_HINT_SGIS*: GLenum = GLenum(0x8192)
  GL_GEOMETRY_DEFORMATION_SGIX*: GLenum = GLenum(0x8194)
  GL_TEXTURE_DEFORMATION_SGIX*: GLenum = GLenum(0x8195)
  GL_DEFORMATIONS_MASK_SGIX*: GLenum = GLenum(0x8196)
  GL_MAX_DEFORMATION_ORDER_SGIX*: GLenum = GLenum(0x8197)
  GL_FOG_OFFSET_SGIX*: GLenum = GLenum(0x8198)
  GL_FOG_OFFSET_VALUE_SGIX*: GLenum = GLenum(0x8199)
  GL_TEXTURE_COMPARE_SGIX*: GLenum = GLenum(0x819A)
  GL_TEXTURE_COMPARE_OPERATOR_SGIX*: GLenum = GLenum(0x819B)
  GL_TEXTURE_LEQUAL_R_SGIX*: GLenum = GLenum(0x819C)
  GL_TEXTURE_GEQUAL_R_SGIX*: GLenum = GLenum(0x819D)
  GL_DEPTH_COMPONENT16*: GLenum = GLenum(0x81A5)
  GL_DEPTH_COMPONENT16_ARB*: GLenum = GLenum(0x81A5)
  GL_DEPTH_COMPONENT16_OES*: GLenum = GLenum(0x81A5)
  GL_DEPTH_COMPONENT16_SGIX*: GLenum = GLenum(0x81A5)
  GL_DEPTH_COMPONENT24*: GLenum = GLenum(0x81A6)
  GL_DEPTH_COMPONENT24_ARB*: GLenum = GLenum(0x81A6)
  GL_DEPTH_COMPONENT24_OES*: GLenum = GLenum(0x81A6)
  GL_DEPTH_COMPONENT24_SGIX*: GLenum = GLenum(0x81A6)
  GL_DEPTH_COMPONENT32*: GLenum = GLenum(0x81A7)
  GL_DEPTH_COMPONENT32_ARB*: GLenum = GLenum(0x81A7)
  GL_DEPTH_COMPONENT32_OES*: GLenum = GLenum(0x81A7)
  GL_DEPTH_COMPONENT32_SGIX*: GLenum = GLenum(0x81A7)
  GL_ARRAY_ELEMENT_LOCK_FIRST_EXT*: GLenum = GLenum(0x81A8)
  GL_ARRAY_ELEMENT_LOCK_COUNT_EXT*: GLenum = GLenum(0x81A9)
  GL_CULL_VERTEX_EXT*: GLenum = GLenum(0x81AA)
  GL_CULL_VERTEX_EYE_POSITION_EXT*: GLenum = GLenum(0x81AB)
  GL_CULL_VERTEX_OBJECT_POSITION_EXT*: GLenum = GLenum(0x81AC)
  GL_IUI_V2F_EXT*: GLenum = GLenum(0x81AD)
  GL_IUI_V3F_EXT*: GLenum = GLenum(0x81AE)
  GL_IUI_N3F_V2F_EXT*: GLenum = GLenum(0x81AF)
  GL_IUI_N3F_V3F_EXT*: GLenum = GLenum(0x81B0)
  GL_T2F_IUI_V2F_EXT*: GLenum = GLenum(0x81B1)
  GL_T2F_IUI_V3F_EXT*: GLenum = GLenum(0x81B2)
  GL_T2F_IUI_N3F_V2F_EXT*: GLenum = GLenum(0x81B3)
  GL_T2F_IUI_N3F_V3F_EXT*: GLenum = GLenum(0x81B4)
  GL_INDEX_TEST_EXT*: GLenum = GLenum(0x81B5)
  GL_INDEX_TEST_FUNC_EXT*: GLenum = GLenum(0x81B6)
  GL_INDEX_TEST_REF_EXT*: GLenum = GLenum(0x81B7)
  GL_INDEX_MATERIAL_EXT*: GLenum = GLenum(0x81B8)
  GL_INDEX_MATERIAL_PARAMETER_EXT*: GLenum = GLenum(0x81B9)
  GL_INDEX_MATERIAL_FACE_EXT*: GLenum = GLenum(0x81BA)
  GL_YCRCB_422_SGIX*: GLenum = GLenum(0x81BB)
  GL_YCRCB_444_SGIX*: GLenum = GLenum(0x81BC)
  GL_WRAP_BORDER_SUN*: GLenum = GLenum(0x81D4)
  GL_UNPACK_CONSTANT_DATA_SUNX*: GLenum = GLenum(0x81D5)
  GL_TEXTURE_CONSTANT_DATA_SUNX*: GLenum = GLenum(0x81D6)
  GL_TRIANGLE_LIST_SUN*: GLenum = GLenum(0x81D7)
  GL_REPLACEMENT_CODE_SUN*: GLenum = GLenum(0x81D8)
  GL_GLOBAL_ALPHA_SUN*: GLenum = GLenum(0x81D9)
  GL_GLOBAL_ALPHA_FACTOR_SUN*: GLenum = GLenum(0x81DA)
  GL_TEXTURE_COLOR_WRITEMASK_SGIS*: GLenum = GLenum(0x81EF)
  GL_EYE_DISTANCE_TO_POINT_SGIS*: GLenum = GLenum(0x81F0)
  GL_OBJECT_DISTANCE_TO_POINT_SGIS*: GLenum = GLenum(0x81F1)
  GL_EYE_DISTANCE_TO_LINE_SGIS*: GLenum = GLenum(0x81F2)
  GL_OBJECT_DISTANCE_TO_LINE_SGIS*: GLenum = GLenum(0x81F3)
  GL_EYE_POINT_SGIS*: GLenum = GLenum(0x81F4)
  GL_OBJECT_POINT_SGIS*: GLenum = GLenum(0x81F5)
  GL_EYE_LINE_SGIS*: GLenum = GLenum(0x81F6)
  GL_OBJECT_LINE_SGIS*: GLenum = GLenum(0x81F7)
  GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_ARB*: GLenum = GLenum(0x9342)
  GL_LIGHT_MODEL_COLOR_CONTROL_EXT*: GLenum = GLenum(0x81F8)
  GL_PROGRAMMABLE_SAMPLE_LOCATION_NV*: GLenum = GLenum(0x9341)
  GL_SINGLE_COLOR_EXT*: GLenum = GLenum(0x81F9)
  GL_PROGRAMMABLE_SAMPLE_LOCATION_ARB*: GLenum = GLenum(0x9341)
  GL_SEPARATE_SPECULAR_COLOR_EXT*: GLenum = GLenum(0x81FA)
  GL_SHARED_TEXTURE_PALETTE_EXT*: GLenum = GLenum(0x81FB)
  GL_TEXT_FRAGMENT_SHADER_ATI*: GLenum = GLenum(0x8200)
  GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING*: GLenum = GLenum(0x8210)
  GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT*: GLenum = GLenum(0x8210)
  GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE*: GLenum = GLenum(0x8211)
  GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT*: GLenum = GLenum(0x8211)
  GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE*: GLenum = GLenum(0x8212)
  GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE*: GLenum = GLenum(0x8213)
  GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE*: GLenum = GLenum(0x8214)
  GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE*: GLenum = GLenum(0x8215)
  GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE*: GLenum = GLenum(0x8216)
  GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE*: GLenum = GLenum(0x8217)
  GL_FRAMEBUFFER_DEFAULT*: GLenum = GLenum(0x8218)
  GL_FRAMEBUFFER_UNDEFINED*: GLenum = GLenum(0x8219)
  GL_FRAMEBUFFER_UNDEFINED_OES*: GLenum = GLenum(0x8219)
  GL_DEPTH_STENCIL_ATTACHMENT*: GLenum = GLenum(0x821A)
  GL_MAJOR_VERSION*: GLenum = GLenum(0x821B)
  GL_MINOR_VERSION*: GLenum = GLenum(0x821C)
  GL_NUM_EXTENSIONS*: GLenum = GLenum(0x821D)
  GL_CONTEXT_FLAGS*: GLenum = GLenum(0x821E)
  GL_BUFFER_IMMUTABLE_STORAGE*: GLenum = GLenum(0x821F)
  GL_BUFFER_IMMUTABLE_STORAGE_EXT*: GLenum = GLenum(0x821F)
  GL_BUFFER_STORAGE_FLAGS*: GLenum = GLenum(0x8220)
  GL_BUFFER_STORAGE_FLAGS_EXT*: GLenum = GLenum(0x8220)
  GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED*: GLenum = GLenum(0x8221)
  GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED_OES*: GLenum = GLenum(0x8221)
  GL_FRAGMENT_COVERAGE_COLOR_NV*: GLenum = GLenum(0x92DE)
  GL_COMPRESSED_RED*: GLenum = GLenum(0x8225)
  GL_COMPRESSED_RG*: GLenum = GLenum(0x8226)
  GL_RG*: GLenum = GLenum(0x8227)
  GL_RG_EXT*: GLenum = GLenum(0x8227)
  GL_RG_INTEGER*: GLenum = GLenum(0x8228)
  GL_R8*: GLenum = GLenum(0x8229)
  GL_R8_EXT*: GLenum = GLenum(0x8229)
  GL_R16*: GLenum = GLenum(0x822A)
  GL_R16_EXT*: GLenum = GLenum(0x822A)
  GL_RG8*: GLenum = GLenum(0x822B)
  GL_RG8_EXT*: GLenum = GLenum(0x822B)
  GL_RG16*: GLenum = GLenum(0x822C)
  GL_RG16_EXT*: GLenum = GLenum(0x822C)
  GL_R16F*: GLenum = GLenum(0x822D)
  GL_R16F_EXT*: GLenum = GLenum(0x822D)
  GL_R32F*: GLenum = GLenum(0x822E)
  GL_R32F_EXT*: GLenum = GLenum(0x822E)
  GL_RG16F*: GLenum = GLenum(0x822F)
  GL_RG16F_EXT*: GLenum = GLenum(0x822F)
  GL_RG32F*: GLenum = GLenum(0x8230)
  GL_RG32F_EXT*: GLenum = GLenum(0x8230)
  GL_R8I*: GLenum = GLenum(0x8231)
  GL_R8UI*: GLenum = GLenum(0x8232)
  GL_R16I*: GLenum = GLenum(0x8233)
  GL_R16UI*: GLenum = GLenum(0x8234)
  GL_R32I*: GLenum = GLenum(0x8235)
  GL_R32UI*: GLenum = GLenum(0x8236)
  GL_RG8I*: GLenum = GLenum(0x8237)
  GL_RG8UI*: GLenum = GLenum(0x8238)
  GL_RG16I*: GLenum = GLenum(0x8239)
  GL_RG16UI*: GLenum = GLenum(0x823A)
  GL_RG32I*: GLenum = GLenum(0x823B)
  GL_RG32UI*: GLenum = GLenum(0x823C)
  GL_SYNC_CL_EVENT_ARB*: GLenum = GLenum(0x8240)
  GL_SYNC_CL_EVENT_COMPLETE_ARB*: GLenum = GLenum(0x8241)
  GL_DEBUG_OUTPUT_SYNCHRONOUS*: GLenum = GLenum(0x8242)
  GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB*: GLenum = GLenum(0x8242)
  GL_DEBUG_OUTPUT_SYNCHRONOUS_KHR*: GLenum = GLenum(0x8242)
  GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH*: GLenum = GLenum(0x8243)
  GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB*: GLenum = GLenum(0x8243)
  GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR*: GLenum = GLenum(0x8243)
  GL_DEBUG_CALLBACK_FUNCTION*: GLenum = GLenum(0x8244)
  GL_DEBUG_CALLBACK_FUNCTION_ARB*: GLenum = GLenum(0x8244)
  GL_DEBUG_CALLBACK_FUNCTION_KHR*: GLenum = GLenum(0x8244)
  GL_DEBUG_CALLBACK_USER_PARAM*: GLenum = GLenum(0x8245)
  GL_DEBUG_CALLBACK_USER_PARAM_ARB*: GLenum = GLenum(0x8245)
  GL_DEBUG_CALLBACK_USER_PARAM_KHR*: GLenum = GLenum(0x8245)
  GL_DEBUG_SOURCE_API*: GLenum = GLenum(0x8246)
  GL_DEBUG_SOURCE_API_ARB*: GLenum = GLenum(0x8246)
  GL_DEBUG_SOURCE_API_KHR*: GLenum = GLenum(0x8246)
  GL_DEBUG_SOURCE_WINDOW_SYSTEM*: GLenum = GLenum(0x8247)
  GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB*: GLenum = GLenum(0x8247)
  GL_DEBUG_SOURCE_WINDOW_SYSTEM_KHR*: GLenum = GLenum(0x8247)
  GL_DEBUG_SOURCE_SHADER_COMPILER*: GLenum = GLenum(0x8248)
  GL_DEBUG_SOURCE_SHADER_COMPILER_ARB*: GLenum = GLenum(0x8248)
  GL_DEBUG_SOURCE_SHADER_COMPILER_KHR*: GLenum = GLenum(0x8248)
  GL_DEBUG_SOURCE_THIRD_PARTY*: GLenum = GLenum(0x8249)
  GL_DEBUG_SOURCE_THIRD_PARTY_ARB*: GLenum = GLenum(0x8249)
  GL_DEBUG_SOURCE_THIRD_PARTY_KHR*: GLenum = GLenum(0x8249)
  GL_DEBUG_SOURCE_APPLICATION*: GLenum = GLenum(0x824A)
  GL_DEBUG_SOURCE_APPLICATION_ARB*: GLenum = GLenum(0x824A)
  GL_DEBUG_SOURCE_APPLICATION_KHR*: GLenum = GLenum(0x824A)
  GL_DEBUG_SOURCE_OTHER*: GLenum = GLenum(0x824B)
  GL_DEBUG_SOURCE_OTHER_ARB*: GLenum = GLenum(0x824B)
  GL_DEBUG_SOURCE_OTHER_KHR*: GLenum = GLenum(0x824B)
  GL_DEBUG_TYPE_ERROR*: GLenum = GLenum(0x824C)
  GL_DEBUG_TYPE_ERROR_ARB*: GLenum = GLenum(0x824C)
  GL_DEBUG_TYPE_ERROR_KHR*: GLenum = GLenum(0x824C)
  GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR*: GLenum = GLenum(0x824D)
  GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB*: GLenum = GLenum(0x824D)
  GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR*: GLenum = GLenum(0x824D)
  GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR*: GLenum = GLenum(0x824E)
  GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB*: GLenum = GLenum(0x824E)
  GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR*: GLenum = GLenum(0x824E)
  GL_DEBUG_TYPE_PORTABILITY*: GLenum = GLenum(0x824F)
  GL_DEBUG_TYPE_PORTABILITY_ARB*: GLenum = GLenum(0x824F)
  GL_DEBUG_TYPE_PORTABILITY_KHR*: GLenum = GLenum(0x824F)
  GL_DEBUG_TYPE_PERFORMANCE*: GLenum = GLenum(0x8250)
  GL_DEBUG_TYPE_PERFORMANCE_ARB*: GLenum = GLenum(0x8250)
  GL_DEBUG_TYPE_PERFORMANCE_KHR*: GLenum = GLenum(0x8250)
  GL_DEBUG_TYPE_OTHER*: GLenum = GLenum(0x8251)
  GL_DEBUG_TYPE_OTHER_ARB*: GLenum = GLenum(0x8251)
  GL_DEBUG_TYPE_OTHER_KHR*: GLenum = GLenum(0x8251)
  GL_LOSE_CONTEXT_ON_RESET*: GLenum = GLenum(0x8252)
  GL_LOSE_CONTEXT_ON_RESET_ARB*: GLenum = GLenum(0x8252)
  GL_LOSE_CONTEXT_ON_RESET_EXT*: GLenum = GLenum(0x8252)
  GL_LOSE_CONTEXT_ON_RESET_KHR*: GLenum = GLenum(0x8252)
  GL_GUILTY_CONTEXT_RESET*: GLenum = GLenum(0x8253)
  GL_GUILTY_CONTEXT_RESET_ARB*: GLenum = GLenum(0x8253)
  GL_GUILTY_CONTEXT_RESET_EXT*: GLenum = GLenum(0x8253)
  GL_GUILTY_CONTEXT_RESET_KHR*: GLenum = GLenum(0x8253)
  GL_INNOCENT_CONTEXT_RESET*: GLenum = GLenum(0x8254)
  GL_INNOCENT_CONTEXT_RESET_ARB*: GLenum = GLenum(0x8254)
  GL_INNOCENT_CONTEXT_RESET_EXT*: GLenum = GLenum(0x8254)
  GL_INNOCENT_CONTEXT_RESET_KHR*: GLenum = GLenum(0x8254)
  GL_UNKNOWN_CONTEXT_RESET*: GLenum = GLenum(0x8255)
  GL_UNKNOWN_CONTEXT_RESET_ARB*: GLenum = GLenum(0x8255)
  GL_UNKNOWN_CONTEXT_RESET_EXT*: GLenum = GLenum(0x8255)
  GL_UNKNOWN_CONTEXT_RESET_KHR*: GLenum = GLenum(0x8255)
  GL_RESET_NOTIFICATION_STRATEGY*: GLenum = GLenum(0x8256)
  GL_RESET_NOTIFICATION_STRATEGY_ARB*: GLenum = GLenum(0x8256)
  GL_RESET_NOTIFICATION_STRATEGY_EXT*: GLenum = GLenum(0x8256)
  GL_RESET_NOTIFICATION_STRATEGY_KHR*: GLenum = GLenum(0x8256)
  GL_PROGRAM_BINARY_RETRIEVABLE_HINT*: GLenum = GLenum(0x8257)
  GL_PROGRAM_SEPARABLE*: GLenum = GLenum(0x8258)
  GL_PROGRAM_SEPARABLE_EXT*: GLenum = GLenum(0x8258)
  GL_ACTIVE_PROGRAM*: GLenum = GLenum(0x8259)
  GL_PROGRAM_PIPELINE_BINDING*: GLenum = GLenum(0x825A)
  GL_PROGRAM_PIPELINE_BINDING_EXT*: GLenum = GLenum(0x825A)
  GL_MAX_VIEWPORTS*: GLenum = GLenum(0x825B)
  GL_MAX_VIEWPORTS_NV*: GLenum = GLenum(0x825B)
  GL_MAX_VIEWPORTS_OES*: GLenum = GLenum(0x825B)
  GL_VIEWPORT_SUBPIXEL_BITS*: GLenum = GLenum(0x825C)
  GL_VIEWPORT_SUBPIXEL_BITS_EXT*: GLenum = GLenum(0x825C)
  GL_VIEWPORT_SUBPIXEL_BITS_NV*: GLenum = GLenum(0x825C)
  GL_VIEWPORT_SUBPIXEL_BITS_OES*: GLenum = GLenum(0x825C)
  GL_VIEWPORT_BOUNDS_RANGE*: GLenum = GLenum(0x825D)
  GL_VIEWPORT_BOUNDS_RANGE_EXT*: GLenum = GLenum(0x825D)
  GL_VIEWPORT_BOUNDS_RANGE_NV*: GLenum = GLenum(0x825D)
  GL_VIEWPORT_BOUNDS_RANGE_OES*: GLenum = GLenum(0x825D)
  GL_LAYER_PROVOKING_VERTEX*: GLenum = GLenum(0x825E)
  GL_LAYER_PROVOKING_VERTEX_EXT*: GLenum = GLenum(0x825E)
  GL_LAYER_PROVOKING_VERTEX_OES*: GLenum = GLenum(0x825E)
  GL_VIEWPORT_INDEX_PROVOKING_VERTEX*: GLenum = GLenum(0x825F)
  GL_VIEWPORT_INDEX_PROVOKING_VERTEX_EXT*: GLenum = GLenum(0x825F)
  GL_VIEWPORT_INDEX_PROVOKING_VERTEX_NV*: GLenum = GLenum(0x825F)
  GL_VIEWPORT_INDEX_PROVOKING_VERTEX_OES*: GLenum = GLenum(0x825F)
  GL_UNDEFINED_VERTEX*: GLenum = GLenum(0x8260)
  GL_UNDEFINED_VERTEX_EXT*: GLenum = GLenum(0x8260)
  GL_UNDEFINED_VERTEX_OES*: GLenum = GLenum(0x8260)
  GL_NO_RESET_NOTIFICATION*: GLenum = GLenum(0x8261)
  GL_NO_RESET_NOTIFICATION_ARB*: GLenum = GLenum(0x8261)
  GL_NO_RESET_NOTIFICATION_EXT*: GLenum = GLenum(0x8261)
  GL_NO_RESET_NOTIFICATION_KHR*: GLenum = GLenum(0x8261)
  GL_MAX_COMPUTE_SHARED_MEMORY_SIZE*: GLenum = GLenum(0x8262)
  GL_MAX_COMPUTE_UNIFORM_COMPONENTS*: GLenum = GLenum(0x8263)
  GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS*: GLenum = GLenum(0x8264)
  GL_MAX_COMPUTE_ATOMIC_COUNTERS*: GLenum = GLenum(0x8265)
  GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS*: GLenum = GLenum(0x8266)
  GL_COMPUTE_WORK_GROUP_SIZE*: GLenum = GLenum(0x8267)
  GL_DEBUG_TYPE_MARKER*: GLenum = GLenum(0x8268)
  GL_DEBUG_TYPE_MARKER_KHR*: GLenum = GLenum(0x8268)
  GL_DEBUG_TYPE_PUSH_GROUP*: GLenum = GLenum(0x8269)
  GL_DEBUG_TYPE_PUSH_GROUP_KHR*: GLenum = GLenum(0x8269)
  GL_DEBUG_TYPE_POP_GROUP*: GLenum = GLenum(0x826A)
  GL_DEBUG_TYPE_POP_GROUP_KHR*: GLenum = GLenum(0x826A)
  GL_DEBUG_SEVERITY_NOTIFICATION*: GLenum = GLenum(0x826B)
  GL_DEBUG_SEVERITY_NOTIFICATION_KHR*: GLenum = GLenum(0x826B)
  GL_MAX_DEBUG_GROUP_STACK_DEPTH*: GLenum = GLenum(0x826C)
  GL_MAX_DEBUG_GROUP_STACK_DEPTH_KHR*: GLenum = GLenum(0x826C)
  GL_DEBUG_GROUP_STACK_DEPTH*: GLenum = GLenum(0x826D)
  GL_DEBUG_GROUP_STACK_DEPTH_KHR*: GLenum = GLenum(0x826D)
  GL_MAX_UNIFORM_LOCATIONS*: GLenum = GLenum(0x826E)
  GL_INTERNALFORMAT_SUPPORTED*: GLenum = GLenum(0x826F)
  GL_INTERNALFORMAT_PREFERRED*: GLenum = GLenum(0x8270)
  GL_INTERNALFORMAT_RED_SIZE*: GLenum = GLenum(0x8271)
  GL_INTERNALFORMAT_GREEN_SIZE*: GLenum = GLenum(0x8272)
  GL_INTERNALFORMAT_BLUE_SIZE*: GLenum = GLenum(0x8273)
  GL_INTERNALFORMAT_ALPHA_SIZE*: GLenum = GLenum(0x8274)
  GL_INTERNALFORMAT_DEPTH_SIZE*: GLenum = GLenum(0x8275)
  GL_INTERNALFORMAT_STENCIL_SIZE*: GLenum = GLenum(0x8276)
  GL_INTERNALFORMAT_SHARED_SIZE*: GLenum = GLenum(0x8277)
  GL_INTERNALFORMAT_RED_TYPE*: GLenum = GLenum(0x8278)
  GL_INTERNALFORMAT_GREEN_TYPE*: GLenum = GLenum(0x8279)
  GL_INTERNALFORMAT_BLUE_TYPE*: GLenum = GLenum(0x827A)
  GL_INTERNALFORMAT_ALPHA_TYPE*: GLenum = GLenum(0x827B)
  GL_INTERNALFORMAT_DEPTH_TYPE*: GLenum = GLenum(0x827C)
  GL_INTERNALFORMAT_STENCIL_TYPE*: GLenum = GLenum(0x827D)
  GL_MAX_WIDTH*: GLenum = GLenum(0x827E)
  GL_MAX_HEIGHT*: GLenum = GLenum(0x827F)
  GL_MAX_DEPTH*: GLenum = GLenum(0x8280)
  GL_MAX_LAYERS*: GLenum = GLenum(0x8281)
  GL_MAX_COMBINED_DIMENSIONS*: GLenum = GLenum(0x8282)
  GL_COLOR_COMPONENTS*: GLenum = GLenum(0x8283)
  GL_DEPTH_COMPONENTS*: GLenum = GLenum(0x8284)
  GL_STENCIL_COMPONENTS*: GLenum = GLenum(0x8285)
  GL_COLOR_RENDERABLE*: GLenum = GLenum(0x8286)
  GL_DEPTH_RENDERABLE*: GLenum = GLenum(0x8287)
  GL_STENCIL_RENDERABLE*: GLenum = GLenum(0x8288)
  GL_FRAMEBUFFER_RENDERABLE*: GLenum = GLenum(0x8289)
  GL_FRAMEBUFFER_RENDERABLE_LAYERED*: GLenum = GLenum(0x828A)
  GL_FRAMEBUFFER_BLEND*: GLenum = GLenum(0x828B)
  GL_READ_PIXELS*: GLenum = GLenum(0x828C)
  GL_READ_PIXELS_FORMAT*: GLenum = GLenum(0x828D)
  GL_READ_PIXELS_TYPE*: GLenum = GLenum(0x828E)
  GL_TEXTURE_IMAGE_FORMAT*: GLenum = GLenum(0x828F)
  GL_TEXTURE_IMAGE_TYPE*: GLenum = GLenum(0x8290)
  GL_GET_TEXTURE_IMAGE_FORMAT*: GLenum = GLenum(0x8291)
  GL_GET_TEXTURE_IMAGE_TYPE*: GLenum = GLenum(0x8292)
  GL_MIPMAP*: GLenum = GLenum(0x8293)
  GL_MANUAL_GENERATE_MIPMAP*: GLenum = GLenum(0x8294)
  GL_AUTO_GENERATE_MIPMAP*: GLenum = GLenum(0x8295) ## Should be deprecated
  GL_COLOR_ENCODING*: GLenum = GLenum(0x8296)
  GL_SRGB_READ*: GLenum = GLenum(0x8297)
  GL_SRGB_WRITE*: GLenum = GLenum(0x8298)
  GL_SRGB_DECODE_ARB*: GLenum = GLenum(0x8299)
  GL_FILTER*: GLenum = GLenum(0x829A)
  GL_VERTEX_TEXTURE*: GLenum = GLenum(0x829B)
  GL_TESS_CONTROL_TEXTURE*: GLenum = GLenum(0x829C)
  GL_TESS_EVALUATION_TEXTURE*: GLenum = GLenum(0x829D)
  GL_GEOMETRY_TEXTURE*: GLenum = GLenum(0x829E)
  GL_FRAGMENT_TEXTURE*: GLenum = GLenum(0x829F)
  GL_COMPUTE_TEXTURE*: GLenum = GLenum(0x82A0)
  GL_TEXTURE_SHADOW*: GLenum = GLenum(0x82A1)
  GL_TEXTURE_GATHER*: GLenum = GLenum(0x82A2)
  GL_TEXTURE_GATHER_SHADOW*: GLenum = GLenum(0x82A3)
  GL_SHADER_IMAGE_LOAD*: GLenum = GLenum(0x82A4)
  GL_SHADER_IMAGE_STORE*: GLenum = GLenum(0x82A5)
  GL_SHADER_IMAGE_ATOMIC*: GLenum = GLenum(0x82A6)
  GL_IMAGE_TEXEL_SIZE*: GLenum = GLenum(0x82A7)
  GL_IMAGE_COMPATIBILITY_CLASS*: GLenum = GLenum(0x82A8)
  GL_IMAGE_PIXEL_FORMAT*: GLenum = GLenum(0x82A9)
  GL_IMAGE_PIXEL_TYPE*: GLenum = GLenum(0x82AA)
  GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST*: GLenum = GLenum(0x82AC)
  GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST*: GLenum = GLenum(0x82AD)
  GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE*: GLenum = GLenum(0x82AE)
  GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE*: GLenum = GLenum(0x82AF)
  GL_TEXTURE_COMPRESSED_BLOCK_WIDTH*: GLenum = GLenum(0x82B1)
  GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT*: GLenum = GLenum(0x82B2)
  GL_TEXTURE_COMPRESSED_BLOCK_SIZE*: GLenum = GLenum(0x82B3)
  GL_CLEAR_BUFFER*: GLenum = GLenum(0x82B4)
  GL_TEXTURE_VIEW*: GLenum = GLenum(0x82B5)
  GL_VIEW_COMPATIBILITY_CLASS*: GLenum = GLenum(0x82B6)
  GL_FULL_SUPPORT*: GLenum = GLenum(0x82B7)
  GL_CAVEAT_SUPPORT*: GLenum = GLenum(0x82B8)
  GL_IMAGE_CLASS_4_X_32*: GLenum = GLenum(0x82B9)
  GL_IMAGE_CLASS_2_X_32*: GLenum = GLenum(0x82BA)
  GL_IMAGE_CLASS_1_X_32*: GLenum = GLenum(0x82BB)
  GL_IMAGE_CLASS_4_X_16*: GLenum = GLenum(0x82BC)
  GL_IMAGE_CLASS_2_X_16*: GLenum = GLenum(0x82BD)
  GL_IMAGE_CLASS_1_X_16*: GLenum = GLenum(0x82BE)
  GL_IMAGE_CLASS_4_X_8*: GLenum = GLenum(0x82BF)
  GL_IMAGE_CLASS_2_X_8*: GLenum = GLenum(0x82C0)
  GL_IMAGE_CLASS_1_X_8*: GLenum = GLenum(0x82C1)
  GL_IMAGE_CLASS_11_11_10*: GLenum = GLenum(0x82C2)
  GL_IMAGE_CLASS_10_10_10_2*: GLenum = GLenum(0x82C3)
  GL_VIEW_CLASS_128_BITS*: GLenum = GLenum(0x82C4)
  GL_VIEW_CLASS_96_BITS*: GLenum = GLenum(0x82C5)
  GL_VIEW_CLASS_64_BITS*: GLenum = GLenum(0x82C6)
  GL_VIEW_CLASS_48_BITS*: GLenum = GLenum(0x82C7)
  GL_VIEW_CLASS_32_BITS*: GLenum = GLenum(0x82C8)
  GL_VIEW_CLASS_24_BITS*: GLenum = GLenum(0x82C9)
  GL_VIEW_CLASS_16_BITS*: GLenum = GLenum(0x82CA)
  GL_VIEW_CLASS_8_BITS*: GLenum = GLenum(0x82CB)
  GL_VIEW_CLASS_S3TC_DXT1_RGB*: GLenum = GLenum(0x82CC)
  GL_VIEW_CLASS_S3TC_DXT1_RGBA*: GLenum = GLenum(0x82CD)
  GL_VIEW_CLASS_S3TC_DXT3_RGBA*: GLenum = GLenum(0x82CE)
  GL_VIEW_CLASS_S3TC_DXT5_RGBA*: GLenum = GLenum(0x82CF)
  GL_VIEW_CLASS_RGTC1_RED*: GLenum = GLenum(0x82D0)
  GL_VIEW_CLASS_RGTC2_RG*: GLenum = GLenum(0x82D1)
  GL_VIEW_CLASS_BPTC_UNORM*: GLenum = GLenum(0x82D2)
  GL_VIEW_CLASS_BPTC_FLOAT*: GLenum = GLenum(0x82D3)
  GL_VERTEX_ATTRIB_BINDING*: GLenum = GLenum(0x82D4)
  GL_VERTEX_ATTRIB_RELATIVE_OFFSET*: GLenum = GLenum(0x82D5)
  GL_VERTEX_BINDING_DIVISOR*: GLenum = GLenum(0x82D6)
  GL_VERTEX_BINDING_OFFSET*: GLenum = GLenum(0x82D7)
  GL_VERTEX_BINDING_STRIDE*: GLenum = GLenum(0x82D8)
  GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET*: GLenum = GLenum(0x82D9)
  GL_MAX_VERTEX_ATTRIB_BINDINGS*: GLenum = GLenum(0x82DA)
  GL_TEXTURE_VIEW_MIN_LEVEL*: GLenum = GLenum(0x82DB)
  GL_TEXTURE_VIEW_MIN_LEVEL_EXT*: GLenum = GLenum(0x82DB)
  GL_TEXTURE_VIEW_MIN_LEVEL_OES*: GLenum = GLenum(0x82DB)
  GL_TEXTURE_VIEW_NUM_LEVELS*: GLenum = GLenum(0x82DC)
  GL_TEXTURE_VIEW_NUM_LEVELS_EXT*: GLenum = GLenum(0x82DC)
  GL_TEXTURE_VIEW_NUM_LEVELS_OES*: GLenum = GLenum(0x82DC)
  GL_TEXTURE_VIEW_MIN_LAYER*: GLenum = GLenum(0x82DD)
  GL_TEXTURE_VIEW_MIN_LAYER_EXT*: GLenum = GLenum(0x82DD)
  GL_TEXTURE_VIEW_MIN_LAYER_OES*: GLenum = GLenum(0x82DD)
  GL_TEXTURE_VIEW_NUM_LAYERS*: GLenum = GLenum(0x82DE)
  GL_TEXTURE_VIEW_NUM_LAYERS_EXT*: GLenum = GLenum(0x82DE)
  GL_TEXTURE_VIEW_NUM_LAYERS_OES*: GLenum = GLenum(0x82DE)
  GL_TEXTURE_IMMUTABLE_LEVELS*: GLenum = GLenum(0x82DF)
  GL_BUFFER*: GLenum = GLenum(0x82E0)
  GL_BUFFER_KHR*: GLenum = GLenum(0x82E0)
  GL_SHADER*: GLenum = GLenum(0x82E1)
  GL_SHADER_KHR*: GLenum = GLenum(0x82E1)
  GL_PROGRAM*: GLenum = GLenum(0x82E2)
  GL_PROGRAM_KHR*: GLenum = GLenum(0x82E2)
  GL_QUERY*: GLenum = GLenum(0x82E3)
  GL_QUERY_KHR*: GLenum = GLenum(0x82E3)
  GL_PROGRAM_PIPELINE*: GLenum = GLenum(0x82E4)
  GL_PROGRAM_PIPELINE_KHR*: GLenum = GLenum(0x82E4)
  GL_MAX_VERTEX_ATTRIB_STRIDE*: GLenum = GLenum(0x82E5)
  GL_SAMPLER*: GLenum = GLenum(0x82E6)
  GL_SAMPLER_KHR*: GLenum = GLenum(0x82E6)
  GL_DISPLAY_LIST*: GLenum = GLenum(0x82E7)
  GL_MAX_LABEL_LENGTH*: GLenum = GLenum(0x82E8)
  GL_MAX_LABEL_LENGTH_KHR*: GLenum = GLenum(0x82E8)
  GL_NUM_SHADING_LANGUAGE_VERSIONS*: GLenum = GLenum(0x82E9)
  GL_QUERY_TARGET*: GLenum = GLenum(0x82EA)
  GL_TRANSFORM_FEEDBACK_OVERFLOW*: GLenum = GLenum(0x82EC)
  GL_TRANSFORM_FEEDBACK_OVERFLOW_ARB*: GLenum = GLenum(0x82EC)
  GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW*: GLenum = GLenum(0x82ED)
  GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB*: GLenum = GLenum(0x82ED)
  GL_VERTICES_SUBMITTED*: GLenum = GLenum(0x82EE)
  GL_VERTICES_SUBMITTED_ARB*: GLenum = GLenum(0x82EE)
  GL_PRIMITIVES_SUBMITTED*: GLenum = GLenum(0x82EF)
  GL_PRIMITIVES_SUBMITTED_ARB*: GLenum = GLenum(0x82EF)
  GL_VERTEX_SHADER_INVOCATIONS*: GLenum = GLenum(0x82F0)
  GL_VERTEX_SHADER_INVOCATIONS_ARB*: GLenum = GLenum(0x82F0)
  GL_TESS_CONTROL_SHADER_PATCHES*: GLenum = GLenum(0x82F1)
  GL_TESS_CONTROL_SHADER_PATCHES_ARB*: GLenum = GLenum(0x82F1)
  GL_TESS_EVALUATION_SHADER_INVOCATIONS*: GLenum = GLenum(0x82F2)
  GL_TESS_EVALUATION_SHADER_INVOCATIONS_ARB*: GLenum = GLenum(0x82F2)
  GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED*: GLenum = GLenum(0x82F3)
  GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB*: GLenum = GLenum(0x82F3)
  GL_FRAGMENT_SHADER_INVOCATIONS*: GLenum = GLenum(0x82F4)
  GL_FRAGMENT_SHADER_INVOCATIONS_ARB*: GLenum = GLenum(0x82F4)
  GL_COMPUTE_SHADER_INVOCATIONS*: GLenum = GLenum(0x82F5)
  GL_COMPUTE_SHADER_INVOCATIONS_ARB*: GLenum = GLenum(0x82F5)
  GL_CLIPPING_INPUT_PRIMITIVES*: GLenum = GLenum(0x82F6)
  GL_CLIPPING_INPUT_PRIMITIVES_ARB*: GLenum = GLenum(0x82F6)
  GL_CLIPPING_OUTPUT_PRIMITIVES*: GLenum = GLenum(0x82F7)
  GL_CLIPPING_OUTPUT_PRIMITIVES_ARB*: GLenum = GLenum(0x82F7)
  GL_SPARSE_BUFFER_PAGE_SIZE_ARB*: GLenum = GLenum(0x82F8)
  GL_MAX_CULL_DISTANCES*: GLenum = GLenum(0x82F9)
  GL_MAX_CULL_DISTANCES_EXT*: GLenum = GLenum(0x82F9)
  GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES*: GLenum = GLenum(0x82FA)
  GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES_EXT*: GLenum = GLenum(0x82FA)
  GL_CONTEXT_RELEASE_BEHAVIOR*: GLenum = GLenum(0x82FB)
  GL_CONTEXT_RELEASE_BEHAVIOR_KHR*: GLenum = GLenum(0x82FB)
  GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH*: GLenum = GLenum(0x82FC)
  GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_KHR*: GLenum = GLenum(0x82FC)
  GL_ROBUST_GPU_TIMEOUT_MS_KHR*: GLenum = GLenum(0x82FD) ## Reserved for future
  GL_DEPTH_PASS_INSTRUMENT_SGIX*: GLenum = GLenum(0x8310)
  GL_DEPTH_PASS_INSTRUMENT_COUNTERS_SGIX*: GLenum = GLenum(0x8311)
  GL_DEPTH_PASS_INSTRUMENT_MAX_SGIX*: GLenum = GLenum(0x8312)
  GL_FRAGMENTS_INSTRUMENT_SGIX*: GLenum = GLenum(0x8313)
  GL_FRAGMENTS_INSTRUMENT_COUNTERS_SGIX*: GLenum = GLenum(0x8314)
  GL_FRAGMENTS_INSTRUMENT_MAX_SGIX*: GLenum = GLenum(0x8315)
  GL_CONVOLUTION_HINT_SGIX*: GLenum = GLenum(0x8316)
  GL_YCRCB_SGIX*: GLenum = GLenum(0x8318)
  GL_YCRCBA_SGIX*: GLenum = GLenum(0x8319)
  GL_UNPACK_COMPRESSED_SIZE_SGIX*: GLenum = GLenum(0x831A)
  GL_PACK_MAX_COMPRESSED_SIZE_SGIX*: GLenum = GLenum(0x831B)
  GL_PACK_COMPRESSED_SIZE_SGIX*: GLenum = GLenum(0x831C)
  GL_SLIM8U_SGIX*: GLenum = GLenum(0x831D)
  GL_SLIM10U_SGIX*: GLenum = GLenum(0x831E)
  GL_SLIM12S_SGIX*: GLenum = GLenum(0x831F)
  GL_ALPHA_MIN_SGIX*: GLenum = GLenum(0x8320)
  GL_ALPHA_MAX_SGIX*: GLenum = GLenum(0x8321)
  GL_SCALEBIAS_HINT_SGIX*: GLenum = GLenum(0x8322)
  GL_ASYNC_MARKER_SGIX*: GLenum = GLenum(0x8329)
  GL_PIXEL_TEX_GEN_MODE_SGIX*: GLenum = GLenum(0x832B)
  GL_ASYNC_HISTOGRAM_SGIX*: GLenum = GLenum(0x832C)
  GL_MAX_ASYNC_HISTOGRAM_SGIX*: GLenum = GLenum(0x832D)
  GL_PIXEL_TRANSFORM_2D_EXT*: GLenum = GLenum(0x8330)
  GL_PIXEL_MAG_FILTER_EXT*: GLenum = GLenum(0x8331)
  GL_PIXEL_MIN_FILTER_EXT*: GLenum = GLenum(0x8332)
  GL_PIXEL_CUBIC_WEIGHT_EXT*: GLenum = GLenum(0x8333)
  GL_CUBIC_EXT*: GLenum = GLenum(0x8334)
  GL_AVERAGE_EXT*: GLenum = GLenum(0x8335)
  GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT*: GLenum = GLenum(0x8336)
  GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT*: GLenum = GLenum(0x8337)
  GL_PIXEL_TRANSFORM_2D_MATRIX_EXT*: GLenum = GLenum(0x8338)
  GL_FRAGMENT_MATERIAL_EXT*: GLenum = GLenum(0x8349)
  GL_FRAGMENT_NORMAL_EXT*: GLenum = GLenum(0x834A)
  GL_FRAGMENT_COLOR_EXT*: GLenum = GLenum(0x834C)
  GL_ATTENUATION_EXT*: GLenum = GLenum(0x834D)
  GL_SHADOW_ATTENUATION_EXT*: GLenum = GLenum(0x834E)
  GL_TEXTURE_APPLICATION_MODE_EXT*: GLenum = GLenum(0x834F)
  GL_TEXTURE_LIGHT_EXT*: GLenum = GLenum(0x8350)
  GL_TEXTURE_MATERIAL_FACE_EXT*: GLenum = GLenum(0x8351)
  GL_TEXTURE_MATERIAL_PARAMETER_EXT*: GLenum = GLenum(0x8352)
  GL_PIXEL_TEXTURE_SGIS*: GLenum = GLenum(0x8353)
  GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS*: GLenum = GLenum(0x8354)
  GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS*: GLenum = GLenum(0x8355)
  GL_PIXEL_GROUP_COLOR_SGIS*: GLenum = GLenum(0x8356)
  GL_LINE_QUALITY_HINT_SGIX*: GLenum = GLenum(0x835B)
  GL_ASYNC_TEX_IMAGE_SGIX*: GLenum = GLenum(0x835C)
  GL_ASYNC_DRAW_PIXELS_SGIX*: GLenum = GLenum(0x835D)
  GL_ASYNC_READ_PIXELS_SGIX*: GLenum = GLenum(0x835E)
  GL_MAX_ASYNC_TEX_IMAGE_SGIX*: GLenum = GLenum(0x835F)
  GL_MAX_ASYNC_DRAW_PIXELS_SGIX*: GLenum = GLenum(0x8360)
  GL_MAX_ASYNC_READ_PIXELS_SGIX*: GLenum = GLenum(0x8361)
  GL_UNSIGNED_BYTE_2_3_3_REV*: GLenum = GLenum(0x8362)
  GL_UNSIGNED_BYTE_2_3_3_REV_EXT*: GLenum = GLenum(0x8362)
  GL_UNSIGNED_SHORT_5_6_5*: GLenum = GLenum(0x8363)
  GL_UNSIGNED_SHORT_5_6_5_EXT*: GLenum = GLenum(0x8363)
  GL_UNSIGNED_SHORT_5_6_5_REV*: GLenum = GLenum(0x8364)
  GL_UNSIGNED_SHORT_5_6_5_REV_EXT*: GLenum = GLenum(0x8364)
  GL_UNSIGNED_SHORT_4_4_4_4_REV*: GLenum = GLenum(0x8365)
  GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT*: GLenum = GLenum(0x8365)
  GL_UNSIGNED_SHORT_4_4_4_4_REV_IMG*: GLenum = GLenum(0x8365)
  GL_UNSIGNED_SHORT_1_5_5_5_REV*: GLenum = GLenum(0x8366)
  GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT*: GLenum = GLenum(0x8366)
  GL_UNSIGNED_INT_8_8_8_8_REV*: GLenum = GLenum(0x8367)
  GL_UNSIGNED_INT_8_8_8_8_REV_EXT*: GLenum = GLenum(0x8367)
  GL_UNSIGNED_INT_2_10_10_10_REV*: GLenum = GLenum(0x8368)
  GL_UNSIGNED_INT_2_10_10_10_REV_EXT*: GLenum = GLenum(0x8368)
  GL_TEXTURE_MAX_CLAMP_S_SGIX*: GLenum = GLenum(0x8369)
  GL_TEXTURE_MAX_CLAMP_T_SGIX*: GLenum = GLenum(0x836A)
  GL_TEXTURE_MAX_CLAMP_R_SGIX*: GLenum = GLenum(0x836B)
  GL_MIRRORED_REPEAT*: GLenum = GLenum(0x8370)
  GL_MIRRORED_REPEAT_ARB*: GLenum = GLenum(0x8370)
  GL_MIRRORED_REPEAT_IBM*: GLenum = GLenum(0x8370)
  GL_MIRRORED_REPEAT_OES*: GLenum = GLenum(0x8370)
  GL_RGB_S3TC*: GLenum = GLenum(0x83A0)
  GL_RGB4_S3TC*: GLenum = GLenum(0x83A1)
  GL_RGBA_S3TC*: GLenum = GLenum(0x83A2)
  GL_RGBA4_S3TC*: GLenum = GLenum(0x83A3)
  GL_RGBA_DXT5_S3TC*: GLenum = GLenum(0x83A4)
  GL_RGBA4_DXT5_S3TC*: GLenum = GLenum(0x83A5)
  GL_VERTEX_PRECLIP_SGIX*: GLenum = GLenum(0x83EE)
  GL_VERTEX_PRECLIP_HINT_SGIX*: GLenum = GLenum(0x83EF)
  GL_COMPRESSED_RGB_S3TC_DXT1_EXT*: GLenum = GLenum(0x83F0)
  GL_COMPRESSED_RGBA_S3TC_DXT1_EXT*: GLenum = GLenum(0x83F1)
  GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE*: GLenum = GLenum(0x83F2)
  GL_COMPRESSED_RGBA_S3TC_DXT3_EXT*: GLenum = GLenum(0x83F2)
  GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE*: GLenum = GLenum(0x83F3)
  GL_COMPRESSED_RGBA_S3TC_DXT5_EXT*: GLenum = GLenum(0x83F3)
  GL_PARALLEL_ARRAYS_INTEL*: GLenum = GLenum(0x83F4)
  GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL*: GLenum = GLenum(0x83F5)
  GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL*: GLenum = GLenum(0x83F6)
  GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL*: GLenum = GLenum(0x83F7)
  GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL*: GLenum = GLenum(0x83F8)
  GL_PERFQUERY_DONOT_FLUSH_INTEL*: GLenum = GLenum(0x83F9)
  GL_PERFQUERY_FLUSH_INTEL*: GLenum = GLenum(0x83FA)
  GL_PERFQUERY_WAIT_INTEL*: GLenum = GLenum(0x83FB)
  GL_BLACKHOLE_RENDER_INTEL*: GLenum = GLenum(0x83FC)
  GL_CONSERVATIVE_RASTERIZATION_INTEL*: GLenum = GLenum(0x83FE)
  GL_TEXTURE_MEMORY_LAYOUT_INTEL*: GLenum = GLenum(0x83FF)
  GL_FRAGMENT_LIGHTING_SGIX*: GLenum = GLenum(0x8400)
  GL_FRAGMENT_COLOR_MATERIAL_SGIX*: GLenum = GLenum(0x8401)
  GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX*: GLenum = GLenum(0x8402)
  GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX*: GLenum = GLenum(0x8403)
  GL_MAX_FRAGMENT_LIGHTS_SGIX*: GLenum = GLenum(0x8404)
  GL_MAX_ACTIVE_LIGHTS_SGIX*: GLenum = GLenum(0x8405)
  GL_CURRENT_RASTER_NORMAL_SGIX*: GLenum = GLenum(0x8406)
  GL_LIGHT_ENV_MODE_SGIX*: GLenum = GLenum(0x8407)
  GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX*: GLenum = GLenum(0x8408)
  GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX*: GLenum = GLenum(0x8409)
  GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX*: GLenum = GLenum(0x840A)
  GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX*: GLenum = GLenum(0x840B)
  GL_FRAGMENT_LIGHT0_SGIX*: GLenum = GLenum(0x840C)
  GL_FRAGMENT_LIGHT1_SGIX*: GLenum = GLenum(0x840D)
  GL_FRAGMENT_LIGHT2_SGIX*: GLenum = GLenum(0x840E)
  GL_FRAGMENT_LIGHT3_SGIX*: GLenum = GLenum(0x840F)
  GL_FRAGMENT_LIGHT4_SGIX*: GLenum = GLenum(0x8410)
  GL_FRAGMENT_LIGHT5_SGIX*: GLenum = GLenum(0x8411)
  GL_FRAGMENT_LIGHT6_SGIX*: GLenum = GLenum(0x8412)
  GL_FRAGMENT_LIGHT7_SGIX*: GLenum = GLenum(0x8413)
  GL_PACK_RESAMPLE_SGIX*: GLenum = GLenum(0x842E) ## Formerly 0x842C in SGI specfile
  GL_UNPACK_RESAMPLE_SGIX*: GLenum = GLenum(0x842F) ## Formerly 0x842D in SGI specfile
  GL_RESAMPLE_DECIMATE_SGIX*: GLenum = GLenum(0x8430) ## Formerly 0x8430 in SGI specfile
  GL_RESAMPLE_REPLICATE_SGIX*: GLenum = GLenum(0x8433) ## Formerly 0x842E in SGI specfile
  GL_RESAMPLE_ZERO_FILL_SGIX*: GLenum = GLenum(0x8434) ## Formerly 0x842F in SGI specfile
  GL_TANGENT_ARRAY_EXT*: GLenum = GLenum(0x8439)
  GL_BINORMAL_ARRAY_EXT*: GLenum = GLenum(0x843A)
  GL_CURRENT_TANGENT_EXT*: GLenum = GLenum(0x843B)
  GL_CURRENT_BINORMAL_EXT*: GLenum = GLenum(0x843C)
  GL_TANGENT_ARRAY_TYPE_EXT*: GLenum = GLenum(0x843E)
  GL_TANGENT_ARRAY_STRIDE_EXT*: GLenum = GLenum(0x843F)
  GL_BINORMAL_ARRAY_TYPE_EXT*: GLenum = GLenum(0x8440)
  GL_BINORMAL_ARRAY_STRIDE_EXT*: GLenum = GLenum(0x8441)
  GL_TANGENT_ARRAY_POINTER_EXT*: GLenum = GLenum(0x8442)
  GL_BINORMAL_ARRAY_POINTER_EXT*: GLenum = GLenum(0x8443)
  GL_MAP1_TANGENT_EXT*: GLenum = GLenum(0x8444)
  GL_MAP2_TANGENT_EXT*: GLenum = GLenum(0x8445)
  GL_MAP1_BINORMAL_EXT*: GLenum = GLenum(0x8446)
  GL_MAP2_BINORMAL_EXT*: GLenum = GLenum(0x8447)
  GL_NEAREST_CLIPMAP_NEAREST_SGIX*: GLenum = GLenum(0x844D)
  GL_NEAREST_CLIPMAP_LINEAR_SGIX*: GLenum = GLenum(0x844E)
  GL_LINEAR_CLIPMAP_NEAREST_SGIX*: GLenum = GLenum(0x844F)
  GL_REFERENCED_BY_COMPUTE_SHADER*: GLenum = GLenum(0x930B)
  GL_FOG_COORDINATE_SOURCE_EXT*: GLenum = GLenum(0x8450)
  GL_MAX_NAME_LENGTH*: GLenum = GLenum(0x92F6)
  GL_REFERENCED_BY_FRAGMENT_SHADER*: GLenum = GLenum(0x930A)
  GL_ACTIVE_RESOURCES*: GLenum = GLenum(0x92F5)
  GL_FOG_COORDINATE_EXT*: GLenum = GLenum(0x8451)
  GL_REFERENCED_BY_GEOMETRY_SHADER_OES*: GLenum = GLenum(0x9309)
  GL_FRAGMENT_DEPTH_EXT*: GLenum = GLenum(0x8452)
  GL_REFERENCED_BY_GEOMETRY_SHADER_EXT*: GLenum = GLenum(0x9309)
  GL_TRANSFORM_FEEDBACK_VARYING*: GLenum = GLenum(0x92F4)
  GL_CURRENT_FOG_COORDINATE_EXT*: GLenum = GLenum(0x8453)
  GL_REFERENCED_BY_GEOMETRY_SHADER*: GLenum = GLenum(0x9309)
  GL_FOG_COORDINATE_ARRAY_TYPE_EXT*: GLenum = GLenum(0x8454)
  GL_COMPUTE_SUBROUTINE_UNIFORM*: GLenum = GLenum(0x92F3)
  GL_REFERENCED_BY_TESS_EVALUATION_SHADER_OES*: GLenum = GLenum(0x9308)
  GL_FOG_COORDINATE_ARRAY_STRIDE_EXT*: GLenum = GLenum(0x8455)
  GL_FRAGMENT_SUBROUTINE_UNIFORM*: GLenum = GLenum(0x92F2)
  GL_REFERENCED_BY_TESS_EVALUATION_SHADER_EXT*: GLenum = GLenum(0x9308)
  GL_FOG_COORDINATE_ARRAY_POINTER_EXT*: GLenum = GLenum(0x8456)
  GL_GEOMETRY_SUBROUTINE_UNIFORM*: GLenum = GLenum(0x92F1)
  GL_REFERENCED_BY_TESS_EVALUATION_SHADER*: GLenum = GLenum(0x9308)
  GL_FOG_COORDINATE_ARRAY_EXT*: GLenum = GLenum(0x8457)
  GL_TESS_EVALUATION_SUBROUTINE_UNIFORM*: GLenum = GLenum(0x92F0)
  GL_REFERENCED_BY_TESS_CONTROL_SHADER_OES*: GLenum = GLenum(0x9307)
  GL_COLOR_SUM_ARB*: GLenum = GLenum(0x8458)
  GL_COLOR_SUM_EXT*: GLenum = GLenum(0x8458)
  GL_REFERENCED_BY_TESS_CONTROL_SHADER_EXT*: GLenum = GLenum(0x9307)
  GL_CURRENT_SECONDARY_COLOR_EXT*: GLenum = GLenum(0x8459)
  GL_REFERENCED_BY_TESS_CONTROL_SHADER*: GLenum = GLenum(0x9307)
  GL_SECONDARY_COLOR_ARRAY_SIZE_EXT*: GLenum = GLenum(0x845A)
  GL_REFERENCED_BY_VERTEX_SHADER*: GLenum = GLenum(0x9306)
  GL_SECONDARY_COLOR_ARRAY_TYPE_EXT*: GLenum = GLenum(0x845B)
  GL_ACTIVE_VARIABLES*: GLenum = GLenum(0x9305)
  GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT*: GLenum = GLenum(0x845C)
  GL_NUM_ACTIVE_VARIABLES*: GLenum = GLenum(0x9304)
  GL_SECONDARY_COLOR_ARRAY_POINTER_EXT*: GLenum = GLenum(0x845D)
  GL_BUFFER_DATA_SIZE*: GLenum = GLenum(0x9303)
  GL_SECONDARY_COLOR_ARRAY_EXT*: GLenum = GLenum(0x845E)
  GL_IS_PER_PATCH*: GLenum = GLenum(0x92E7)
  GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_NV*: GLenum = GLenum(0x9340)
  GL_ALIASED_LINE_WIDTH_RANGE*: GLenum = GLenum(0x846E)
  GL_SCREEN_COORDINATES_REND*: GLenum = GLenum(0x8490)
  GL_INVERTED_SCREEN_W_REND*: GLenum = GLenum(0x8491)
  GL_TEXTURE0*: GLenum = GLenum(0x84C0)
  GL_TEXTURE0_ARB*: GLenum = GLenum(0x84C0)
  GL_TEXTURE1*: GLenum = GLenum(0x84C1)
  GL_TEXTURE1_ARB*: GLenum = GLenum(0x84C1)
  GL_TEXTURE2*: GLenum = GLenum(0x84C2)
  GL_TEXTURE2_ARB*: GLenum = GLenum(0x84C2)
  GL_TEXTURE3*: GLenum = GLenum(0x84C3)
  GL_TEXTURE3_ARB*: GLenum = GLenum(0x84C3)
  GL_TEXTURE4*: GLenum = GLenum(0x84C4)
  GL_TEXTURE4_ARB*: GLenum = GLenum(0x84C4)
  GL_TEXTURE5*: GLenum = GLenum(0x84C5)
  GL_TEXTURE5_ARB*: GLenum = GLenum(0x84C5)
  GL_TEXTURE6*: GLenum = GLenum(0x84C6)
  GL_TEXTURE6_ARB*: GLenum = GLenum(0x84C6)
  GL_TEXTURE7*: GLenum = GLenum(0x84C7)
  GL_TEXTURE7_ARB*: GLenum = GLenum(0x84C7)
  GL_TEXTURE8*: GLenum = GLenum(0x84C8)
  GL_TEXTURE8_ARB*: GLenum = GLenum(0x84C8)
  GL_TEXTURE9*: GLenum = GLenum(0x84C9)
  GL_TEXTURE9_ARB*: GLenum = GLenum(0x84C9)
  GL_TEXTURE10*: GLenum = GLenum(0x84CA)
  GL_TEXTURE10_ARB*: GLenum = GLenum(0x84CA)
  GL_TEXTURE11*: GLenum = GLenum(0x84CB)
  GL_TEXTURE11_ARB*: GLenum = GLenum(0x84CB)
  GL_TEXTURE12*: GLenum = GLenum(0x84CC)
  GL_TEXTURE12_ARB*: GLenum = GLenum(0x84CC)
  GL_TEXTURE13*: GLenum = GLenum(0x84CD)
  GL_TEXTURE13_ARB*: GLenum = GLenum(0x84CD)
  GL_TEXTURE14*: GLenum = GLenum(0x84CE)
  GL_TEXTURE14_ARB*: GLenum = GLenum(0x84CE)
  GL_TEXTURE15*: GLenum = GLenum(0x84CF)
  GL_TEXTURE15_ARB*: GLenum = GLenum(0x84CF)
  GL_TEXTURE16*: GLenum = GLenum(0x84D0)
  GL_TEXTURE16_ARB*: GLenum = GLenum(0x84D0)
  GL_TEXTURE17*: GLenum = GLenum(0x84D1)
  GL_TEXTURE17_ARB*: GLenum = GLenum(0x84D1)
  GL_TEXTURE18*: GLenum = GLenum(0x84D2)
  GL_TEXTURE18_ARB*: GLenum = GLenum(0x84D2)
  GL_TEXTURE19*: GLenum = GLenum(0x84D3)
  GL_TEXTURE19_ARB*: GLenum = GLenum(0x84D3)
  GL_TEXTURE20*: GLenum = GLenum(0x84D4)
  GL_TEXTURE20_ARB*: GLenum = GLenum(0x84D4)
  GL_TEXTURE21*: GLenum = GLenum(0x84D5)
  GL_TEXTURE21_ARB*: GLenum = GLenum(0x84D5)
  GL_TEXTURE22*: GLenum = GLenum(0x84D6)
  GL_TEXTURE22_ARB*: GLenum = GLenum(0x84D6)
  GL_TEXTURE23*: GLenum = GLenum(0x84D7)
  GL_TEXTURE23_ARB*: GLenum = GLenum(0x84D7)
  GL_TEXTURE24*: GLenum = GLenum(0x84D8)
  GL_TEXTURE24_ARB*: GLenum = GLenum(0x84D8)
  GL_TEXTURE25*: GLenum = GLenum(0x84D9)
  GL_TEXTURE25_ARB*: GLenum = GLenum(0x84D9)
  GL_TEXTURE26*: GLenum = GLenum(0x84DA)
  GL_TEXTURE26_ARB*: GLenum = GLenum(0x84DA)
  GL_TEXTURE27*: GLenum = GLenum(0x84DB)
  GL_TEXTURE27_ARB*: GLenum = GLenum(0x84DB)
  GL_TEXTURE28*: GLenum = GLenum(0x84DC)
  GL_TEXTURE28_ARB*: GLenum = GLenum(0x84DC)
  GL_TEXTURE29*: GLenum = GLenum(0x84DD)
  GL_TEXTURE29_ARB*: GLenum = GLenum(0x84DD)
  GL_TEXTURE30*: GLenum = GLenum(0x84DE)
  GL_TEXTURE30_ARB*: GLenum = GLenum(0x84DE)
  GL_TEXTURE31*: GLenum = GLenum(0x84DF)
  GL_TEXTURE31_ARB*: GLenum = GLenum(0x84DF)
  GL_ACTIVE_TEXTURE*: GLenum = GLenum(0x84E0)
  GL_ACTIVE_TEXTURE_ARB*: GLenum = GLenum(0x84E0)
  GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_ARB*: GLenum = GLenum(0x9340)
  GL_CLIENT_ACTIVE_TEXTURE_ARB*: GLenum = GLenum(0x84E1)
  GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_NV*: GLenum = GLenum(0x933F)
  GL_MAX_TEXTURE_UNITS_ARB*: GLenum = GLenum(0x84E2)
  GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_ARB*: GLenum = GLenum(0x933F)
  GL_TRANSPOSE_MODELVIEW_MATRIX_ARB*: GLenum = GLenum(0x84E3)
  GL_PATH_TRANSPOSE_MODELVIEW_MATRIX_NV*: GLenum = GLenum(0x84E3)
  GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_NV*: GLenum = GLenum(0x933E)
  GL_TRANSPOSE_PROJECTION_MATRIX_ARB*: GLenum = GLenum(0x84E4)
  GL_PATH_TRANSPOSE_PROJECTION_MATRIX_NV*: GLenum = GLenum(0x84E4)
  GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_ARB*: GLenum = GLenum(0x933E)
  GL_TRANSPOSE_TEXTURE_MATRIX_ARB*: GLenum = GLenum(0x84E5)
  GL_SAMPLE_LOCATION_SUBPIXEL_BITS_NV*: GLenum = GLenum(0x933D)
  GL_TRANSPOSE_COLOR_MATRIX_ARB*: GLenum = GLenum(0x84E6)
  GL_FRAMEBUFFER_DEFAULT_SAMPLES*: GLenum = GLenum(0x9313)
  GL_SUBTRACT_ARB*: GLenum = GLenum(0x84E7)
  GL_MAX_RENDERBUFFER_SIZE*: GLenum = GLenum(0x84E8)
  GL_MAX_RENDERBUFFER_SIZE_EXT*: GLenum = GLenum(0x84E8)
  GL_MAX_RENDERBUFFER_SIZE_OES*: GLenum = GLenum(0x84E8)
  GL_WARPS_PER_SM_NV*: GLenum = GLenum(0x933A)
  GL_COMPRESSED_ALPHA_ARB*: GLenum = GLenum(0x84E9)
  GL_WARP_SIZE_NV*: GLenum = GLenum(0x9339)
  GL_COMPRESSED_LUMINANCE_ARB*: GLenum = GLenum(0x84EA)
  GL_COVERAGE_MODULATION_TABLE_SIZE_NV*: GLenum = GLenum(0x9333)
  GL_COMPRESSED_LUMINANCE_ALPHA_ARB*: GLenum = GLenum(0x84EB)
  GL_COVERAGE_MODULATION_NV*: GLenum = GLenum(0x9332)
  GL_COMPRESSED_INTENSITY_ARB*: GLenum = GLenum(0x84EC)
  GL_COMPRESSED_RGB*: GLenum = GLenum(0x84ED)
  GL_COMPRESSED_RGB_ARB*: GLenum = GLenum(0x84ED)
  GL_COMPRESSED_RGBA*: GLenum = GLenum(0x84EE)
  GL_COMPRESSED_RGBA_ARB*: GLenum = GLenum(0x84EE)
  GL_TEXTURE_COMPRESSION_HINT*: GLenum = GLenum(0x84EF)
  GL_TEXTURE_COMPRESSION_HINT_ARB*: GLenum = GLenum(0x84EF)
  GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER*: GLenum = GLenum(0x84F0)
  GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER*: GLenum = GLenum(0x84F1)
  GL_ALL_COMPLETED_NV*: GLenum = GLenum(0x84F2)
  GL_FENCE_STATUS_NV*: GLenum = GLenum(0x84F3)
  GL_FENCE_CONDITION_NV*: GLenum = GLenum(0x84F4)
  GL_TEXTURE_RECTANGLE*: GLenum = GLenum(0x84F5)
  GL_TEXTURE_RECTANGLE_ARB*: GLenum = GLenum(0x84F5)
  GL_TEXTURE_RECTANGLE_NV*: GLenum = GLenum(0x84F5)
  GL_TEXTURE_BINDING_RECTANGLE*: GLenum = GLenum(0x84F6)
  GL_TEXTURE_BINDING_RECTANGLE_ARB*: GLenum = GLenum(0x84F6)
  GL_TEXTURE_BINDING_RECTANGLE_NV*: GLenum = GLenum(0x84F6)
  GL_PROXY_TEXTURE_RECTANGLE*: GLenum = GLenum(0x84F7)
  GL_PROXY_TEXTURE_RECTANGLE_ARB*: GLenum = GLenum(0x84F7)
  GL_PROXY_TEXTURE_RECTANGLE_NV*: GLenum = GLenum(0x84F7)
  GL_MAX_RECTANGLE_TEXTURE_SIZE*: GLenum = GLenum(0x84F8)
  GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB*: GLenum = GLenum(0x84F8)
  GL_MAX_RECTANGLE_TEXTURE_SIZE_NV*: GLenum = GLenum(0x84F8)
  GL_DEPTH_STENCIL*: GLenum = GLenum(0x84F9)
  GL_DEPTH_STENCIL_EXT*: GLenum = GLenum(0x84F9)
  GL_DEPTH_STENCIL_NV*: GLenum = GLenum(0x84F9)
  GL_DEPTH_STENCIL_OES*: GLenum = GLenum(0x84F9)
  GL_UNSIGNED_INT_24_8*: GLenum = GLenum(0x84FA)
  GL_UNSIGNED_INT_24_8_EXT*: GLenum = GLenum(0x84FA)
  GL_UNSIGNED_INT_24_8_NV*: GLenum = GLenum(0x84FA)
  GL_UNSIGNED_INT_24_8_OES*: GLenum = GLenum(0x84FA)
  GL_MAX_TEXTURE_LOD_BIAS*: GLenum = GLenum(0x84FD)
  GL_MAX_TEXTURE_LOD_BIAS_EXT*: GLenum = GLenum(0x84FD)
  GL_TEXTURE_MAX_ANISOTROPY*: GLenum = GLenum(0x84FE)
  GL_TEXTURE_MAX_ANISOTROPY_EXT*: GLenum = GLenum(0x84FE)
  GL_MAX_TEXTURE_MAX_ANISOTROPY*: GLenum = GLenum(0x84FF)
  GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT*: GLenum = GLenum(0x84FF)
  GL_BUFFER_BINDING*: GLenum = GLenum(0x9302)
  GL_TEXTURE_FILTER_CONTROL_EXT*: GLenum = GLenum(0x8500)
  GL_TEXTURE_LOD_BIAS*: GLenum = GLenum(0x8501)
  GL_TEXTURE_LOD_BIAS_EXT*: GLenum = GLenum(0x8501)
  GL_MODELVIEW1_STACK_DEPTH_EXT*: GLenum = GLenum(0x8502)
  GL_COMBINE4_NV*: GLenum = GLenum(0x8503)
  GL_MAX_SHININESS_NV*: GLenum = GLenum(0x8504)
  GL_MAX_SPOT_EXPONENT_NV*: GLenum = GLenum(0x8505)
  GL_MODELVIEW1_MATRIX_EXT*: GLenum = GLenum(0x8506)
  GL_INCR_WRAP*: GLenum = GLenum(0x8507)
  GL_INCR_WRAP_EXT*: GLenum = GLenum(0x8507)
  GL_INCR_WRAP_OES*: GLenum = GLenum(0x8507)
  GL_DECR_WRAP*: GLenum = GLenum(0x8508)
  GL_DECR_WRAP_EXT*: GLenum = GLenum(0x8508)
  GL_DECR_WRAP_OES*: GLenum = GLenum(0x8508)
  GL_VERTEX_WEIGHTING_EXT*: GLenum = GLenum(0x8509)
  GL_MODELVIEW1_ARB*: GLenum = GLenum(0x850A)
  GL_MODELVIEW1_EXT*: GLenum = GLenum(0x850A)
  GL_CURRENT_VERTEX_WEIGHT_EXT*: GLenum = GLenum(0x850B)
  GL_VERTEX_WEIGHT_ARRAY_EXT*: GLenum = GLenum(0x850C)
  GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT*: GLenum = GLenum(0x850D)
  GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT*: GLenum = GLenum(0x850E)
  GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT*: GLenum = GLenum(0x850F)
  GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT*: GLenum = GLenum(0x8510)
  GL_FILL_RECTANGLE_NV*: GLenum = GLenum(0x933C)
  GL_NORMAL_MAP_ARB*: GLenum = GLenum(0x8511)
  GL_NORMAL_MAP_EXT*: GLenum = GLenum(0x8511)
  GL_NORMAL_MAP_NV*: GLenum = GLenum(0x8511)
  GL_NORMAL_MAP_OES*: GLenum = GLenum(0x8511)
  GL_SM_COUNT_NV*: GLenum = GLenum(0x933B)
  GL_REFLECTION_MAP_ARB*: GLenum = GLenum(0x8512)
  GL_REFLECTION_MAP_EXT*: GLenum = GLenum(0x8512)
  GL_REFLECTION_MAP_NV*: GLenum = GLenum(0x8512)
  GL_REFLECTION_MAP_OES*: GLenum = GLenum(0x8512)
  GL_TEXTURE_CUBE_MAP*: GLenum = GLenum(0x8513)
  GL_TEXTURE_CUBE_MAP_ARB*: GLenum = GLenum(0x8513)
  GL_TEXTURE_CUBE_MAP_EXT*: GLenum = GLenum(0x8513)
  GL_TEXTURE_CUBE_MAP_OES*: GLenum = GLenum(0x8513)
  GL_TEXTURE_BINDING_CUBE_MAP*: GLenum = GLenum(0x8514)
  GL_TEXTURE_BINDING_CUBE_MAP_ARB*: GLenum = GLenum(0x8514)
  GL_TEXTURE_BINDING_CUBE_MAP_EXT*: GLenum = GLenum(0x8514)
  GL_TEXTURE_BINDING_CUBE_MAP_OES*: GLenum = GLenum(0x8514)
  GL_TEXTURE_CUBE_MAP_POSITIVE_X*: GLenum = GLenum(0x8515)
  GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB*: GLenum = GLenum(0x8515)
  GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT*: GLenum = GLenum(0x8515)
  GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES*: GLenum = GLenum(0x8515)
  GL_TEXTURE_CUBE_MAP_NEGATIVE_X*: GLenum = GLenum(0x8516)
  GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB*: GLenum = GLenum(0x8516)
  GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT*: GLenum = GLenum(0x8516)
  GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES*: GLenum = GLenum(0x8516)
  GL_TEXTURE_CUBE_MAP_POSITIVE_Y*: GLenum = GLenum(0x8517)
  GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB*: GLenum = GLenum(0x8517)
  GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT*: GLenum = GLenum(0x8517)
  GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES*: GLenum = GLenum(0x8517)
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y*: GLenum = GLenum(0x8518)
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB*: GLenum = GLenum(0x8518)
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT*: GLenum = GLenum(0x8518)
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES*: GLenum = GLenum(0x8518)
  GL_TEXTURE_CUBE_MAP_POSITIVE_Z*: GLenum = GLenum(0x8519)
  GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB*: GLenum = GLenum(0x8519)
  GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT*: GLenum = GLenum(0x8519)
  GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES*: GLenum = GLenum(0x8519)
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z*: GLenum = GLenum(0x851A)
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB*: GLenum = GLenum(0x851A)
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT*: GLenum = GLenum(0x851A)
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES*: GLenum = GLenum(0x851A)
  GL_PROXY_TEXTURE_CUBE_MAP*: GLenum = GLenum(0x851B)
  GL_PROXY_TEXTURE_CUBE_MAP_ARB*: GLenum = GLenum(0x851B)
  GL_PROXY_TEXTURE_CUBE_MAP_EXT*: GLenum = GLenum(0x851B)
  GL_MAX_CUBE_MAP_TEXTURE_SIZE*: GLenum = GLenum(0x851C)
  GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB*: GLenum = GLenum(0x851C)
  GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT*: GLenum = GLenum(0x851C)
  GL_MAX_CUBE_MAP_TEXTURE_SIZE_OES*: GLenum = GLenum(0x851C)
  GL_VERTEX_ARRAY_RANGE_APPLE*: GLenum = GLenum(0x851D)
  GL_VERTEX_ARRAY_RANGE_NV*: GLenum = GLenum(0x851D)
  GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE*: GLenum = GLenum(0x851E)
  GL_VERTEX_ARRAY_RANGE_LENGTH_NV*: GLenum = GLenum(0x851E)
  GL_VERTEX_ARRAY_RANGE_VALID_NV*: GLenum = GLenum(0x851F)
  GL_VERTEX_ARRAY_STORAGE_HINT_APPLE*: GLenum = GLenum(0x851F)
  GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV*: GLenum = GLenum(0x8520)
  GL_VERTEX_ARRAY_RANGE_POINTER_APPLE*: GLenum = GLenum(0x8521)
  GL_VERTEX_ARRAY_RANGE_POINTER_NV*: GLenum = GLenum(0x8521)
  GL_REGISTER_COMBINERS_NV*: GLenum = GLenum(0x8522)
  GL_VARIABLE_A_NV*: GLenum = GLenum(0x8523)
  GL_VARIABLE_B_NV*: GLenum = GLenum(0x8524)
  GL_VARIABLE_C_NV*: GLenum = GLenum(0x8525)
  GL_VARIABLE_D_NV*: GLenum = GLenum(0x8526)
  GL_VARIABLE_E_NV*: GLenum = GLenum(0x8527)
  GL_VARIABLE_F_NV*: GLenum = GLenum(0x8528)
  GL_VARIABLE_G_NV*: GLenum = GLenum(0x8529)
  GL_CONSTANT_COLOR0_NV*: GLenum = GLenum(0x852A)
  GL_CONSTANT_COLOR1_NV*: GLenum = GLenum(0x852B)
  GL_PRIMARY_COLOR_NV*: GLenum = GLenum(0x852C)
  GL_SECONDARY_COLOR_NV*: GLenum = GLenum(0x852D)
  GL_SPARE0_NV*: GLenum = GLenum(0x852E)
  GL_SPARE1_NV*: GLenum = GLenum(0x852F)
  GL_DISCARD_NV*: GLenum = GLenum(0x8530)
  GL_E_TIMES_F_NV*: GLenum = GLenum(0x8531)
  GL_SPARE0_PLUS_SECONDARY_COLOR_NV*: GLenum = GLenum(0x8532)
  GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV*: GLenum = GLenum(0x8533)
  GL_MULTISAMPLE_FILTER_HINT_NV*: GLenum = GLenum(0x8534)
  GL_PER_STAGE_CONSTANTS_NV*: GLenum = GLenum(0x8535)
  GL_UNSIGNED_IDENTITY_NV*: GLenum = GLenum(0x8536)
  GL_UNSIGNED_INVERT_NV*: GLenum = GLenum(0x8537)
  GL_EXPAND_NORMAL_NV*: GLenum = GLenum(0x8538)
  GL_EXPAND_NEGATE_NV*: GLenum = GLenum(0x8539)
  GL_HALF_BIAS_NORMAL_NV*: GLenum = GLenum(0x853A)
  GL_HALF_BIAS_NEGATE_NV*: GLenum = GLenum(0x853B)
  GL_SIGNED_IDENTITY_NV*: GLenum = GLenum(0x853C)
  GL_SIGNED_NEGATE_NV*: GLenum = GLenum(0x853D)
  GL_SCALE_BY_TWO_NV*: GLenum = GLenum(0x853E)
  GL_SCALE_BY_FOUR_NV*: GLenum = GLenum(0x853F)
  GL_SCALE_BY_ONE_HALF_NV*: GLenum = GLenum(0x8540)
  GL_BIAS_BY_NEGATIVE_ONE_HALF_NV*: GLenum = GLenum(0x8541)
  GL_COMBINER_INPUT_NV*: GLenum = GLenum(0x8542)
  GL_COMBINER_MAPPING_NV*: GLenum = GLenum(0x8543)
  GL_COMBINER_COMPONENT_USAGE_NV*: GLenum = GLenum(0x8544)
  GL_COMBINER_AB_DOT_PRODUCT_NV*: GLenum = GLenum(0x8545)
  GL_COMBINER_CD_DOT_PRODUCT_NV*: GLenum = GLenum(0x8546)
  GL_COMBINER_MUX_SUM_NV*: GLenum = GLenum(0x8547)
  GL_COMBINER_SCALE_NV*: GLenum = GLenum(0x8548)
  GL_COMBINER_BIAS_NV*: GLenum = GLenum(0x8549)
  GL_COMBINER_AB_OUTPUT_NV*: GLenum = GLenum(0x854A)
  GL_COMBINER_CD_OUTPUT_NV*: GLenum = GLenum(0x854B)
  GL_COMBINER_SUM_OUTPUT_NV*: GLenum = GLenum(0x854C)
  GL_MAX_GENERAL_COMBINERS_NV*: GLenum = GLenum(0x854D)
  GL_NUM_GENERAL_COMBINERS_NV*: GLenum = GLenum(0x854E)
  GL_COLOR_SUM_CLAMP_NV*: GLenum = GLenum(0x854F)
  GL_COMBINER0_NV*: GLenum = GLenum(0x8550)
  GL_COMBINER1_NV*: GLenum = GLenum(0x8551)
  GL_COMBINER2_NV*: GLenum = GLenum(0x8552)
  GL_COMBINER3_NV*: GLenum = GLenum(0x8553)
  GL_COMBINER4_NV*: GLenum = GLenum(0x8554)
  GL_COMBINER5_NV*: GLenum = GLenum(0x8555)
  GL_COMBINER6_NV*: GLenum = GLenum(0x8556)
  GL_COMBINER7_NV*: GLenum = GLenum(0x8557)
  GL_PRIMITIVE_RESTART_NV*: GLenum = GLenum(0x8558)
  GL_PRIMITIVE_RESTART_INDEX_NV*: GLenum = GLenum(0x8559)
  GL_FOG_DISTANCE_MODE_NV*: GLenum = GLenum(0x855A)
  GL_EYE_RADIAL_NV*: GLenum = GLenum(0x855B)
  GL_EYE_PLANE_ABSOLUTE_NV*: GLenum = GLenum(0x855C)
  GL_EMBOSS_LIGHT_NV*: GLenum = GLenum(0x855D)
  GL_EMBOSS_CONSTANT_NV*: GLenum = GLenum(0x855E)
  GL_EMBOSS_MAP_NV*: GLenum = GLenum(0x855F)
  GL_RED_MIN_CLAMP_INGR*: GLenum = GLenum(0x8560)
  GL_GREEN_MIN_CLAMP_INGR*: GLenum = GLenum(0x8561)
  GL_BLUE_MIN_CLAMP_INGR*: GLenum = GLenum(0x8562)
  GL_ALPHA_MIN_CLAMP_INGR*: GLenum = GLenum(0x8563)
  GL_RED_MAX_CLAMP_INGR*: GLenum = GLenum(0x8564)
  GL_GREEN_MAX_CLAMP_INGR*: GLenum = GLenum(0x8565)
  GL_BLUE_MAX_CLAMP_INGR*: GLenum = GLenum(0x8566)
  GL_ALPHA_MAX_CLAMP_INGR*: GLenum = GLenum(0x8567)
  GL_INTERLACE_READ_INGR*: GLenum = GLenum(0x8568)
  GL_COVERAGE_MODULATION_TABLE_NV*: GLenum = GLenum(0x9331)
  GL_COMBINE_ARB*: GLenum = GLenum(0x8570)
  GL_COMBINE_EXT*: GLenum = GLenum(0x8570)
  GL_MIXED_STENCIL_SAMPLES_SUPPORTED_NV*: GLenum = GLenum(0x9330)
  GL_COMBINE_RGB_ARB*: GLenum = GLenum(0x8571)
  GL_COMBINE_RGB_EXT*: GLenum = GLenum(0x8571)
  GL_MIXED_DEPTH_SAMPLES_SUPPORTED_NV*: GLenum = GLenum(0x932F)
  GL_COMBINE_ALPHA_ARB*: GLenum = GLenum(0x8572)
  GL_COMBINE_ALPHA_EXT*: GLenum = GLenum(0x8572)
  GL_MAX_FRAMEBUFFER_HEIGHT*: GLenum = GLenum(0x9316)
  GL_RGB_SCALE_ARB*: GLenum = GLenum(0x8573)
  GL_RGB_SCALE_EXT*: GLenum = GLenum(0x8573)
  GL_MAX_FRAMEBUFFER_WIDTH*: GLenum = GLenum(0x9315)
  GL_ADD_SIGNED_ARB*: GLenum = GLenum(0x8574)
  GL_ADD_SIGNED_EXT*: GLenum = GLenum(0x8574)
  GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS*: GLenum = GLenum(0x9314)
  GL_INTERPOLATE_ARB*: GLenum = GLenum(0x8575)
  GL_INTERPOLATE_EXT*: GLenum = GLenum(0x8575)
  GL_FRAMEBUFFER_DEFAULT_LAYERS_OES*: GLenum = GLenum(0x9312)
  GL_CONSTANT_ARB*: GLenum = GLenum(0x8576)
  GL_CONSTANT_EXT*: GLenum = GLenum(0x8576)
  GL_CONSTANT_NV*: GLenum = GLenum(0x8576)
  GL_FRAMEBUFFER_DEFAULT_LAYERS_EXT*: GLenum = GLenum(0x9312)
  GL_PRIMARY_COLOR_ARB*: GLenum = GLenum(0x8577)
  GL_PRIMARY_COLOR_EXT*: GLenum = GLenum(0x8577)
  GL_FRAMEBUFFER_DEFAULT_LAYERS*: GLenum = GLenum(0x9312)
  GL_PREVIOUS_ARB*: GLenum = GLenum(0x8578)
  GL_PREVIOUS_EXT*: GLenum = GLenum(0x8578)
  GL_STENCIL_SAMPLES_NV*: GLenum = GLenum(0x932E)
  GL_SOURCE0_RGB_ARB*: GLenum = GLenum(0x8580)
  GL_SOURCE0_RGB_EXT*: GLenum = GLenum(0x8580)
  GL_VERTEX_SUBROUTINE_UNIFORM*: GLenum = GLenum(0x92EE)
  GL_DEPTH_SAMPLES_NV*: GLenum = GLenum(0x932D)
  GL_SOURCE1_RGB_ARB*: GLenum = GLenum(0x8581)
  GL_SOURCE1_RGB_EXT*: GLenum = GLenum(0x8581)
  GL_COMPUTE_SUBROUTINE*: GLenum = GLenum(0x92ED)
  GL_EFFECTIVE_RASTER_SAMPLES_EXT*: GLenum = GLenum(0x932C)
  GL_SOURCE2_RGB_ARB*: GLenum = GLenum(0x8582)
  GL_SOURCE2_RGB_EXT*: GLenum = GLenum(0x8582)
  GL_FRAGMENT_SUBROUTINE*: GLenum = GLenum(0x92EC)
  GL_SOURCE3_RGB_NV*: GLenum = GLenum(0x8583)
  GL_MULTISAMPLE_RASTERIZATION_ALLOWED_EXT*: GLenum = GLenum(0x932B)
  GL_SOURCE0_ALPHA_ARB*: GLenum = GLenum(0x8588)
  GL_SOURCE0_ALPHA_EXT*: GLenum = GLenum(0x8588)
  GL_GEOMETRY_SUBROUTINE*: GLenum = GLenum(0x92EB)
  GL_RASTER_FIXED_SAMPLE_LOCATIONS_EXT*: GLenum = GLenum(0x932A)
  GL_SOURCE1_ALPHA_ARB*: GLenum = GLenum(0x8589)
  GL_SOURCE1_ALPHA_EXT*: GLenum = GLenum(0x8589)
  GL_SRC1_ALPHA*: GLenum = GLenum(0x8589)
  GL_SRC1_ALPHA_EXT*: GLenum = GLenum(0x8589)
  GL_MAX_RASTER_SAMPLES_EXT*: GLenum = GLenum(0x9329)
  GL_SOURCE2_ALPHA_ARB*: GLenum = GLenum(0x858A)
  GL_SOURCE2_ALPHA_EXT*: GLenum = GLenum(0x858A)
  GL_TESS_EVALUATION_SUBROUTINE*: GLenum = GLenum(0x92EA)
  GL_SOURCE3_ALPHA_NV*: GLenum = GLenum(0x858B)
  GL_RASTER_SAMPLES_EXT*: GLenum = GLenum(0x9328)
  GL_OPERAND0_RGB_ARB*: GLenum = GLenum(0x8590)
  GL_OPERAND0_RGB_EXT*: GLenum = GLenum(0x8590)
  GL_RASTER_MULTISAMPLE_EXT*: GLenum = GLenum(0x9327)
  GL_OPERAND1_RGB_ARB*: GLenum = GLenum(0x8591)
  GL_OPERAND1_RGB_EXT*: GLenum = GLenum(0x8591)
  GL_MAX_FRAMEBUFFER_SAMPLES*: GLenum = GLenum(0x9318)
  GL_OPERAND2_RGB_ARB*: GLenum = GLenum(0x8592)
  GL_OPERAND2_RGB_EXT*: GLenum = GLenum(0x8592)
  GL_OPERAND3_RGB_NV*: GLenum = GLenum(0x8593)
  GL_MAX_FRAMEBUFFER_LAYERS_OES*: GLenum = GLenum(0x9317)
  GL_OPERAND0_ALPHA_ARB*: GLenum = GLenum(0x8598)
  GL_OPERAND0_ALPHA_EXT*: GLenum = GLenum(0x8598)
  GL_MAX_FRAMEBUFFER_LAYERS_EXT*: GLenum = GLenum(0x9317)
  GL_OPERAND1_ALPHA_ARB*: GLenum = GLenum(0x8599)
  GL_OPERAND1_ALPHA_EXT*: GLenum = GLenum(0x8599)
  GL_MAX_FRAMEBUFFER_LAYERS*: GLenum = GLenum(0x9317)
  GL_OPERAND2_ALPHA_ARB*: GLenum = GLenum(0x859A)
  GL_OPERAND2_ALPHA_EXT*: GLenum = GLenum(0x859A)
  GL_OPERAND3_ALPHA_NV*: GLenum = GLenum(0x859B)
  GL_PACK_SUBSAMPLE_RATE_SGIX*: GLenum = GLenum(0x85A0)
  GL_UNPACK_SUBSAMPLE_RATE_SGIX*: GLenum = GLenum(0x85A1)
  GL_PIXEL_SUBSAMPLE_4444_SGIX*: GLenum = GLenum(0x85A2)
  GL_PIXEL_SUBSAMPLE_2424_SGIX*: GLenum = GLenum(0x85A3)
  GL_PIXEL_SUBSAMPLE_4242_SGIX*: GLenum = GLenum(0x85A4)
  GL_PERTURB_EXT*: GLenum = GLenum(0x85AE)
  GL_TEXTURE_NORMAL_EXT*: GLenum = GLenum(0x85AF)
  GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE*: GLenum = GLenum(0x85B0)
  GL_TRANSFORM_HINT_APPLE*: GLenum = GLenum(0x85B1)
  GL_UNPACK_CLIENT_STORAGE_APPLE*: GLenum = GLenum(0x85B2)
  GL_BUFFER_OBJECT_APPLE*: GLenum = GLenum(0x85B3)
  GL_STORAGE_CLIENT_APPLE*: GLenum = GLenum(0x85B4)
  GL_VERTEX_ARRAY_BINDING*: GLenum = GLenum(0x85B5)
  GL_VERTEX_ARRAY_BINDING_APPLE*: GLenum = GLenum(0x85B5)
  GL_VERTEX_ARRAY_BINDING_OES*: GLenum = GLenum(0x85B5)
  GL_TEXTURE_RANGE_LENGTH_APPLE*: GLenum = GLenum(0x85B7)
  GL_TEXTURE_RANGE_POINTER_APPLE*: GLenum = GLenum(0x85B8)
  GL_YCBCR_422_APPLE*: GLenum = GLenum(0x85B9)
  GL_UNSIGNED_SHORT_8_8_APPLE*: GLenum = GLenum(0x85BA)
  GL_UNSIGNED_SHORT_8_8_MESA*: GLenum = GLenum(0x85BA)
  GL_UNSIGNED_SHORT_8_8_REV_APPLE*: GLenum = GLenum(0x85BB)
  GL_UNSIGNED_SHORT_8_8_REV_MESA*: GLenum = GLenum(0x85BB)
  GL_TEXTURE_STORAGE_HINT_APPLE*: GLenum = GLenum(0x85BC)
  GL_STORAGE_PRIVATE_APPLE*: GLenum = GLenum(0x85BD)
  GL_STORAGE_CACHED_APPLE*: GLenum = GLenum(0x85BE)
  GL_STORAGE_SHARED_APPLE*: GLenum = GLenum(0x85BF)
  GL_REPLACEMENT_CODE_ARRAY_SUN*: GLenum = GLenum(0x85C0)
  GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN*: GLenum = GLenum(0x85C1)
  GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN*: GLenum = GLenum(0x85C2)
  GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN*: GLenum = GLenum(0x85C3)
  GL_R1UI_V3F_SUN*: GLenum = GLenum(0x85C4)
  GL_R1UI_C4UB_V3F_SUN*: GLenum = GLenum(0x85C5)
  GL_R1UI_C3F_V3F_SUN*: GLenum = GLenum(0x85C6)
  GL_R1UI_N3F_V3F_SUN*: GLenum = GLenum(0x85C7)
  GL_R1UI_C4F_N3F_V3F_SUN*: GLenum = GLenum(0x85C8)
  GL_R1UI_T2F_V3F_SUN*: GLenum = GLenum(0x85C9)
  GL_R1UI_T2F_N3F_V3F_SUN*: GLenum = GLenum(0x85CA)
  GL_R1UI_T2F_C4F_N3F_V3F_SUN*: GLenum = GLenum(0x85CB)
  GL_SLICE_ACCUM_SUN*: GLenum = GLenum(0x85CC)
  GL_QUAD_MESH_SUN*: GLenum = GLenum(0x8614)
  GL_TRIANGLE_MESH_SUN*: GLenum = GLenum(0x8615)
  GL_VERTEX_PROGRAM_ARB*: GLenum = GLenum(0x8620)
  GL_VERTEX_PROGRAM_NV*: GLenum = GLenum(0x8620)
  GL_VERTEX_STATE_PROGRAM_NV*: GLenum = GLenum(0x8621)
  GL_VERTEX_ATTRIB_ARRAY_ENABLED*: GLenum = GLenum(0x8622)
  GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB*: GLenum = GLenum(0x8622)
  GL_ATTRIB_ARRAY_SIZE_NV*: GLenum = GLenum(0x8623)
  GL_VERTEX_ATTRIB_ARRAY_SIZE*: GLenum = GLenum(0x8623)
  GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB*: GLenum = GLenum(0x8623)
  GL_ATTRIB_ARRAY_STRIDE_NV*: GLenum = GLenum(0x8624)
  GL_VERTEX_ATTRIB_ARRAY_STRIDE*: GLenum = GLenum(0x8624)
  GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB*: GLenum = GLenum(0x8624)
  GL_ATTRIB_ARRAY_TYPE_NV*: GLenum = GLenum(0x8625)
  GL_VERTEX_ATTRIB_ARRAY_TYPE*: GLenum = GLenum(0x8625)
  GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB*: GLenum = GLenum(0x8625)
  GL_CURRENT_ATTRIB_NV*: GLenum = GLenum(0x8626)
  GL_CURRENT_VERTEX_ATTRIB*: GLenum = GLenum(0x8626)
  GL_CURRENT_VERTEX_ATTRIB_ARB*: GLenum = GLenum(0x8626)
  GL_PROGRAM_LENGTH_ARB*: GLenum = GLenum(0x8627)
  GL_PROGRAM_LENGTH_NV*: GLenum = GLenum(0x8627)
  GL_PROGRAM_STRING_ARB*: GLenum = GLenum(0x8628)
  GL_PROGRAM_STRING_NV*: GLenum = GLenum(0x8628)
  GL_MODELVIEW_PROJECTION_NV*: GLenum = GLenum(0x8629)
  GL_IDENTITY_NV*: GLenum = GLenum(0x862A)
  GL_INVERSE_NV*: GLenum = GLenum(0x862B)
  GL_TRANSPOSE_NV*: GLenum = GLenum(0x862C)
  GL_INVERSE_TRANSPOSE_NV*: GLenum = GLenum(0x862D)
  GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB*: GLenum = GLenum(0x862E)
  GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV*: GLenum = GLenum(0x862E)
  GL_MAX_PROGRAM_MATRICES_ARB*: GLenum = GLenum(0x862F)
  GL_MAX_TRACK_MATRICES_NV*: GLenum = GLenum(0x862F)
  GL_MATRIX0_NV*: GLenum = GLenum(0x8630)
  GL_MATRIX1_NV*: GLenum = GLenum(0x8631)
  GL_MATRIX2_NV*: GLenum = GLenum(0x8632)
  GL_MATRIX3_NV*: GLenum = GLenum(0x8633)
  GL_MATRIX4_NV*: GLenum = GLenum(0x8634)
  GL_MATRIX5_NV*: GLenum = GLenum(0x8635)
  GL_MATRIX6_NV*: GLenum = GLenum(0x8636)
  GL_MATRIX7_NV*: GLenum = GLenum(0x8637)
  GL_CURRENT_MATRIX_STACK_DEPTH_ARB*: GLenum = GLenum(0x8640)
  GL_CURRENT_MATRIX_STACK_DEPTH_NV*: GLenum = GLenum(0x8640)
  GL_CURRENT_MATRIX_ARB*: GLenum = GLenum(0x8641)
  GL_CURRENT_MATRIX_NV*: GLenum = GLenum(0x8641)
  GL_VERTEX_PROGRAM_POINT_SIZE*: GLenum = GLenum(0x8642)
  GL_VERTEX_PROGRAM_POINT_SIZE_ARB*: GLenum = GLenum(0x8642)
  GL_VERTEX_PROGRAM_POINT_SIZE_NV*: GLenum = GLenum(0x8642)
  GL_PROGRAM_POINT_SIZE*: GLenum = GLenum(0x8642)
  GL_PROGRAM_POINT_SIZE_ARB*: GLenum = GLenum(0x8642)
  GL_PROGRAM_POINT_SIZE_EXT*: GLenum = GLenum(0x8642)
  GL_TESS_CONTROL_SUBROUTINE*: GLenum = GLenum(0x92E9)
  GL_VERTEX_PROGRAM_TWO_SIDE_ARB*: GLenum = GLenum(0x8643)
  GL_VERTEX_PROGRAM_TWO_SIDE_NV*: GLenum = GLenum(0x8643)
  GL_PROGRAM_PARAMETER_NV*: GLenum = GLenum(0x8644)
  GL_ATTRIB_ARRAY_POINTER_NV*: GLenum = GLenum(0x8645)
  GL_VERTEX_ATTRIB_ARRAY_POINTER*: GLenum = GLenum(0x8645)
  GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB*: GLenum = GLenum(0x8645)
  GL_PROGRAM_TARGET_NV*: GLenum = GLenum(0x8646)
  GL_PROGRAM_RESIDENT_NV*: GLenum = GLenum(0x8647)
  GL_TRACK_MATRIX_NV*: GLenum = GLenum(0x8648)
  GL_TRACK_MATRIX_TRANSFORM_NV*: GLenum = GLenum(0x8649)
  GL_VERTEX_PROGRAM_BINDING_NV*: GLenum = GLenum(0x864A)
  GL_PROGRAM_ERROR_POSITION_ARB*: GLenum = GLenum(0x864B)
  GL_PROGRAM_ERROR_POSITION_NV*: GLenum = GLenum(0x864B)
  GL_OFFSET_TEXTURE_RECTANGLE_NV*: GLenum = GLenum(0x864C)
  GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV*: GLenum = GLenum(0x864D)
  GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV*: GLenum = GLenum(0x864E)
  GL_DEPTH_CLAMP*: GLenum = GLenum(0x864F)
  GL_DEPTH_CLAMP_NV*: GLenum = GLenum(0x864F)
  GL_VERTEX_ATTRIB_ARRAY0_NV*: GLenum = GLenum(0x8650)
  GL_VERTEX_ATTRIB_ARRAY1_NV*: GLenum = GLenum(0x8651)
  GL_VERTEX_ATTRIB_ARRAY2_NV*: GLenum = GLenum(0x8652)
  GL_VERTEX_ATTRIB_ARRAY3_NV*: GLenum = GLenum(0x8653)
  GL_VERTEX_ATTRIB_ARRAY4_NV*: GLenum = GLenum(0x8654)
  GL_VERTEX_ATTRIB_ARRAY5_NV*: GLenum = GLenum(0x8655)
  GL_VERTEX_ATTRIB_ARRAY6_NV*: GLenum = GLenum(0x8656)
  GL_VERTEX_ATTRIB_ARRAY7_NV*: GLenum = GLenum(0x8657)
  GL_VERTEX_ATTRIB_ARRAY8_NV*: GLenum = GLenum(0x8658)
  GL_VERTEX_ATTRIB_ARRAY9_NV*: GLenum = GLenum(0x8659)
  GL_VERTEX_ATTRIB_ARRAY10_NV*: GLenum = GLenum(0x865A)
  GL_VERTEX_ATTRIB_ARRAY11_NV*: GLenum = GLenum(0x865B)
  GL_VERTEX_ATTRIB_ARRAY12_NV*: GLenum = GLenum(0x865C)
  GL_VERTEX_ATTRIB_ARRAY13_NV*: GLenum = GLenum(0x865D)
  GL_VERTEX_ATTRIB_ARRAY14_NV*: GLenum = GLenum(0x865E)
  GL_VERTEX_ATTRIB_ARRAY15_NV*: GLenum = GLenum(0x865F)
  GL_MAP1_VERTEX_ATTRIB0_4_NV*: GLenum = GLenum(0x8660)
  GL_MAP1_VERTEX_ATTRIB1_4_NV*: GLenum = GLenum(0x8661)
  GL_MAP1_VERTEX_ATTRIB2_4_NV*: GLenum = GLenum(0x8662)
  GL_MAP1_VERTEX_ATTRIB3_4_NV*: GLenum = GLenum(0x8663)
  GL_MAP1_VERTEX_ATTRIB4_4_NV*: GLenum = GLenum(0x8664)
  GL_MAP1_VERTEX_ATTRIB5_4_NV*: GLenum = GLenum(0x8665)
  GL_MAP1_VERTEX_ATTRIB6_4_NV*: GLenum = GLenum(0x8666)
  GL_MAP1_VERTEX_ATTRIB7_4_NV*: GLenum = GLenum(0x8667)
  GL_MAP1_VERTEX_ATTRIB8_4_NV*: GLenum = GLenum(0x8668)
  GL_MAP1_VERTEX_ATTRIB9_4_NV*: GLenum = GLenum(0x8669)
  GL_MAP1_VERTEX_ATTRIB10_4_NV*: GLenum = GLenum(0x866A)
  GL_MAP1_VERTEX_ATTRIB11_4_NV*: GLenum = GLenum(0x866B)
  GL_MAP1_VERTEX_ATTRIB12_4_NV*: GLenum = GLenum(0x866C)
  GL_MAP1_VERTEX_ATTRIB13_4_NV*: GLenum = GLenum(0x866D)
  GL_MAP1_VERTEX_ATTRIB14_4_NV*: GLenum = GLenum(0x866E)
  GL_MAP1_VERTEX_ATTRIB15_4_NV*: GLenum = GLenum(0x866F)
  GL_MAP2_VERTEX_ATTRIB0_4_NV*: GLenum = GLenum(0x8670)
  GL_MAP2_VERTEX_ATTRIB1_4_NV*: GLenum = GLenum(0x8671)
  GL_MAP2_VERTEX_ATTRIB2_4_NV*: GLenum = GLenum(0x8672)
  GL_MAP2_VERTEX_ATTRIB3_4_NV*: GLenum = GLenum(0x8673)
  GL_MAP2_VERTEX_ATTRIB4_4_NV*: GLenum = GLenum(0x8674)
  GL_MAP2_VERTEX_ATTRIB5_4_NV*: GLenum = GLenum(0x8675)
  GL_MAP2_VERTEX_ATTRIB6_4_NV*: GLenum = GLenum(0x8676)
  GL_MAP2_VERTEX_ATTRIB7_4_NV*: GLenum = GLenum(0x8677)
  GL_PROGRAM_BINDING_ARB*: GLenum = GLenum(0x8677) ## NOT an alias. Accidental reuse of GL_MAP2_VERTEX_ATTRIB7_4_NV
  GL_MAP2_VERTEX_ATTRIB8_4_NV*: GLenum = GLenum(0x8678)
  GL_MAP2_VERTEX_ATTRIB9_4_NV*: GLenum = GLenum(0x8679)
  GL_MAP2_VERTEX_ATTRIB10_4_NV*: GLenum = GLenum(0x867A)
  GL_MAP2_VERTEX_ATTRIB11_4_NV*: GLenum = GLenum(0x867B)
  GL_MAP2_VERTEX_ATTRIB12_4_NV*: GLenum = GLenum(0x867C)
  GL_MAP2_VERTEX_ATTRIB13_4_NV*: GLenum = GLenum(0x867D)
  GL_MAP2_VERTEX_ATTRIB14_4_NV*: GLenum = GLenum(0x867E)
  GL_MAP2_VERTEX_ATTRIB15_4_NV*: GLenum = GLenum(0x867F)
  GL_TEXTURE_COMPRESSED_IMAGE_SIZE*: GLenum = GLenum(0x86A0)
  GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB*: GLenum = GLenum(0x86A0)
  GL_TEXTURE_COMPRESSED*: GLenum = GLenum(0x86A1)
  GL_TEXTURE_COMPRESSED_ARB*: GLenum = GLenum(0x86A1)
  GL_NUM_COMPRESSED_TEXTURE_FORMATS*: GLenum = GLenum(0x86A2)
  GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB*: GLenum = GLenum(0x86A2)
  GL_COMPRESSED_TEXTURE_FORMATS*: GLenum = GLenum(0x86A3)
  GL_COMPRESSED_TEXTURE_FORMATS_ARB*: GLenum = GLenum(0x86A3)
  GL_MAX_VERTEX_UNITS_ARB*: GLenum = GLenum(0x86A4)
  GL_MAX_VERTEX_UNITS_OES*: GLenum = GLenum(0x86A4)
  GL_ACTIVE_VERTEX_UNITS_ARB*: GLenum = GLenum(0x86A5)
  GL_WEIGHT_SUM_UNITY_ARB*: GLenum = GLenum(0x86A6)
  GL_VERTEX_BLEND_ARB*: GLenum = GLenum(0x86A7)
  GL_CURRENT_WEIGHT_ARB*: GLenum = GLenum(0x86A8)
  GL_WEIGHT_ARRAY_TYPE_ARB*: GLenum = GLenum(0x86A9)
  GL_WEIGHT_ARRAY_TYPE_OES*: GLenum = GLenum(0x86A9)
  GL_WEIGHT_ARRAY_STRIDE_ARB*: GLenum = GLenum(0x86AA)
  GL_WEIGHT_ARRAY_STRIDE_OES*: GLenum = GLenum(0x86AA)
  GL_WEIGHT_ARRAY_SIZE_ARB*: GLenum = GLenum(0x86AB)
  GL_WEIGHT_ARRAY_SIZE_OES*: GLenum = GLenum(0x86AB)
  GL_WEIGHT_ARRAY_POINTER_ARB*: GLenum = GLenum(0x86AC)
  GL_WEIGHT_ARRAY_POINTER_OES*: GLenum = GLenum(0x86AC)
  GL_WEIGHT_ARRAY_ARB*: GLenum = GLenum(0x86AD)
  GL_WEIGHT_ARRAY_OES*: GLenum = GLenum(0x86AD)
  GL_FRAMEBUFFER_DEFAULT_HEIGHT*: GLenum = GLenum(0x9311)
  GL_DOT3_RGB_ARB*: GLenum = GLenum(0x86AE)
  GL_FRAMEBUFFER_DEFAULT_WIDTH*: GLenum = GLenum(0x9310)
  GL_DOT3_RGBA_ARB*: GLenum = GLenum(0x86AF)
  GL_DOT3_RGBA_IMG*: GLenum = GLenum(0x86AF)
  GL_COMPRESSED_RGB_FXT1_3DFX*: GLenum = GLenum(0x86B0)
  GL_COMPRESSED_RGBA_FXT1_3DFX*: GLenum = GLenum(0x86B1)
  GL_MULTISAMPLE_3DFX*: GLenum = GLenum(0x86B2)
  GL_SAMPLE_BUFFERS_3DFX*: GLenum = GLenum(0x86B3)
  GL_SAMPLES_3DFX*: GLenum = GLenum(0x86B4)
  GL_EVAL_2D_NV*: GLenum = GLenum(0x86C0)
  GL_EVAL_TRIANGULAR_2D_NV*: GLenum = GLenum(0x86C1)
  GL_MAP_TESSELLATION_NV*: GLenum = GLenum(0x86C2)
  GL_MAP_ATTRIB_U_ORDER_NV*: GLenum = GLenum(0x86C3)
  GL_MAP_ATTRIB_V_ORDER_NV*: GLenum = GLenum(0x86C4)
  GL_EVAL_FRACTIONAL_TESSELLATION_NV*: GLenum = GLenum(0x86C5)
  GL_EVAL_VERTEX_ATTRIB0_NV*: GLenum = GLenum(0x86C6)
  GL_EVAL_VERTEX_ATTRIB1_NV*: GLenum = GLenum(0x86C7)
  GL_EVAL_VERTEX_ATTRIB2_NV*: GLenum = GLenum(0x86C8)
  GL_EVAL_VERTEX_ATTRIB3_NV*: GLenum = GLenum(0x86C9)
  GL_EVAL_VERTEX_ATTRIB4_NV*: GLenum = GLenum(0x86CA)
  GL_EVAL_VERTEX_ATTRIB5_NV*: GLenum = GLenum(0x86CB)
  GL_EVAL_VERTEX_ATTRIB6_NV*: GLenum = GLenum(0x86CC)
  GL_EVAL_VERTEX_ATTRIB7_NV*: GLenum = GLenum(0x86CD)
  GL_EVAL_VERTEX_ATTRIB8_NV*: GLenum = GLenum(0x86CE)
  GL_EVAL_VERTEX_ATTRIB9_NV*: GLenum = GLenum(0x86CF)
  GL_EVAL_VERTEX_ATTRIB10_NV*: GLenum = GLenum(0x86D0)
  GL_EVAL_VERTEX_ATTRIB11_NV*: GLenum = GLenum(0x86D1)
  GL_EVAL_VERTEX_ATTRIB12_NV*: GLenum = GLenum(0x86D2)
  GL_EVAL_VERTEX_ATTRIB13_NV*: GLenum = GLenum(0x86D3)
  GL_EVAL_VERTEX_ATTRIB14_NV*: GLenum = GLenum(0x86D4)
  GL_EVAL_VERTEX_ATTRIB15_NV*: GLenum = GLenum(0x86D5)
  GL_MAX_MAP_TESSELLATION_NV*: GLenum = GLenum(0x86D6)
  GL_MAX_RATIONAL_EVAL_ORDER_NV*: GLenum = GLenum(0x86D7)
  GL_MAX_PROGRAM_PATCH_ATTRIBS_NV*: GLenum = GLenum(0x86D8)
  GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV*: GLenum = GLenum(0x86D9)
  GL_UNSIGNED_INT_S8_S8_8_8_NV*: GLenum = GLenum(0x86DA)
  GL_UNSIGNED_INT_8_8_S8_S8_REV_NV*: GLenum = GLenum(0x86DB)
  GL_DSDT_MAG_INTENSITY_NV*: GLenum = GLenum(0x86DC)
  GL_SHADER_CONSISTENT_NV*: GLenum = GLenum(0x86DD)
  GL_TEXTURE_SHADER_NV*: GLenum = GLenum(0x86DE)
  GL_SHADER_OPERATION_NV*: GLenum = GLenum(0x86DF)
  GL_CULL_MODES_NV*: GLenum = GLenum(0x86E0)
  GL_OFFSET_TEXTURE_MATRIX_NV*: GLenum = GLenum(0x86E1)
  GL_OFFSET_TEXTURE_2D_MATRIX_NV*: GLenum = GLenum(0x86E1)
  GL_OFFSET_TEXTURE_SCALE_NV*: GLenum = GLenum(0x86E2)
  GL_OFFSET_TEXTURE_2D_SCALE_NV*: GLenum = GLenum(0x86E2)
  GL_OFFSET_TEXTURE_BIAS_NV*: GLenum = GLenum(0x86E3)
  GL_OFFSET_TEXTURE_2D_BIAS_NV*: GLenum = GLenum(0x86E3)
  GL_PREVIOUS_TEXTURE_INPUT_NV*: GLenum = GLenum(0x86E4)
  GL_CONST_EYE_NV*: GLenum = GLenum(0x86E5)
  GL_PASS_THROUGH_NV*: GLenum = GLenum(0x86E6)
  GL_CULL_FRAGMENT_NV*: GLenum = GLenum(0x86E7)
  GL_OFFSET_TEXTURE_2D_NV*: GLenum = GLenum(0x86E8)
  GL_DEPENDENT_AR_TEXTURE_2D_NV*: GLenum = GLenum(0x86E9)
  GL_DEPENDENT_GB_TEXTURE_2D_NV*: GLenum = GLenum(0x86EA)
  GL_SURFACE_STATE_NV*: GLenum = GLenum(0x86EB)
  GL_DOT_PRODUCT_NV*: GLenum = GLenum(0x86EC)
  GL_DOT_PRODUCT_DEPTH_REPLACE_NV*: GLenum = GLenum(0x86ED)
  GL_DOT_PRODUCT_TEXTURE_2D_NV*: GLenum = GLenum(0x86EE)
  GL_DOT_PRODUCT_TEXTURE_3D_NV*: GLenum = GLenum(0x86EF)
  GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV*: GLenum = GLenum(0x86F0)
  GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV*: GLenum = GLenum(0x86F1)
  GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV*: GLenum = GLenum(0x86F2)
  GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV*: GLenum = GLenum(0x86F3)
  GL_HILO_NV*: GLenum = GLenum(0x86F4)
  GL_DSDT_NV*: GLenum = GLenum(0x86F5)
  GL_DSDT_MAG_NV*: GLenum = GLenum(0x86F6)
  GL_DSDT_MAG_VIB_NV*: GLenum = GLenum(0x86F7)
  GL_HILO16_NV*: GLenum = GLenum(0x86F8)
  GL_SIGNED_HILO_NV*: GLenum = GLenum(0x86F9)
  GL_SIGNED_HILO16_NV*: GLenum = GLenum(0x86FA)
  GL_SIGNED_RGBA_NV*: GLenum = GLenum(0x86FB)
  GL_SIGNED_RGBA8_NV*: GLenum = GLenum(0x86FC)
  GL_SURFACE_REGISTERED_NV*: GLenum = GLenum(0x86FD)
  GL_SIGNED_RGB_NV*: GLenum = GLenum(0x86FE)
  GL_SIGNED_RGB8_NV*: GLenum = GLenum(0x86FF)
  GL_SURFACE_MAPPED_NV*: GLenum = GLenum(0x8700)
  GL_SIGNED_LUMINANCE_NV*: GLenum = GLenum(0x8701)
  GL_SIGNED_LUMINANCE8_NV*: GLenum = GLenum(0x8702)
  GL_SIGNED_LUMINANCE_ALPHA_NV*: GLenum = GLenum(0x8703)
  GL_SIGNED_LUMINANCE8_ALPHA8_NV*: GLenum = GLenum(0x8704)
  GL_SIGNED_ALPHA_NV*: GLenum = GLenum(0x8705)
  GL_SIGNED_ALPHA8_NV*: GLenum = GLenum(0x8706)
  GL_SIGNED_INTENSITY_NV*: GLenum = GLenum(0x8707)
  GL_SIGNED_INTENSITY8_NV*: GLenum = GLenum(0x8708)
  GL_DSDT8_NV*: GLenum = GLenum(0x8709)
  GL_DSDT8_MAG8_NV*: GLenum = GLenum(0x870A)
  GL_DSDT8_MAG8_INTENSITY8_NV*: GLenum = GLenum(0x870B)
  GL_SIGNED_RGB_UNSIGNED_ALPHA_NV*: GLenum = GLenum(0x870C)
  GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV*: GLenum = GLenum(0x870D)
  GL_HI_SCALE_NV*: GLenum = GLenum(0x870E)
  GL_LO_SCALE_NV*: GLenum = GLenum(0x870F)
  GL_DS_SCALE_NV*: GLenum = GLenum(0x8710)
  GL_DT_SCALE_NV*: GLenum = GLenum(0x8711)
  GL_MAGNITUDE_SCALE_NV*: GLenum = GLenum(0x8712)
  GL_VIBRANCE_SCALE_NV*: GLenum = GLenum(0x8713)
  GL_HI_BIAS_NV*: GLenum = GLenum(0x8714)
  GL_LO_BIAS_NV*: GLenum = GLenum(0x8715)
  GL_DS_BIAS_NV*: GLenum = GLenum(0x8716)
  GL_DT_BIAS_NV*: GLenum = GLenum(0x8717)
  GL_MAGNITUDE_BIAS_NV*: GLenum = GLenum(0x8718)
  GL_VIBRANCE_BIAS_NV*: GLenum = GLenum(0x8719)
  GL_TEXTURE_BORDER_VALUES_NV*: GLenum = GLenum(0x871A)
  GL_TEXTURE_HI_SIZE_NV*: GLenum = GLenum(0x871B)
  GL_TEXTURE_LO_SIZE_NV*: GLenum = GLenum(0x871C)
  GL_TEXTURE_DS_SIZE_NV*: GLenum = GLenum(0x871D)
  GL_TEXTURE_DT_SIZE_NV*: GLenum = GLenum(0x871E)
  GL_TEXTURE_MAG_SIZE_NV*: GLenum = GLenum(0x871F)
  GL_MODELVIEW2_ARB*: GLenum = GLenum(0x8722)
  GL_MODELVIEW3_ARB*: GLenum = GLenum(0x8723)
  GL_MODELVIEW4_ARB*: GLenum = GLenum(0x8724)
  GL_MODELVIEW5_ARB*: GLenum = GLenum(0x8725)
  GL_MODELVIEW6_ARB*: GLenum = GLenum(0x8726)
  GL_MODELVIEW7_ARB*: GLenum = GLenum(0x8727)
  GL_MODELVIEW8_ARB*: GLenum = GLenum(0x8728)
  GL_MODELVIEW9_ARB*: GLenum = GLenum(0x8729)
  GL_MODELVIEW10_ARB*: GLenum = GLenum(0x872A)
  GL_MODELVIEW11_ARB*: GLenum = GLenum(0x872B)
  GL_MODELVIEW12_ARB*: GLenum = GLenum(0x872C)
  GL_MODELVIEW13_ARB*: GLenum = GLenum(0x872D)
  GL_MODELVIEW14_ARB*: GLenum = GLenum(0x872E)
  GL_MODELVIEW15_ARB*: GLenum = GLenum(0x872F)
  GL_MODELVIEW16_ARB*: GLenum = GLenum(0x8730)
  GL_MODELVIEW17_ARB*: GLenum = GLenum(0x8731)
  GL_MODELVIEW18_ARB*: GLenum = GLenum(0x8732)
  GL_MODELVIEW19_ARB*: GLenum = GLenum(0x8733)
  GL_MODELVIEW20_ARB*: GLenum = GLenum(0x8734)
  GL_MODELVIEW21_ARB*: GLenum = GLenum(0x8735)
  GL_MODELVIEW22_ARB*: GLenum = GLenum(0x8736)
  GL_MODELVIEW23_ARB*: GLenum = GLenum(0x8737)
  GL_MODELVIEW24_ARB*: GLenum = GLenum(0x8738)
  GL_MODELVIEW25_ARB*: GLenum = GLenum(0x8739)
  GL_MODELVIEW26_ARB*: GLenum = GLenum(0x873A)
  GL_MODELVIEW27_ARB*: GLenum = GLenum(0x873B)
  GL_MODELVIEW28_ARB*: GLenum = GLenum(0x873C)
  GL_MODELVIEW29_ARB*: GLenum = GLenum(0x873D)
  GL_MODELVIEW30_ARB*: GLenum = GLenum(0x873E)
  GL_MODELVIEW31_ARB*: GLenum = GLenum(0x873F)
  GL_DOT3_RGB_EXT*: GLenum = GLenum(0x8740)
  GL_Z400_BINARY_AMD*: GLenum = GLenum(0x8740) ## NOT an alias. Accidental reuse of GL_DOT3_RGB_EXT
  GL_DOT3_RGBA_EXT*: GLenum = GLenum(0x8741)
  GL_PROGRAM_BINARY_LENGTH_OES*: GLenum = GLenum(0x8741) ## NOT an alias. Accidental reuse of GL_DOT3_RGBA_EXT
  GL_PROGRAM_BINARY_LENGTH*: GLenum = GLenum(0x8741)
  GL_MIRROR_CLAMP_ATI*: GLenum = GLenum(0x8742)
  GL_MIRROR_CLAMP_EXT*: GLenum = GLenum(0x8742)
  GL_MIRROR_CLAMP_TO_EDGE*: GLenum = GLenum(0x8743)
  GL_MIRROR_CLAMP_TO_EDGE_ATI*: GLenum = GLenum(0x8743)
  GL_MIRROR_CLAMP_TO_EDGE_EXT*: GLenum = GLenum(0x8743)
  GL_MODULATE_ADD_ATI*: GLenum = GLenum(0x8744)
  GL_MODULATE_SIGNED_ADD_ATI*: GLenum = GLenum(0x8745)
  GL_MODULATE_SUBTRACT_ATI*: GLenum = GLenum(0x8746)
  GL_SET_AMD*: GLenum = GLenum(0x874A)
  GL_REPLACE_VALUE_AMD*: GLenum = GLenum(0x874B)
  GL_STENCIL_OP_VALUE_AMD*: GLenum = GLenum(0x874C)
  GL_STENCIL_BACK_OP_VALUE_AMD*: GLenum = GLenum(0x874D)
  GL_VERTEX_ATTRIB_ARRAY_LONG*: GLenum = GLenum(0x874E)
  GL_OCCLUSION_QUERY_EVENT_MASK_AMD*: GLenum = GLenum(0x874F)
  GL_DEPTH_STENCIL_MESA*: GLenum = GLenum(0x8750)
  GL_UNSIGNED_INT_24_8_MESA*: GLenum = GLenum(0x8751)
  GL_UNSIGNED_INT_8_24_REV_MESA*: GLenum = GLenum(0x8752)
  GL_UNSIGNED_SHORT_15_1_MESA*: GLenum = GLenum(0x8753)
  GL_UNSIGNED_SHORT_1_15_REV_MESA*: GLenum = GLenum(0x8754)
  GL_TRACE_MASK_MESA*: GLenum = GLenum(0x8755)
  GL_TRACE_NAME_MESA*: GLenum = GLenum(0x8756)
  GL_YCBCR_MESA*: GLenum = GLenum(0x8757)
  GL_PACK_INVERT_MESA*: GLenum = GLenum(0x8758)
  GL_DEBUG_OBJECT_MESA*: GLenum = GLenum(0x8759) ## NOT an alias. Accidental reuse of GL_TEXTURE_1D_STACK_MESAX
  GL_TEXTURE_1D_STACK_MESAX*: GLenum = GLenum(0x8759)
  GL_DEBUG_PRINT_MESA*: GLenum = GLenum(0x875A) ## NOT an alias. Accidental reuse of GL_TEXTURE_2D_STACK_MESAX
  GL_TEXTURE_2D_STACK_MESAX*: GLenum = GLenum(0x875A)
  GL_DEBUG_ASSERT_MESA*: GLenum = GLenum(0x875B) ## NOT an alias. Accidental reuse of GL_PROXY_TEXTURE_1D_STACK_MESAX
  GL_PROXY_TEXTURE_1D_STACK_MESAX*: GLenum = GLenum(0x875B)
  GL_PROXY_TEXTURE_2D_STACK_MESAX*: GLenum = GLenum(0x875C)
  GL_TEXTURE_1D_STACK_BINDING_MESAX*: GLenum = GLenum(0x875D)
  GL_TEXTURE_2D_STACK_BINDING_MESAX*: GLenum = GLenum(0x875E)
  GL_PROGRAM_BINARY_FORMAT_MESA*: GLenum = GLenum(0x875F)
  GL_STATIC_ATI*: GLenum = GLenum(0x8760)
  GL_DYNAMIC_ATI*: GLenum = GLenum(0x8761)
  GL_PRESERVE_ATI*: GLenum = GLenum(0x8762)
  GL_DISCARD_ATI*: GLenum = GLenum(0x8763)
  GL_BUFFER_SIZE*: GLenum = GLenum(0x8764)
  GL_BUFFER_SIZE_ARB*: GLenum = GLenum(0x8764)
  GL_OBJECT_BUFFER_SIZE_ATI*: GLenum = GLenum(0x8764)
  GL_BUFFER_USAGE*: GLenum = GLenum(0x8765)
  GL_BUFFER_USAGE_ARB*: GLenum = GLenum(0x8765)
  GL_OBJECT_BUFFER_USAGE_ATI*: GLenum = GLenum(0x8765)
  GL_ARRAY_OBJECT_BUFFER_ATI*: GLenum = GLenum(0x8766)
  GL_ARRAY_OBJECT_OFFSET_ATI*: GLenum = GLenum(0x8767)
  GL_ELEMENT_ARRAY_ATI*: GLenum = GLenum(0x8768)
  GL_ELEMENT_ARRAY_TYPE_ATI*: GLenum = GLenum(0x8769)
  GL_ELEMENT_ARRAY_POINTER_ATI*: GLenum = GLenum(0x876A)
  GL_MAX_VERTEX_STREAMS_ATI*: GLenum = GLenum(0x876B)
  GL_VERTEX_STREAM0_ATI*: GLenum = GLenum(0x876C)
  GL_VERTEX_STREAM1_ATI*: GLenum = GLenum(0x876D)
  GL_VERTEX_STREAM2_ATI*: GLenum = GLenum(0x876E)
  GL_VERTEX_STREAM3_ATI*: GLenum = GLenum(0x876F)
  GL_VERTEX_STREAM4_ATI*: GLenum = GLenum(0x8770)
  GL_VERTEX_STREAM5_ATI*: GLenum = GLenum(0x8771)
  GL_VERTEX_STREAM6_ATI*: GLenum = GLenum(0x8772)
  GL_VERTEX_STREAM7_ATI*: GLenum = GLenum(0x8773)
  GL_VERTEX_SOURCE_ATI*: GLenum = GLenum(0x8774)
  GL_BUMP_ROT_MATRIX_ATI*: GLenum = GLenum(0x8775)
  GL_BUMP_ROT_MATRIX_SIZE_ATI*: GLenum = GLenum(0x8776)
  GL_BUMP_NUM_TEX_UNITS_ATI*: GLenum = GLenum(0x8777)
  GL_BUMP_TEX_UNITS_ATI*: GLenum = GLenum(0x8778)
  GL_DUDV_ATI*: GLenum = GLenum(0x8779)
  GL_DU8DV8_ATI*: GLenum = GLenum(0x877A)
  GL_BUMP_ENVMAP_ATI*: GLenum = GLenum(0x877B)
  GL_BUMP_TARGET_ATI*: GLenum = GLenum(0x877C)
  GL_VERTEX_SHADER_EXT*: GLenum = GLenum(0x8780)
  GL_VERTEX_SHADER_BINDING_EXT*: GLenum = GLenum(0x8781)
  GL_OP_INDEX_EXT*: GLenum = GLenum(0x8782)
  GL_OP_NEGATE_EXT*: GLenum = GLenum(0x8783)
  GL_OP_DOT3_EXT*: GLenum = GLenum(0x8784)
  GL_OP_DOT4_EXT*: GLenum = GLenum(0x8785)
  GL_OP_MUL_EXT*: GLenum = GLenum(0x8786)
  GL_OP_ADD_EXT*: GLenum = GLenum(0x8787)
  GL_OP_MADD_EXT*: GLenum = GLenum(0x8788)
  GL_OP_FRAC_EXT*: GLenum = GLenum(0x8789)
  GL_OP_MAX_EXT*: GLenum = GLenum(0x878A)
  GL_OP_MIN_EXT*: GLenum = GLenum(0x878B)
  GL_OP_SET_GE_EXT*: GLenum = GLenum(0x878C)
  GL_OP_SET_LT_EXT*: GLenum = GLenum(0x878D)
  GL_OP_CLAMP_EXT*: GLenum = GLenum(0x878E)
  GL_OP_FLOOR_EXT*: GLenum = GLenum(0x878F)
  GL_OP_ROUND_EXT*: GLenum = GLenum(0x8790)
  GL_OP_EXP_BASE_2_EXT*: GLenum = GLenum(0x8791)
  GL_OP_LOG_BASE_2_EXT*: GLenum = GLenum(0x8792)
  GL_OP_POWER_EXT*: GLenum = GLenum(0x8793)
  GL_OP_RECIP_EXT*: GLenum = GLenum(0x8794)
  GL_OP_RECIP_SQRT_EXT*: GLenum = GLenum(0x8795)
  GL_OP_SUB_EXT*: GLenum = GLenum(0x8796)
  GL_OP_CROSS_PRODUCT_EXT*: GLenum = GLenum(0x8797)
  GL_OP_MULTIPLY_MATRIX_EXT*: GLenum = GLenum(0x8798)
  GL_OP_MOV_EXT*: GLenum = GLenum(0x8799)
  GL_OUTPUT_VERTEX_EXT*: GLenum = GLenum(0x879A)
  GL_OUTPUT_COLOR0_EXT*: GLenum = GLenum(0x879B)
  GL_OUTPUT_COLOR1_EXT*: GLenum = GLenum(0x879C)
  GL_OUTPUT_TEXTURE_COORD0_EXT*: GLenum = GLenum(0x879D)
  GL_OUTPUT_TEXTURE_COORD1_EXT*: GLenum = GLenum(0x879E)
  GL_OUTPUT_TEXTURE_COORD2_EXT*: GLenum = GLenum(0x879F)
  GL_OUTPUT_TEXTURE_COORD3_EXT*: GLenum = GLenum(0x87A0)
  GL_OUTPUT_TEXTURE_COORD4_EXT*: GLenum = GLenum(0x87A1)
  GL_OUTPUT_TEXTURE_COORD5_EXT*: GLenum = GLenum(0x87A2)
  GL_OUTPUT_TEXTURE_COORD6_EXT*: GLenum = GLenum(0x87A3)
  GL_OUTPUT_TEXTURE_COORD7_EXT*: GLenum = GLenum(0x87A4)
  GL_OUTPUT_TEXTURE_COORD8_EXT*: GLenum = GLenum(0x87A5)
  GL_OUTPUT_TEXTURE_COORD9_EXT*: GLenum = GLenum(0x87A6)
  GL_OUTPUT_TEXTURE_COORD10_EXT*: GLenum = GLenum(0x87A7)
  GL_OUTPUT_TEXTURE_COORD11_EXT*: GLenum = GLenum(0x87A8)
  GL_OUTPUT_TEXTURE_COORD12_EXT*: GLenum = GLenum(0x87A9)
  GL_OUTPUT_TEXTURE_COORD13_EXT*: GLenum = GLenum(0x87AA)
  GL_OUTPUT_TEXTURE_COORD14_EXT*: GLenum = GLenum(0x87AB)
  GL_OUTPUT_TEXTURE_COORD15_EXT*: GLenum = GLenum(0x87AC)
  GL_OUTPUT_TEXTURE_COORD16_EXT*: GLenum = GLenum(0x87AD)
  GL_OUTPUT_TEXTURE_COORD17_EXT*: GLenum = GLenum(0x87AE)
  GL_OUTPUT_TEXTURE_COORD18_EXT*: GLenum = GLenum(0x87AF)
  GL_OUTPUT_TEXTURE_COORD19_EXT*: GLenum = GLenum(0x87B0)
  GL_OUTPUT_TEXTURE_COORD20_EXT*: GLenum = GLenum(0x87B1)
  GL_OUTPUT_TEXTURE_COORD21_EXT*: GLenum = GLenum(0x87B2)
  GL_OUTPUT_TEXTURE_COORD22_EXT*: GLenum = GLenum(0x87B3)
  GL_OUTPUT_TEXTURE_COORD23_EXT*: GLenum = GLenum(0x87B4)
  GL_OUTPUT_TEXTURE_COORD24_EXT*: GLenum = GLenum(0x87B5)
  GL_OUTPUT_TEXTURE_COORD25_EXT*: GLenum = GLenum(0x87B6)
  GL_OUTPUT_TEXTURE_COORD26_EXT*: GLenum = GLenum(0x87B7)
  GL_OUTPUT_TEXTURE_COORD27_EXT*: GLenum = GLenum(0x87B8)
  GL_OUTPUT_TEXTURE_COORD28_EXT*: GLenum = GLenum(0x87B9)
  GL_OUTPUT_TEXTURE_COORD29_EXT*: GLenum = GLenum(0x87BA)
  GL_OUTPUT_TEXTURE_COORD30_EXT*: GLenum = GLenum(0x87BB)
  GL_OUTPUT_TEXTURE_COORD31_EXT*: GLenum = GLenum(0x87BC)
  GL_OUTPUT_FOG_EXT*: GLenum = GLenum(0x87BD)
  GL_SCALAR_EXT*: GLenum = GLenum(0x87BE)
  GL_VECTOR_EXT*: GLenum = GLenum(0x87BF)
  GL_MATRIX_EXT*: GLenum = GLenum(0x87C0)
  GL_VARIANT_EXT*: GLenum = GLenum(0x87C1)
  GL_INVARIANT_EXT*: GLenum = GLenum(0x87C2)
  GL_LOCAL_CONSTANT_EXT*: GLenum = GLenum(0x87C3)
  GL_LOCAL_EXT*: GLenum = GLenum(0x87C4)
  GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT*: GLenum = GLenum(0x87C5)
  GL_MAX_VERTEX_SHADER_VARIANTS_EXT*: GLenum = GLenum(0x87C6)
  GL_MAX_VERTEX_SHADER_INVARIANTS_EXT*: GLenum = GLenum(0x87C7)
  GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT*: GLenum = GLenum(0x87C8)
  GL_MAX_VERTEX_SHADER_LOCALS_EXT*: GLenum = GLenum(0x87C9)
  GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT*: GLenum = GLenum(0x87CA)
  GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT*: GLenum = GLenum(0x87CB)
  GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT*: GLenum = GLenum(0x87CC)
  GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT*: GLenum = GLenum(0x87CD)
  GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT*: GLenum = GLenum(0x87CE)
  GL_VERTEX_SHADER_INSTRUCTIONS_EXT*: GLenum = GLenum(0x87CF)
  GL_VERTEX_SHADER_VARIANTS_EXT*: GLenum = GLenum(0x87D0)
  GL_VERTEX_SHADER_INVARIANTS_EXT*: GLenum = GLenum(0x87D1)
  GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT*: GLenum = GLenum(0x87D2)
  GL_VERTEX_SHADER_LOCALS_EXT*: GLenum = GLenum(0x87D3)
  GL_VERTEX_SHADER_OPTIMIZED_EXT*: GLenum = GLenum(0x87D4)
  GL_X_EXT*: GLenum = GLenum(0x87D5)
  GL_Y_EXT*: GLenum = GLenum(0x87D6)
  GL_Z_EXT*: GLenum = GLenum(0x87D7)
  GL_W_EXT*: GLenum = GLenum(0x87D8)
  GL_NEGATIVE_X_EXT*: GLenum = GLenum(0x87D9)
  GL_NEGATIVE_Y_EXT*: GLenum = GLenum(0x87DA)
  GL_NEGATIVE_Z_EXT*: GLenum = GLenum(0x87DB)
  GL_NEGATIVE_W_EXT*: GLenum = GLenum(0x87DC)
  GL_ZERO_EXT*: GLenum = GLenum(0x87DD)
  GL_ONE_EXT*: GLenum = GLenum(0x87DE)
  GL_NEGATIVE_ONE_EXT*: GLenum = GLenum(0x87DF)
  GL_NORMALIZED_RANGE_EXT*: GLenum = GLenum(0x87E0)
  GL_FULL_RANGE_EXT*: GLenum = GLenum(0x87E1)
  GL_CURRENT_VERTEX_EXT*: GLenum = GLenum(0x87E2)
  GL_MVP_MATRIX_EXT*: GLenum = GLenum(0x87E3)
  GL_VARIANT_VALUE_EXT*: GLenum = GLenum(0x87E4)
  GL_VARIANT_DATATYPE_EXT*: GLenum = GLenum(0x87E5)
  GL_VARIANT_ARRAY_STRIDE_EXT*: GLenum = GLenum(0x87E6)
  GL_VARIANT_ARRAY_TYPE_EXT*: GLenum = GLenum(0x87E7)
  GL_VARIANT_ARRAY_EXT*: GLenum = GLenum(0x87E8)
  GL_VARIANT_ARRAY_POINTER_EXT*: GLenum = GLenum(0x87E9)
  GL_INVARIANT_VALUE_EXT*: GLenum = GLenum(0x87EA)
  GL_INVARIANT_DATATYPE_EXT*: GLenum = GLenum(0x87EB)
  GL_LOCAL_CONSTANT_VALUE_EXT*: GLenum = GLenum(0x87EC)
  GL_LOCAL_CONSTANT_DATATYPE_EXT*: GLenum = GLenum(0x87ED)
  GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD*: GLenum = GLenum(0x87EE)
  GL_PN_TRIANGLES_ATI*: GLenum = GLenum(0x87F0)
  GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI*: GLenum = GLenum(0x87F1)
  GL_PN_TRIANGLES_POINT_MODE_ATI*: GLenum = GLenum(0x87F2)
  GL_PN_TRIANGLES_NORMAL_MODE_ATI*: GLenum = GLenum(0x87F3)
  GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI*: GLenum = GLenum(0x87F4)
  GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI*: GLenum = GLenum(0x87F5)
  GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI*: GLenum = GLenum(0x87F6)
  GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI*: GLenum = GLenum(0x87F7)
  GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI*: GLenum = GLenum(0x87F8)
  GL_3DC_X_AMD*: GLenum = GLenum(0x87F9)
  GL_3DC_XY_AMD*: GLenum = GLenum(0x87FA)
  GL_VBO_FREE_MEMORY_ATI*: GLenum = GLenum(0x87FB)
  GL_TEXTURE_FREE_MEMORY_ATI*: GLenum = GLenum(0x87FC)
  GL_RENDERBUFFER_FREE_MEMORY_ATI*: GLenum = GLenum(0x87FD)
  GL_NUM_PROGRAM_BINARY_FORMATS*: GLenum = GLenum(0x87FE)
  GL_NUM_PROGRAM_BINARY_FORMATS_OES*: GLenum = GLenum(0x87FE)
  GL_PROGRAM_BINARY_FORMATS*: GLenum = GLenum(0x87FF)
  GL_PROGRAM_BINARY_FORMATS_OES*: GLenum = GLenum(0x87FF)
  GL_STENCIL_BACK_FUNC*: GLenum = GLenum(0x8800)
  GL_STENCIL_BACK_FUNC_ATI*: GLenum = GLenum(0x8800)
  GL_STENCIL_BACK_FAIL*: GLenum = GLenum(0x8801)
  GL_STENCIL_BACK_FAIL_ATI*: GLenum = GLenum(0x8801)
  GL_STENCIL_BACK_PASS_DEPTH_FAIL*: GLenum = GLenum(0x8802)
  GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI*: GLenum = GLenum(0x8802)
  GL_STENCIL_BACK_PASS_DEPTH_PASS*: GLenum = GLenum(0x8803)
  GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI*: GLenum = GLenum(0x8803)
  GL_FRAGMENT_PROGRAM_ARB*: GLenum = GLenum(0x8804)
  GL_PROGRAM_ALU_INSTRUCTIONS_ARB*: GLenum = GLenum(0x8805)
  GL_PROGRAM_TEX_INSTRUCTIONS_ARB*: GLenum = GLenum(0x8806)
  GL_PROGRAM_TEX_INDIRECTIONS_ARB*: GLenum = GLenum(0x8807)
  GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB*: GLenum = GLenum(0x8808)
  GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB*: GLenum = GLenum(0x8809)
  GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB*: GLenum = GLenum(0x880A)
  GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB*: GLenum = GLenum(0x880B)
  GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB*: GLenum = GLenum(0x880C)
  GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB*: GLenum = GLenum(0x880D)
  GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB*: GLenum = GLenum(0x880E)
  GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB*: GLenum = GLenum(0x880F)
  GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB*: GLenum = GLenum(0x8810)
  GL_RGBA32F*: GLenum = GLenum(0x8814)
  GL_RGBA32F_ARB*: GLenum = GLenum(0x8814)
  GL_RGBA32F_EXT*: GLenum = GLenum(0x8814)
  GL_RGBA_FLOAT32_APPLE*: GLenum = GLenum(0x8814)
  GL_RGBA_FLOAT32_ATI*: GLenum = GLenum(0x8814)
  GL_RGB32F*: GLenum = GLenum(0x8815)
  GL_RGB32F_ARB*: GLenum = GLenum(0x8815)
  GL_RGB32F_EXT*: GLenum = GLenum(0x8815)
  GL_RGB_FLOAT32_APPLE*: GLenum = GLenum(0x8815)
  GL_RGB_FLOAT32_ATI*: GLenum = GLenum(0x8815)
  GL_ALPHA32F_ARB*: GLenum = GLenum(0x8816)
  GL_ALPHA32F_EXT*: GLenum = GLenum(0x8816)
  GL_ALPHA_FLOAT32_APPLE*: GLenum = GLenum(0x8816)
  GL_ALPHA_FLOAT32_ATI*: GLenum = GLenum(0x8816)
  GL_INTENSITY32F_ARB*: GLenum = GLenum(0x8817)
  GL_INTENSITY_FLOAT32_APPLE*: GLenum = GLenum(0x8817)
  GL_INTENSITY_FLOAT32_ATI*: GLenum = GLenum(0x8817)
  GL_LUMINANCE32F_ARB*: GLenum = GLenum(0x8818)
  GL_LUMINANCE32F_EXT*: GLenum = GLenum(0x8818)
  GL_LUMINANCE_FLOAT32_APPLE*: GLenum = GLenum(0x8818)
  GL_LUMINANCE_FLOAT32_ATI*: GLenum = GLenum(0x8818)
  GL_LUMINANCE_ALPHA32F_ARB*: GLenum = GLenum(0x8819)
  GL_LUMINANCE_ALPHA32F_EXT*: GLenum = GLenum(0x8819)
  GL_LUMINANCE_ALPHA_FLOAT32_APPLE*: GLenum = GLenum(0x8819)
  GL_LUMINANCE_ALPHA_FLOAT32_ATI*: GLenum = GLenum(0x8819)
  GL_RGBA16F*: GLenum = GLenum(0x881A)
  GL_RGBA16F_ARB*: GLenum = GLenum(0x881A)
  GL_RGBA16F_EXT*: GLenum = GLenum(0x881A)
  GL_RGBA_FLOAT16_APPLE*: GLenum = GLenum(0x881A)
  GL_RGBA_FLOAT16_ATI*: GLenum = GLenum(0x881A)
  GL_RGB16F*: GLenum = GLenum(0x881B)
  GL_RGB16F_ARB*: GLenum = GLenum(0x881B)
  GL_RGB16F_EXT*: GLenum = GLenum(0x881B)
  GL_RGB_FLOAT16_APPLE*: GLenum = GLenum(0x881B)
  GL_RGB_FLOAT16_ATI*: GLenum = GLenum(0x881B)
  GL_ALPHA16F_ARB*: GLenum = GLenum(0x881C)
  GL_ALPHA16F_EXT*: GLenum = GLenum(0x881C)
  GL_ALPHA_FLOAT16_APPLE*: GLenum = GLenum(0x881C)
  GL_ALPHA_FLOAT16_ATI*: GLenum = GLenum(0x881C)
  GL_INTENSITY16F_ARB*: GLenum = GLenum(0x881D)
  GL_INTENSITY_FLOAT16_APPLE*: GLenum = GLenum(0x881D)
  GL_INTENSITY_FLOAT16_ATI*: GLenum = GLenum(0x881D)
  GL_LUMINANCE16F_ARB*: GLenum = GLenum(0x881E)
  GL_LUMINANCE16F_EXT*: GLenum = GLenum(0x881E)
  GL_LUMINANCE_FLOAT16_APPLE*: GLenum = GLenum(0x881E)
  GL_LUMINANCE_FLOAT16_ATI*: GLenum = GLenum(0x881E)
  GL_LUMINANCE_ALPHA16F_ARB*: GLenum = GLenum(0x881F)
  GL_LUMINANCE_ALPHA16F_EXT*: GLenum = GLenum(0x881F)
  GL_LUMINANCE_ALPHA_FLOAT16_APPLE*: GLenum = GLenum(0x881F)
  GL_LUMINANCE_ALPHA_FLOAT16_ATI*: GLenum = GLenum(0x881F)
  GL_RGBA_FLOAT_MODE_ARB*: GLenum = GLenum(0x8820)
  GL_RGBA_FLOAT_MODE_ATI*: GLenum = GLenum(0x8820)
  GL_WRITEONLY_RENDERING_QCOM*: GLenum = GLenum(0x8823)
  GL_MAX_DRAW_BUFFERS*: GLenum = GLenum(0x8824)
  GL_MAX_DRAW_BUFFERS_ARB*: GLenum = GLenum(0x8824)
  GL_MAX_DRAW_BUFFERS_ATI*: GLenum = GLenum(0x8824)
  GL_MAX_DRAW_BUFFERS_EXT*: GLenum = GLenum(0x8824)
  GL_MAX_DRAW_BUFFERS_NV*: GLenum = GLenum(0x8824)
  GL_DRAW_BUFFER0*: GLenum = GLenum(0x8825)
  GL_DRAW_BUFFER0_ARB*: GLenum = GLenum(0x8825)
  GL_DRAW_BUFFER0_ATI*: GLenum = GLenum(0x8825)
  GL_DRAW_BUFFER0_EXT*: GLenum = GLenum(0x8825)
  GL_DRAW_BUFFER0_NV*: GLenum = GLenum(0x8825)
  GL_DRAW_BUFFER1*: GLenum = GLenum(0x8826)
  GL_DRAW_BUFFER1_ARB*: GLenum = GLenum(0x8826)
  GL_DRAW_BUFFER1_ATI*: GLenum = GLenum(0x8826)
  GL_DRAW_BUFFER1_EXT*: GLenum = GLenum(0x8826)
  GL_DRAW_BUFFER1_NV*: GLenum = GLenum(0x8826)
  GL_DRAW_BUFFER2*: GLenum = GLenum(0x8827)
  GL_DRAW_BUFFER2_ARB*: GLenum = GLenum(0x8827)
  GL_DRAW_BUFFER2_ATI*: GLenum = GLenum(0x8827)
  GL_DRAW_BUFFER2_EXT*: GLenum = GLenum(0x8827)
  GL_DRAW_BUFFER2_NV*: GLenum = GLenum(0x8827)
  GL_DRAW_BUFFER3*: GLenum = GLenum(0x8828)
  GL_DRAW_BUFFER3_ARB*: GLenum = GLenum(0x8828)
  GL_DRAW_BUFFER3_ATI*: GLenum = GLenum(0x8828)
  GL_DRAW_BUFFER3_EXT*: GLenum = GLenum(0x8828)
  GL_DRAW_BUFFER3_NV*: GLenum = GLenum(0x8828)
  GL_DRAW_BUFFER4*: GLenum = GLenum(0x8829)
  GL_DRAW_BUFFER4_ARB*: GLenum = GLenum(0x8829)
  GL_DRAW_BUFFER4_ATI*: GLenum = GLenum(0x8829)
  GL_DRAW_BUFFER4_EXT*: GLenum = GLenum(0x8829)
  GL_DRAW_BUFFER4_NV*: GLenum = GLenum(0x8829)
  GL_DRAW_BUFFER5*: GLenum = GLenum(0x882A)
  GL_DRAW_BUFFER5_ARB*: GLenum = GLenum(0x882A)
  GL_DRAW_BUFFER5_ATI*: GLenum = GLenum(0x882A)
  GL_DRAW_BUFFER5_EXT*: GLenum = GLenum(0x882A)
  GL_DRAW_BUFFER5_NV*: GLenum = GLenum(0x882A)
  GL_DRAW_BUFFER6*: GLenum = GLenum(0x882B)
  GL_DRAW_BUFFER6_ARB*: GLenum = GLenum(0x882B)
  GL_DRAW_BUFFER6_ATI*: GLenum = GLenum(0x882B)
  GL_DRAW_BUFFER6_EXT*: GLenum = GLenum(0x882B)
  GL_DRAW_BUFFER6_NV*: GLenum = GLenum(0x882B)
  GL_DRAW_BUFFER7*: GLenum = GLenum(0x882C)
  GL_DRAW_BUFFER7_ARB*: GLenum = GLenum(0x882C)
  GL_DRAW_BUFFER7_ATI*: GLenum = GLenum(0x882C)
  GL_DRAW_BUFFER7_EXT*: GLenum = GLenum(0x882C)
  GL_DRAW_BUFFER7_NV*: GLenum = GLenum(0x882C)
  GL_DRAW_BUFFER8*: GLenum = GLenum(0x882D)
  GL_DRAW_BUFFER8_ARB*: GLenum = GLenum(0x882D)
  GL_DRAW_BUFFER8_ATI*: GLenum = GLenum(0x882D)
  GL_DRAW_BUFFER8_EXT*: GLenum = GLenum(0x882D)
  GL_DRAW_BUFFER8_NV*: GLenum = GLenum(0x882D)
  GL_DRAW_BUFFER9*: GLenum = GLenum(0x882E)
  GL_DRAW_BUFFER9_ARB*: GLenum = GLenum(0x882E)
  GL_DRAW_BUFFER9_ATI*: GLenum = GLenum(0x882E)
  GL_DRAW_BUFFER9_EXT*: GLenum = GLenum(0x882E)
  GL_DRAW_BUFFER9_NV*: GLenum = GLenum(0x882E)
  GL_DRAW_BUFFER10*: GLenum = GLenum(0x882F)
  GL_DRAW_BUFFER10_ARB*: GLenum = GLenum(0x882F)
  GL_DRAW_BUFFER10_ATI*: GLenum = GLenum(0x882F)
  GL_DRAW_BUFFER10_EXT*: GLenum = GLenum(0x882F)
  GL_DRAW_BUFFER10_NV*: GLenum = GLenum(0x882F)
  GL_DRAW_BUFFER11*: GLenum = GLenum(0x8830)
  GL_DRAW_BUFFER11_ARB*: GLenum = GLenum(0x8830)
  GL_DRAW_BUFFER11_ATI*: GLenum = GLenum(0x8830)
  GL_DRAW_BUFFER11_EXT*: GLenum = GLenum(0x8830)
  GL_DRAW_BUFFER11_NV*: GLenum = GLenum(0x8830)
  GL_DRAW_BUFFER12*: GLenum = GLenum(0x8831)
  GL_DRAW_BUFFER12_ARB*: GLenum = GLenum(0x8831)
  GL_DRAW_BUFFER12_ATI*: GLenum = GLenum(0x8831)
  GL_DRAW_BUFFER12_EXT*: GLenum = GLenum(0x8831)
  GL_DRAW_BUFFER12_NV*: GLenum = GLenum(0x8831)
  GL_DRAW_BUFFER13*: GLenum = GLenum(0x8832)
  GL_DRAW_BUFFER13_ARB*: GLenum = GLenum(0x8832)
  GL_DRAW_BUFFER13_ATI*: GLenum = GLenum(0x8832)
  GL_DRAW_BUFFER13_EXT*: GLenum = GLenum(0x8832)
  GL_DRAW_BUFFER13_NV*: GLenum = GLenum(0x8832)
  GL_DRAW_BUFFER14*: GLenum = GLenum(0x8833)
  GL_DRAW_BUFFER14_ARB*: GLenum = GLenum(0x8833)
  GL_DRAW_BUFFER14_ATI*: GLenum = GLenum(0x8833)
  GL_DRAW_BUFFER14_EXT*: GLenum = GLenum(0x8833)
  GL_DRAW_BUFFER14_NV*: GLenum = GLenum(0x8833)
  GL_DRAW_BUFFER15*: GLenum = GLenum(0x8834)
  GL_DRAW_BUFFER15_ARB*: GLenum = GLenum(0x8834)
  GL_DRAW_BUFFER15_ATI*: GLenum = GLenum(0x8834)
  GL_DRAW_BUFFER15_EXT*: GLenum = GLenum(0x8834)
  GL_DRAW_BUFFER15_NV*: GLenum = GLenum(0x8834)
  GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI*: GLenum = GLenum(0x8835)
  GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI*: GLenum = GLenum(0x8837) ## Defined by Mesa but not ATI
  GL_BLEND_EQUATION_ALPHA*: GLenum = GLenum(0x883D)
  GL_BLEND_EQUATION_ALPHA_EXT*: GLenum = GLenum(0x883D)
  GL_BLEND_EQUATION_ALPHA_OES*: GLenum = GLenum(0x883D)
  GL_SUBSAMPLE_DISTANCE_AMD*: GLenum = GLenum(0x883F)
  GL_MATRIX_PALETTE_ARB*: GLenum = GLenum(0x8840)
  GL_MATRIX_PALETTE_OES*: GLenum = GLenum(0x8840)
  GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB*: GLenum = GLenum(0x8841)
  GL_MAX_PALETTE_MATRICES_ARB*: GLenum = GLenum(0x8842)
  GL_MAX_PALETTE_MATRICES_OES*: GLenum = GLenum(0x8842)
  GL_CURRENT_PALETTE_MATRIX_ARB*: GLenum = GLenum(0x8843)
  GL_CURRENT_PALETTE_MATRIX_OES*: GLenum = GLenum(0x8843)
  GL_MATRIX_INDEX_ARRAY_ARB*: GLenum = GLenum(0x8844)
  GL_MATRIX_INDEX_ARRAY_OES*: GLenum = GLenum(0x8844)
  GL_CURRENT_MATRIX_INDEX_ARB*: GLenum = GLenum(0x8845)
  GL_MATRIX_INDEX_ARRAY_SIZE_ARB*: GLenum = GLenum(0x8846)
  GL_MATRIX_INDEX_ARRAY_SIZE_OES*: GLenum = GLenum(0x8846)
  GL_MATRIX_INDEX_ARRAY_TYPE_ARB*: GLenum = GLenum(0x8847)
  GL_MATRIX_INDEX_ARRAY_TYPE_OES*: GLenum = GLenum(0x8847)
  GL_MATRIX_INDEX_ARRAY_STRIDE_ARB*: GLenum = GLenum(0x8848)
  GL_MATRIX_INDEX_ARRAY_STRIDE_OES*: GLenum = GLenum(0x8848)
  GL_MATRIX_INDEX_ARRAY_POINTER_ARB*: GLenum = GLenum(0x8849)
  GL_MATRIX_INDEX_ARRAY_POINTER_OES*: GLenum = GLenum(0x8849)
  GL_TEXTURE_DEPTH_SIZE*: GLenum = GLenum(0x884A)
  GL_TEXTURE_DEPTH_SIZE_ARB*: GLenum = GLenum(0x884A)
  GL_ATOMIC_COUNTER_BUFFER_INDEX*: GLenum = GLenum(0x9301)
  GL_DEPTH_TEXTURE_MODE_ARB*: GLenum = GLenum(0x884B)
  GL_TEXTURE_COMPARE_MODE*: GLenum = GLenum(0x884C)
  GL_TEXTURE_COMPARE_MODE_ARB*: GLenum = GLenum(0x884C)
  GL_TEXTURE_COMPARE_MODE_EXT*: GLenum = GLenum(0x884C)
  GL_TEXTURE_COMPARE_FUNC*: GLenum = GLenum(0x884D)
  GL_TEXTURE_COMPARE_FUNC_ARB*: GLenum = GLenum(0x884D)
  GL_TEXTURE_COMPARE_FUNC_EXT*: GLenum = GLenum(0x884D)
  GL_IS_ROW_MAJOR*: GLenum = GLenum(0x9300)
  GL_COMPARE_R_TO_TEXTURE_ARB*: GLenum = GLenum(0x884E)
  GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT*: GLenum = GLenum(0x884E)
  GL_COMPARE_REF_TO_TEXTURE*: GLenum = GLenum(0x884E)
  GL_COMPARE_REF_TO_TEXTURE_EXT*: GLenum = GLenum(0x884E)
  GL_TEXTURE_CUBE_MAP_SEAMLESS*: GLenum = GLenum(0x884F)
  GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV*: GLenum = GLenum(0x8850)
  GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV*: GLenum = GLenum(0x8851)
  GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV*: GLenum = GLenum(0x8852)
  GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV*: GLenum = GLenum(0x8853)
  GL_OFFSET_HILO_TEXTURE_2D_NV*: GLenum = GLenum(0x8854)
  GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV*: GLenum = GLenum(0x8855)
  GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV*: GLenum = GLenum(0x8856)
  GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV*: GLenum = GLenum(0x8857)
  GL_DEPENDENT_HILO_TEXTURE_2D_NV*: GLenum = GLenum(0x8858)
  GL_DEPENDENT_RGB_TEXTURE_3D_NV*: GLenum = GLenum(0x8859)
  GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV*: GLenum = GLenum(0x885A)
  GL_DOT_PRODUCT_PASS_THROUGH_NV*: GLenum = GLenum(0x885B)
  GL_DOT_PRODUCT_TEXTURE_1D_NV*: GLenum = GLenum(0x885C)
  GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV*: GLenum = GLenum(0x885D)
  GL_HILO8_NV*: GLenum = GLenum(0x885E)
  GL_SIGNED_HILO8_NV*: GLenum = GLenum(0x885F)
  GL_FORCE_BLUE_TO_ONE_NV*: GLenum = GLenum(0x8860)
  GL_VERTEX_SUBROUTINE*: GLenum = GLenum(0x92E8)
  GL_POINT_SPRITE_ARB*: GLenum = GLenum(0x8861)
  GL_POINT_SPRITE_NV*: GLenum = GLenum(0x8861)
  GL_POINT_SPRITE_OES*: GLenum = GLenum(0x8861)
  GL_IS_PER_PATCH_OES*: GLenum = GLenum(0x92E7)
  GL_COORD_REPLACE_ARB*: GLenum = GLenum(0x8862)
  GL_COORD_REPLACE_NV*: GLenum = GLenum(0x8862)
  GL_COORD_REPLACE_OES*: GLenum = GLenum(0x8862)
  GL_POINT_SPRITE_R_MODE_NV*: GLenum = GLenum(0x8863)
  GL_PIXEL_COUNTER_BITS_NV*: GLenum = GLenum(0x8864)
  GL_QUERY_COUNTER_BITS*: GLenum = GLenum(0x8864)
  GL_QUERY_COUNTER_BITS_ARB*: GLenum = GLenum(0x8864)
  GL_QUERY_COUNTER_BITS_EXT*: GLenum = GLenum(0x8864)
  GL_CURRENT_OCCLUSION_QUERY_ID_NV*: GLenum = GLenum(0x8865)
  GL_CURRENT_QUERY*: GLenum = GLenum(0x8865)
  GL_CURRENT_QUERY_ARB*: GLenum = GLenum(0x8865)
  GL_CURRENT_QUERY_EXT*: GLenum = GLenum(0x8865)
  GL_PIXEL_COUNT_NV*: GLenum = GLenum(0x8866)
  GL_QUERY_RESULT*: GLenum = GLenum(0x8866)
  GL_QUERY_RESULT_ARB*: GLenum = GLenum(0x8866)
  GL_QUERY_RESULT_EXT*: GLenum = GLenum(0x8866)
  GL_PIXEL_COUNT_AVAILABLE_NV*: GLenum = GLenum(0x8867)
  GL_QUERY_RESULT_AVAILABLE*: GLenum = GLenum(0x8867)
  GL_QUERY_RESULT_AVAILABLE_ARB*: GLenum = GLenum(0x8867)
  GL_QUERY_RESULT_AVAILABLE_EXT*: GLenum = GLenum(0x8867)
  GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV*: GLenum = GLenum(0x8868)
  GL_MAX_VERTEX_ATTRIBS*: GLenum = GLenum(0x8869)
  GL_MAX_VERTEX_ATTRIBS_ARB*: GLenum = GLenum(0x8869)
  GL_VERTEX_ATTRIB_ARRAY_NORMALIZED*: GLenum = GLenum(0x886A)
  GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB*: GLenum = GLenum(0x886A)
  GL_MAX_TESS_CONTROL_INPUT_COMPONENTS*: GLenum = GLenum(0x886C)
  GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_EXT*: GLenum = GLenum(0x886C)
  GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_OES*: GLenum = GLenum(0x886C)
  GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS*: GLenum = GLenum(0x886D)
  GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_EXT*: GLenum = GLenum(0x886D)
  GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_OES*: GLenum = GLenum(0x886D)
  GL_DEPTH_STENCIL_TO_RGBA_NV*: GLenum = GLenum(0x886E)
  GL_DEPTH_STENCIL_TO_BGRA_NV*: GLenum = GLenum(0x886F)
  GL_FRAGMENT_PROGRAM_NV*: GLenum = GLenum(0x8870)
  GL_IS_PER_PATCH_EXT*: GLenum = GLenum(0x92E7)
  GL_MAX_TEXTURE_COORDS_ARB*: GLenum = GLenum(0x8871)
  GL_MAX_TEXTURE_COORDS_NV*: GLenum = GLenum(0x8871)
  GL_MAX_TEXTURE_IMAGE_UNITS*: GLenum = GLenum(0x8872)
  GL_MAX_TEXTURE_IMAGE_UNITS_ARB*: GLenum = GLenum(0x8872)
  GL_MAX_TEXTURE_IMAGE_UNITS_NV*: GLenum = GLenum(0x8872)
  GL_FRAGMENT_PROGRAM_BINDING_NV*: GLenum = GLenum(0x8873)
  GL_PROGRAM_ERROR_STRING_ARB*: GLenum = GLenum(0x8874)
  GL_PROGRAM_ERROR_STRING_NV*: GLenum = GLenum(0x8874)
  GL_PROGRAM_FORMAT_ASCII_ARB*: GLenum = GLenum(0x8875)
  GL_PROGRAM_FORMAT_ARB*: GLenum = GLenum(0x8876)
  GL_WRITE_PIXEL_DATA_RANGE_NV*: GLenum = GLenum(0x8878)
  GL_READ_PIXEL_DATA_RANGE_NV*: GLenum = GLenum(0x8879)
  GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV*: GLenum = GLenum(0x887A)
  GL_READ_PIXEL_DATA_RANGE_LENGTH_NV*: GLenum = GLenum(0x887B)
  GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV*: GLenum = GLenum(0x887C)
  GL_READ_PIXEL_DATA_RANGE_POINTER_NV*: GLenum = GLenum(0x887D)
  GL_GEOMETRY_SHADER_INVOCATIONS*: GLenum = GLenum(0x887F)
  GL_GEOMETRY_SHADER_INVOCATIONS_EXT*: GLenum = GLenum(0x887F)
  GL_GEOMETRY_SHADER_INVOCATIONS_OES*: GLenum = GLenum(0x887F)
  GL_FLOAT_R_NV*: GLenum = GLenum(0x8880)
  GL_FLOAT_RG_NV*: GLenum = GLenum(0x8881)
  GL_FLOAT_RGB_NV*: GLenum = GLenum(0x8882)
  GL_FLOAT_RGBA_NV*: GLenum = GLenum(0x8883)
  GL_FLOAT_R16_NV*: GLenum = GLenum(0x8884)
  GL_FLOAT_R32_NV*: GLenum = GLenum(0x8885)
  GL_FLOAT_RG16_NV*: GLenum = GLenum(0x8886)
  GL_FLOAT_RG32_NV*: GLenum = GLenum(0x8887)
  GL_FLOAT_RGB16_NV*: GLenum = GLenum(0x8888)
  GL_FLOAT_RGB32_NV*: GLenum = GLenum(0x8889)
  GL_FLOAT_RGBA16_NV*: GLenum = GLenum(0x888A)
  GL_FLOAT_RGBA32_NV*: GLenum = GLenum(0x888B)
  GL_TEXTURE_FLOAT_COMPONENTS_NV*: GLenum = GLenum(0x888C)
  GL_FLOAT_CLEAR_COLOR_VALUE_NV*: GLenum = GLenum(0x888D)
  GL_FLOAT_RGBA_MODE_NV*: GLenum = GLenum(0x888E)
  GL_TEXTURE_UNSIGNED_REMAP_MODE_NV*: GLenum = GLenum(0x888F)
  GL_DEPTH_BOUNDS_TEST_EXT*: GLenum = GLenum(0x8890)
  GL_DEPTH_BOUNDS_EXT*: GLenum = GLenum(0x8891)
  GL_ARRAY_BUFFER*: GLenum = GLenum(0x8892)
  GL_ARRAY_BUFFER_ARB*: GLenum = GLenum(0x8892)
  GL_ELEMENT_ARRAY_BUFFER*: GLenum = GLenum(0x8893)
  GL_ELEMENT_ARRAY_BUFFER_ARB*: GLenum = GLenum(0x8893)
  GL_ARRAY_BUFFER_BINDING*: GLenum = GLenum(0x8894)
  GL_ARRAY_BUFFER_BINDING_ARB*: GLenum = GLenum(0x8894)
  GL_ELEMENT_ARRAY_BUFFER_BINDING*: GLenum = GLenum(0x8895)
  GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB*: GLenum = GLenum(0x8895)
  GL_MATRIX_STRIDE*: GLenum = GLenum(0x92FF)
  GL_VERTEX_ARRAY_BUFFER_BINDING_ARB*: GLenum = GLenum(0x8896)
  GL_ARRAY_STRIDE*: GLenum = GLenum(0x92FE)
  GL_NORMAL_ARRAY_BUFFER_BINDING_ARB*: GLenum = GLenum(0x8897)
  GL_BLOCK_INDEX*: GLenum = GLenum(0x92FD)
  GL_COLOR_ARRAY_BUFFER_BINDING_ARB*: GLenum = GLenum(0x8898)
  GL_OFFSET*: GLenum = GLenum(0x92FC)
  GL_INDEX_ARRAY_BUFFER_BINDING_ARB*: GLenum = GLenum(0x8899)
  GL_ARRAY_SIZE*: GLenum = GLenum(0x92FB)
  GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB*: GLenum = GLenum(0x889A)
  GL_TYPE*: GLenum = GLenum(0x92FA)
  GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB*: GLenum = GLenum(0x889B)
  GL_NAME_LENGTH*: GLenum = GLenum(0x92F9)
  GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB*: GLenum = GLenum(0x889C)
  GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB*: GLenum = GLenum(0x889D)
  GL_MAX_NUM_COMPATIBLE_SUBROUTINES*: GLenum = GLenum(0x92F8)
  GL_TESS_CONTROL_SUBROUTINE_UNIFORM*: GLenum = GLenum(0x92EF)
  GL_MAX_NUM_ACTIVE_VARIABLES*: GLenum = GLenum(0x92F7)
  GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB*: GLenum = GLenum(0x889E)
  GL_WEIGHT_ARRAY_BUFFER_BINDING_OES*: GLenum = GLenum(0x889E)
  GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING*: GLenum = GLenum(0x889F)
  GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB*: GLenum = GLenum(0x889F)
  GL_PROGRAM_INSTRUCTIONS_ARB*: GLenum = GLenum(0x88A0)
  GL_MAX_PROGRAM_INSTRUCTIONS_ARB*: GLenum = GLenum(0x88A1)
  GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB*: GLenum = GLenum(0x88A2)
  GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB*: GLenum = GLenum(0x88A3)
  GL_PROGRAM_TEMPORARIES_ARB*: GLenum = GLenum(0x88A4)
  GL_MAX_PROGRAM_TEMPORARIES_ARB*: GLenum = GLenum(0x88A5)
  GL_PROGRAM_NATIVE_TEMPORARIES_ARB*: GLenum = GLenum(0x88A6)
  GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB*: GLenum = GLenum(0x88A7)
  GL_PROGRAM_PARAMETERS_ARB*: GLenum = GLenum(0x88A8)
  GL_MAX_PROGRAM_PARAMETERS_ARB*: GLenum = GLenum(0x88A9)
  GL_PROGRAM_NATIVE_PARAMETERS_ARB*: GLenum = GLenum(0x88AA)
  GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB*: GLenum = GLenum(0x88AB)
  GL_PROGRAM_ATTRIBS_ARB*: GLenum = GLenum(0x88AC)
  GL_MAX_PROGRAM_ATTRIBS_ARB*: GLenum = GLenum(0x88AD)
  GL_PROGRAM_NATIVE_ATTRIBS_ARB*: GLenum = GLenum(0x88AE)
  GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB*: GLenum = GLenum(0x88AF)
  GL_PROGRAM_ADDRESS_REGISTERS_ARB*: GLenum = GLenum(0x88B0)
  GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB*: GLenum = GLenum(0x88B1)
  GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB*: GLenum = GLenum(0x88B2)
  GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB*: GLenum = GLenum(0x88B3)
  GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB*: GLenum = GLenum(0x88B4)
  GL_MAX_PROGRAM_ENV_PARAMETERS_ARB*: GLenum = GLenum(0x88B5)
  GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB*: GLenum = GLenum(0x88B6)
  GL_TRANSPOSE_CURRENT_MATRIX_ARB*: GLenum = GLenum(0x88B7)
  GL_READ_ONLY*: GLenum = GLenum(0x88B8)
  GL_READ_ONLY_ARB*: GLenum = GLenum(0x88B8)
  GL_WRITE_ONLY*: GLenum = GLenum(0x88B9)
  GL_WRITE_ONLY_ARB*: GLenum = GLenum(0x88B9)
  GL_WRITE_ONLY_OES*: GLenum = GLenum(0x88B9)
  GL_READ_WRITE*: GLenum = GLenum(0x88BA)
  GL_READ_WRITE_ARB*: GLenum = GLenum(0x88BA)
  GL_BUFFER_ACCESS*: GLenum = GLenum(0x88BB)
  GL_BUFFER_ACCESS_ARB*: GLenum = GLenum(0x88BB)
  GL_BUFFER_ACCESS_OES*: GLenum = GLenum(0x88BB)
  GL_BUFFER_MAPPED*: GLenum = GLenum(0x88BC)
  GL_BUFFER_MAPPED_ARB*: GLenum = GLenum(0x88BC)
  GL_BUFFER_MAPPED_OES*: GLenum = GLenum(0x88BC)
  GL_BUFFER_MAP_POINTER*: GLenum = GLenum(0x88BD)
  GL_BUFFER_MAP_POINTER_ARB*: GLenum = GLenum(0x88BD)
  GL_BUFFER_MAP_POINTER_OES*: GLenum = GLenum(0x88BD)
  GL_WRITE_DISCARD_NV*: GLenum = GLenum(0x88BE)
  GL_TIME_ELAPSED*: GLenum = GLenum(0x88BF)
  GL_TIME_ELAPSED_EXT*: GLenum = GLenum(0x88BF)
  GL_MATRIX0_ARB*: GLenum = GLenum(0x88C0)
  GL_MATRIX1_ARB*: GLenum = GLenum(0x88C1)
  GL_MATRIX2_ARB*: GLenum = GLenum(0x88C2)
  GL_MATRIX3_ARB*: GLenum = GLenum(0x88C3)
  GL_MATRIX4_ARB*: GLenum = GLenum(0x88C4)
  GL_MATRIX5_ARB*: GLenum = GLenum(0x88C5)
  GL_MATRIX6_ARB*: GLenum = GLenum(0x88C6)
  GL_MATRIX7_ARB*: GLenum = GLenum(0x88C7)
  GL_MATRIX8_ARB*: GLenum = GLenum(0x88C8)
  GL_MATRIX9_ARB*: GLenum = GLenum(0x88C9)
  GL_MATRIX10_ARB*: GLenum = GLenum(0x88CA)
  GL_MATRIX11_ARB*: GLenum = GLenum(0x88CB)
  GL_MATRIX12_ARB*: GLenum = GLenum(0x88CC)
  GL_MATRIX13_ARB*: GLenum = GLenum(0x88CD)
  GL_MATRIX14_ARB*: GLenum = GLenum(0x88CE)
  GL_MATRIX15_ARB*: GLenum = GLenum(0x88CF)
  GL_MATRIX16_ARB*: GLenum = GLenum(0x88D0)
  GL_MATRIX17_ARB*: GLenum = GLenum(0x88D1)
  GL_MATRIX18_ARB*: GLenum = GLenum(0x88D2)
  GL_MATRIX19_ARB*: GLenum = GLenum(0x88D3)
  GL_MATRIX20_ARB*: GLenum = GLenum(0x88D4)
  GL_MATRIX21_ARB*: GLenum = GLenum(0x88D5)
  GL_MATRIX22_ARB*: GLenum = GLenum(0x88D6)
  GL_MATRIX23_ARB*: GLenum = GLenum(0x88D7)
  GL_MATRIX24_ARB*: GLenum = GLenum(0x88D8)
  GL_MATRIX25_ARB*: GLenum = GLenum(0x88D9)
  GL_MATRIX26_ARB*: GLenum = GLenum(0x88DA)
  GL_MATRIX27_ARB*: GLenum = GLenum(0x88DB)
  GL_MATRIX28_ARB*: GLenum = GLenum(0x88DC)
  GL_MATRIX29_ARB*: GLenum = GLenum(0x88DD)
  GL_MATRIX30_ARB*: GLenum = GLenum(0x88DE)
  GL_MATRIX31_ARB*: GLenum = GLenum(0x88DF)
  GL_STREAM_DRAW*: GLenum = GLenum(0x88E0)
  GL_STREAM_DRAW_ARB*: GLenum = GLenum(0x88E0)
  GL_STREAM_READ*: GLenum = GLenum(0x88E1)
  GL_STREAM_READ_ARB*: GLenum = GLenum(0x88E1)
  GL_STREAM_COPY*: GLenum = GLenum(0x88E2)
  GL_STREAM_COPY_ARB*: GLenum = GLenum(0x88E2)
  GL_STATIC_DRAW*: GLenum = GLenum(0x88E4)
  GL_STATIC_DRAW_ARB*: GLenum = GLenum(0x88E4)
  GL_STATIC_READ*: GLenum = GLenum(0x88E5)
  GL_STATIC_READ_ARB*: GLenum = GLenum(0x88E5)
  GL_STATIC_COPY*: GLenum = GLenum(0x88E6)
  GL_STATIC_COPY_ARB*: GLenum = GLenum(0x88E6)
  GL_DYNAMIC_DRAW*: GLenum = GLenum(0x88E8)
  GL_DYNAMIC_DRAW_ARB*: GLenum = GLenum(0x88E8)
  GL_DYNAMIC_READ*: GLenum = GLenum(0x88E9)
  GL_DYNAMIC_READ_ARB*: GLenum = GLenum(0x88E9)
  GL_DYNAMIC_COPY*: GLenum = GLenum(0x88EA)
  GL_DYNAMIC_COPY_ARB*: GLenum = GLenum(0x88EA)
  GL_PIXEL_PACK_BUFFER*: GLenum = GLenum(0x88EB)
  GL_PIXEL_PACK_BUFFER_ARB*: GLenum = GLenum(0x88EB)
  GL_PIXEL_PACK_BUFFER_EXT*: GLenum = GLenum(0x88EB)
  GL_PIXEL_PACK_BUFFER_NV*: GLenum = GLenum(0x88EB)
  GL_PIXEL_UNPACK_BUFFER*: GLenum = GLenum(0x88EC)
  GL_PIXEL_UNPACK_BUFFER_ARB*: GLenum = GLenum(0x88EC)
  GL_PIXEL_UNPACK_BUFFER_EXT*: GLenum = GLenum(0x88EC)
  GL_PIXEL_UNPACK_BUFFER_NV*: GLenum = GLenum(0x88EC)
  GL_PIXEL_PACK_BUFFER_BINDING*: GLenum = GLenum(0x88ED)
  GL_PIXEL_PACK_BUFFER_BINDING_ARB*: GLenum = GLenum(0x88ED)
  GL_PIXEL_PACK_BUFFER_BINDING_EXT*: GLenum = GLenum(0x88ED)
  GL_PIXEL_PACK_BUFFER_BINDING_NV*: GLenum = GLenum(0x88ED)
  GL_ETC1_SRGB8_NV*: GLenum = GLenum(0x88EE)
  GL_PIXEL_UNPACK_BUFFER_BINDING*: GLenum = GLenum(0x88EF)
  GL_PIXEL_UNPACK_BUFFER_BINDING_ARB*: GLenum = GLenum(0x88EF)
  GL_PIXEL_UNPACK_BUFFER_BINDING_EXT*: GLenum = GLenum(0x88EF)
  GL_PIXEL_UNPACK_BUFFER_BINDING_NV*: GLenum = GLenum(0x88EF)
  GL_DEPTH24_STENCIL8*: GLenum = GLenum(0x88F0)
  GL_DEPTH24_STENCIL8_EXT*: GLenum = GLenum(0x88F0)
  GL_DEPTH24_STENCIL8_OES*: GLenum = GLenum(0x88F0)
  GL_TEXTURE_STENCIL_SIZE*: GLenum = GLenum(0x88F1)
  GL_TEXTURE_STENCIL_SIZE_EXT*: GLenum = GLenum(0x88F1)
  GL_STENCIL_TAG_BITS_EXT*: GLenum = GLenum(0x88F2)
  GL_STENCIL_CLEAR_TAG_VALUE_EXT*: GLenum = GLenum(0x88F3)
  GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV*: GLenum = GLenum(0x88F4)
  GL_MAX_PROGRAM_CALL_DEPTH_NV*: GLenum = GLenum(0x88F5)
  GL_MAX_PROGRAM_IF_DEPTH_NV*: GLenum = GLenum(0x88F6)
  GL_MAX_PROGRAM_LOOP_DEPTH_NV*: GLenum = GLenum(0x88F7)
  GL_MAX_PROGRAM_LOOP_COUNT_NV*: GLenum = GLenum(0x88F8)
  GL_SRC1_COLOR*: GLenum = GLenum(0x88F9)
  GL_SRC1_COLOR_EXT*: GLenum = GLenum(0x88F9)
  GL_ONE_MINUS_SRC1_COLOR*: GLenum = GLenum(0x88FA)
  GL_ONE_MINUS_SRC1_COLOR_EXT*: GLenum = GLenum(0x88FA)
  GL_ONE_MINUS_SRC1_ALPHA*: GLenum = GLenum(0x88FB)
  GL_ONE_MINUS_SRC1_ALPHA_EXT*: GLenum = GLenum(0x88FB)
  GL_MAX_DUAL_SOURCE_DRAW_BUFFERS*: GLenum = GLenum(0x88FC)
  GL_MAX_DUAL_SOURCE_DRAW_BUFFERS_EXT*: GLenum = GLenum(0x88FC)
  GL_VERTEX_ATTRIB_ARRAY_INTEGER*: GLenum = GLenum(0x88FD)
  GL_VERTEX_ATTRIB_ARRAY_INTEGER_EXT*: GLenum = GLenum(0x88FD)
  GL_VERTEX_ATTRIB_ARRAY_INTEGER_NV*: GLenum = GLenum(0x88FD)
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR*: GLenum = GLenum(0x88FE)
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE*: GLenum = GLenum(0x88FE)
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB*: GLenum = GLenum(0x88FE)
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR_EXT*: GLenum = GLenum(0x88FE)
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR_NV*: GLenum = GLenum(0x88FE)
  GL_MAX_ARRAY_TEXTURE_LAYERS*: GLenum = GLenum(0x88FF)
  GL_MAX_ARRAY_TEXTURE_LAYERS_EXT*: GLenum = GLenum(0x88FF)
  GL_MIN_PROGRAM_TEXEL_OFFSET*: GLenum = GLenum(0x8904)
  GL_MIN_PROGRAM_TEXEL_OFFSET_EXT*: GLenum = GLenum(0x8904)
  GL_MIN_PROGRAM_TEXEL_OFFSET_NV*: GLenum = GLenum(0x8904)
  GL_MAX_PROGRAM_TEXEL_OFFSET*: GLenum = GLenum(0x8905)
  GL_MAX_PROGRAM_TEXEL_OFFSET_EXT*: GLenum = GLenum(0x8905)
  GL_MAX_PROGRAM_TEXEL_OFFSET_NV*: GLenum = GLenum(0x8905)
  GL_PROGRAM_ATTRIB_COMPONENTS_NV*: GLenum = GLenum(0x8906)
  GL_PROGRAM_RESULT_COMPONENTS_NV*: GLenum = GLenum(0x8907)
  GL_MAX_PROGRAM_ATTRIB_COMPONENTS_NV*: GLenum = GLenum(0x8908)
  GL_MAX_PROGRAM_RESULT_COMPONENTS_NV*: GLenum = GLenum(0x8909)
  GL_STENCIL_TEST_TWO_SIDE_EXT*: GLenum = GLenum(0x8910)
  GL_ACTIVE_STENCIL_FACE_EXT*: GLenum = GLenum(0x8911)
  GL_MIRROR_CLAMP_TO_BORDER_EXT*: GLenum = GLenum(0x8912)
  GL_SAMPLES_PASSED*: GLenum = GLenum(0x8914)
  GL_SAMPLES_PASSED_ARB*: GLenum = GLenum(0x8914)
  GL_GEOMETRY_VERTICES_OUT*: GLenum = GLenum(0x8916)
  GL_GEOMETRY_LINKED_VERTICES_OUT_EXT*: GLenum = GLenum(0x8916)
  GL_GEOMETRY_LINKED_VERTICES_OUT_OES*: GLenum = GLenum(0x8916)
  GL_GEOMETRY_INPUT_TYPE*: GLenum = GLenum(0x8917)
  GL_GEOMETRY_LINKED_INPUT_TYPE_EXT*: GLenum = GLenum(0x8917)
  GL_GEOMETRY_LINKED_INPUT_TYPE_OES*: GLenum = GLenum(0x8917)
  GL_GEOMETRY_OUTPUT_TYPE*: GLenum = GLenum(0x8918)
  GL_GEOMETRY_LINKED_OUTPUT_TYPE_EXT*: GLenum = GLenum(0x8918)
  GL_GEOMETRY_LINKED_OUTPUT_TYPE_OES*: GLenum = GLenum(0x8918)
  GL_SAMPLER_BINDING*: GLenum = GLenum(0x8919)
  GL_DEBUG_OUTPUT_KHR*: GLenum = GLenum(0x92E0)
  GL_CLAMP_VERTEX_COLOR_ARB*: GLenum = GLenum(0x891A)
  GL_DEBUG_OUTPUT*: GLenum = GLenum(0x92E0)
  GL_CLAMP_FRAGMENT_COLOR_ARB*: GLenum = GLenum(0x891B)
  GL_CLAMP_READ_COLOR*: GLenum = GLenum(0x891C)
  GL_CLAMP_READ_COLOR_ARB*: GLenum = GLenum(0x891C)
  GL_FIXED_ONLY*: GLenum = GLenum(0x891D)
  GL_FIXED_ONLY_ARB*: GLenum = GLenum(0x891D)
  GL_TESS_CONTROL_PROGRAM_NV*: GLenum = GLenum(0x891E)
  GL_TESS_EVALUATION_PROGRAM_NV*: GLenum = GLenum(0x891F)
  GL_FRAGMENT_SHADER_ATI*: GLenum = GLenum(0x8920)
  GL_REG_0_ATI*: GLenum = GLenum(0x8921)
  GL_REG_1_ATI*: GLenum = GLenum(0x8922)
  GL_REG_2_ATI*: GLenum = GLenum(0x8923)
  GL_REG_3_ATI*: GLenum = GLenum(0x8924)
  GL_REG_4_ATI*: GLenum = GLenum(0x8925)
  GL_REG_5_ATI*: GLenum = GLenum(0x8926)
  GL_REG_6_ATI*: GLenum = GLenum(0x8927)
  GL_REG_7_ATI*: GLenum = GLenum(0x8928)
  GL_REG_8_ATI*: GLenum = GLenum(0x8929)
  GL_REG_9_ATI*: GLenum = GLenum(0x892A)
  GL_REG_10_ATI*: GLenum = GLenum(0x892B)
  GL_REG_11_ATI*: GLenum = GLenum(0x892C)
  GL_REG_12_ATI*: GLenum = GLenum(0x892D)
  GL_REG_13_ATI*: GLenum = GLenum(0x892E)
  GL_REG_14_ATI*: GLenum = GLenum(0x892F)
  GL_REG_15_ATI*: GLenum = GLenum(0x8930)
  GL_REG_16_ATI*: GLenum = GLenum(0x8931)
  GL_REG_17_ATI*: GLenum = GLenum(0x8932)
  GL_REG_18_ATI*: GLenum = GLenum(0x8933)
  GL_REG_19_ATI*: GLenum = GLenum(0x8934)
  GL_REG_20_ATI*: GLenum = GLenum(0x8935)
  GL_REG_21_ATI*: GLenum = GLenum(0x8936)
  GL_REG_22_ATI*: GLenum = GLenum(0x8937)
  GL_REG_23_ATI*: GLenum = GLenum(0x8938)
  GL_REG_24_ATI*: GLenum = GLenum(0x8939)
  GL_REG_25_ATI*: GLenum = GLenum(0x893A)
  GL_REG_26_ATI*: GLenum = GLenum(0x893B)
  GL_REG_27_ATI*: GLenum = GLenum(0x893C)
  GL_REG_28_ATI*: GLenum = GLenum(0x893D)
  GL_REG_29_ATI*: GLenum = GLenum(0x893E)
  GL_REG_30_ATI*: GLenum = GLenum(0x893F)
  GL_REG_31_ATI*: GLenum = GLenum(0x8940)
  GL_CON_0_ATI*: GLenum = GLenum(0x8941)
  GL_CON_1_ATI*: GLenum = GLenum(0x8942)
  GL_CON_2_ATI*: GLenum = GLenum(0x8943)
  GL_CON_3_ATI*: GLenum = GLenum(0x8944)
  GL_CON_4_ATI*: GLenum = GLenum(0x8945)
  GL_CON_5_ATI*: GLenum = GLenum(0x8946)
  GL_CON_6_ATI*: GLenum = GLenum(0x8947)
  GL_CON_7_ATI*: GLenum = GLenum(0x8948)
  GL_CON_8_ATI*: GLenum = GLenum(0x8949)
  GL_CON_9_ATI*: GLenum = GLenum(0x894A)
  GL_CON_10_ATI*: GLenum = GLenum(0x894B)
  GL_CON_11_ATI*: GLenum = GLenum(0x894C)
  GL_CON_12_ATI*: GLenum = GLenum(0x894D)
  GL_CON_13_ATI*: GLenum = GLenum(0x894E)
  GL_CON_14_ATI*: GLenum = GLenum(0x894F)
  GL_CON_15_ATI*: GLenum = GLenum(0x8950)
  GL_CON_16_ATI*: GLenum = GLenum(0x8951)
  GL_CON_17_ATI*: GLenum = GLenum(0x8952)
  GL_CON_18_ATI*: GLenum = GLenum(0x8953)
  GL_CON_19_ATI*: GLenum = GLenum(0x8954)
  GL_CON_20_ATI*: GLenum = GLenum(0x8955)
  GL_CON_21_ATI*: GLenum = GLenum(0x8956)
  GL_CON_22_ATI*: GLenum = GLenum(0x8957)
  GL_CON_23_ATI*: GLenum = GLenum(0x8958)
  GL_CON_24_ATI*: GLenum = GLenum(0x8959)
  GL_CON_25_ATI*: GLenum = GLenum(0x895A)
  GL_CON_26_ATI*: GLenum = GLenum(0x895B)
  GL_CON_27_ATI*: GLenum = GLenum(0x895C)
  GL_CON_28_ATI*: GLenum = GLenum(0x895D)
  GL_CON_29_ATI*: GLenum = GLenum(0x895E)
  GL_CON_30_ATI*: GLenum = GLenum(0x895F)
  GL_CON_31_ATI*: GLenum = GLenum(0x8960)
  GL_MOV_ATI*: GLenum = GLenum(0x8961)
  GL_ADD_ATI*: GLenum = GLenum(0x8963)
  GL_MUL_ATI*: GLenum = GLenum(0x8964)
  GL_SUB_ATI*: GLenum = GLenum(0x8965)
  GL_DOT3_ATI*: GLenum = GLenum(0x8966)
  GL_DOT4_ATI*: GLenum = GLenum(0x8967)
  GL_MAD_ATI*: GLenum = GLenum(0x8968)
  GL_LERP_ATI*: GLenum = GLenum(0x8969)
  GL_CND_ATI*: GLenum = GLenum(0x896A)
  GL_CND0_ATI*: GLenum = GLenum(0x896B)
  GL_DOT2_ADD_ATI*: GLenum = GLenum(0x896C)
  GL_SECONDARY_INTERPOLATOR_ATI*: GLenum = GLenum(0x896D)
  GL_NUM_FRAGMENT_REGISTERS_ATI*: GLenum = GLenum(0x896E)
  GL_NUM_FRAGMENT_CONSTANTS_ATI*: GLenum = GLenum(0x896F)
  GL_NUM_PASSES_ATI*: GLenum = GLenum(0x8970)
  GL_NUM_INSTRUCTIONS_PER_PASS_ATI*: GLenum = GLenum(0x8971)
  GL_NUM_INSTRUCTIONS_TOTAL_ATI*: GLenum = GLenum(0x8972)
  GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI*: GLenum = GLenum(0x8973)
  GL_NUM_LOOPBACK_COMPONENTS_ATI*: GLenum = GLenum(0x8974)
  GL_COLOR_ALPHA_PAIRING_ATI*: GLenum = GLenum(0x8975)
  GL_SWIZZLE_STR_ATI*: GLenum = GLenum(0x8976)
  GL_SWIZZLE_STQ_ATI*: GLenum = GLenum(0x8977)
  GL_SWIZZLE_STR_DR_ATI*: GLenum = GLenum(0x8978)
  GL_SWIZZLE_STQ_DQ_ATI*: GLenum = GLenum(0x8979)
  GL_SWIZZLE_STRQ_ATI*: GLenum = GLenum(0x897A)
  GL_SWIZZLE_STRQ_DQ_ATI*: GLenum = GLenum(0x897B)
  GL_INTERLACE_OML*: GLenum = GLenum(0x8980)
  GL_INTERLACE_READ_OML*: GLenum = GLenum(0x8981)
  GL_FORMAT_SUBSAMPLE_24_24_OML*: GLenum = GLenum(0x8982)
  GL_FORMAT_SUBSAMPLE_244_244_OML*: GLenum = GLenum(0x8983)
  GL_PACK_RESAMPLE_OML*: GLenum = GLenum(0x8984)
  GL_UNPACK_RESAMPLE_OML*: GLenum = GLenum(0x8985)
  GL_RESAMPLE_REPLICATE_OML*: GLenum = GLenum(0x8986)
  GL_RESAMPLE_ZERO_FILL_OML*: GLenum = GLenum(0x8987)
  GL_RESAMPLE_AVERAGE_OML*: GLenum = GLenum(0x8988)
  GL_RESAMPLE_DECIMATE_OML*: GLenum = GLenum(0x8989)
  GL_POINT_SIZE_ARRAY_TYPE_OES*: GLenum = GLenum(0x898A)
  GL_POINT_SIZE_ARRAY_STRIDE_OES*: GLenum = GLenum(0x898B)
  GL_POINT_SIZE_ARRAY_POINTER_OES*: GLenum = GLenum(0x898C)
  GL_MODELVIEW_MATRIX_FLOAT_AS_INT_BITS_OES*: GLenum = GLenum(0x898D)
  GL_PROJECTION_MATRIX_FLOAT_AS_INT_BITS_OES*: GLenum = GLenum(0x898E)
  GL_TEXTURE_MATRIX_FLOAT_AS_INT_BITS_OES*: GLenum = GLenum(0x898F)
  GL_VERTEX_ATTRIB_MAP1_APPLE*: GLenum = GLenum(0x8A00)
  GL_VERTEX_ATTRIB_MAP2_APPLE*: GLenum = GLenum(0x8A01)
  GL_VERTEX_ATTRIB_MAP1_SIZE_APPLE*: GLenum = GLenum(0x8A02)
  GL_VERTEX_ATTRIB_MAP1_COEFF_APPLE*: GLenum = GLenum(0x8A03)
  GL_VERTEX_ATTRIB_MAP1_ORDER_APPLE*: GLenum = GLenum(0x8A04)
  GL_VERTEX_ATTRIB_MAP1_DOMAIN_APPLE*: GLenum = GLenum(0x8A05)
  GL_VERTEX_ATTRIB_MAP2_SIZE_APPLE*: GLenum = GLenum(0x8A06)
  GL_VERTEX_ATTRIB_MAP2_COEFF_APPLE*: GLenum = GLenum(0x8A07)
  GL_VERTEX_ATTRIB_MAP2_ORDER_APPLE*: GLenum = GLenum(0x8A08)
  GL_VERTEX_ATTRIB_MAP2_DOMAIN_APPLE*: GLenum = GLenum(0x8A09)
  GL_DRAW_PIXELS_APPLE*: GLenum = GLenum(0x8A0A)
  GL_FENCE_APPLE*: GLenum = GLenum(0x8A0B)
  GL_ELEMENT_ARRAY_APPLE*: GLenum = GLenum(0x8A0C)
  GL_ELEMENT_ARRAY_TYPE_APPLE*: GLenum = GLenum(0x8A0D)
  GL_ELEMENT_ARRAY_POINTER_APPLE*: GLenum = GLenum(0x8A0E)
  GL_COLOR_FLOAT_APPLE*: GLenum = GLenum(0x8A0F)
  GL_UNIFORM_BUFFER*: GLenum = GLenum(0x8A11)
  GL_BUFFER_SERIALIZED_MODIFY_APPLE*: GLenum = GLenum(0x8A12)
  GL_BUFFER_FLUSHING_UNMAP_APPLE*: GLenum = GLenum(0x8A13)
  GL_AUX_DEPTH_STENCIL_APPLE*: GLenum = GLenum(0x8A14)
  GL_PACK_ROW_BYTES_APPLE*: GLenum = GLenum(0x8A15)
  GL_UNPACK_ROW_BYTES_APPLE*: GLenum = GLenum(0x8A16)
  GL_RELEASED_APPLE*: GLenum = GLenum(0x8A19)
  GL_VOLATILE_APPLE*: GLenum = GLenum(0x8A1A)
  GL_RETAINED_APPLE*: GLenum = GLenum(0x8A1B)
  GL_UNDEFINED_APPLE*: GLenum = GLenum(0x8A1C)
  GL_PURGEABLE_APPLE*: GLenum = GLenum(0x8A1D)
  GL_RGB_422_APPLE*: GLenum = GLenum(0x8A1F)
  GL_UNIFORM_BUFFER_BINDING*: GLenum = GLenum(0x8A28)
  GL_UNIFORM_BUFFER_START*: GLenum = GLenum(0x8A29)
  GL_UNIFORM_BUFFER_SIZE*: GLenum = GLenum(0x8A2A)
  GL_MAX_VERTEX_UNIFORM_BLOCKS*: GLenum = GLenum(0x8A2B)
  GL_MAX_GEOMETRY_UNIFORM_BLOCKS*: GLenum = GLenum(0x8A2C)
  GL_MAX_GEOMETRY_UNIFORM_BLOCKS_EXT*: GLenum = GLenum(0x8A2C)
  GL_MAX_GEOMETRY_UNIFORM_BLOCKS_OES*: GLenum = GLenum(0x8A2C)
  GL_MAX_FRAGMENT_UNIFORM_BLOCKS*: GLenum = GLenum(0x8A2D)
  GL_MAX_COMBINED_UNIFORM_BLOCKS*: GLenum = GLenum(0x8A2E)
  GL_MAX_UNIFORM_BUFFER_BINDINGS*: GLenum = GLenum(0x8A2F)
  GL_MAX_UNIFORM_BLOCK_SIZE*: GLenum = GLenum(0x8A30)
  GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS*: GLenum = GLenum(0x8A31)
  GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS*: GLenum = GLenum(0x8A32)
  GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_EXT*: GLenum = GLenum(0x8A32)
  GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_OES*: GLenum = GLenum(0x8A32)
  GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS*: GLenum = GLenum(0x8A33)
  GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT*: GLenum = GLenum(0x8A34)
  GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH*: GLenum = GLenum(0x8A35)
  GL_ACTIVE_UNIFORM_BLOCKS*: GLenum = GLenum(0x8A36)
  GL_UNIFORM_TYPE*: GLenum = GLenum(0x8A37)
  GL_UNIFORM_SIZE*: GLenum = GLenum(0x8A38)
  GL_UNIFORM_NAME_LENGTH*: GLenum = GLenum(0x8A39)
  GL_UNIFORM_BLOCK_INDEX*: GLenum = GLenum(0x8A3A)
  GL_UNIFORM_OFFSET*: GLenum = GLenum(0x8A3B)
  GL_UNIFORM_ARRAY_STRIDE*: GLenum = GLenum(0x8A3C)
  GL_UNIFORM_MATRIX_STRIDE*: GLenum = GLenum(0x8A3D)
  GL_UNIFORM_IS_ROW_MAJOR*: GLenum = GLenum(0x8A3E)
  GL_UNIFORM_BLOCK_BINDING*: GLenum = GLenum(0x8A3F)
  GL_UNIFORM_BLOCK_DATA_SIZE*: GLenum = GLenum(0x8A40)
  GL_UNIFORM_BLOCK_NAME_LENGTH*: GLenum = GLenum(0x8A41)
  GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS*: GLenum = GLenum(0x8A42)
  GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES*: GLenum = GLenum(0x8A43)
  GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER*: GLenum = GLenum(0x8A44)
  GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER*: GLenum = GLenum(0x8A45)
  GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER*: GLenum = GLenum(0x8A46)
  GL_TEXTURE_SRGB_DECODE_EXT*: GLenum = GLenum(0x8A48)
  GL_DECODE_EXT*: GLenum = GLenum(0x8A49)
  GL_SKIP_DECODE_EXT*: GLenum = GLenum(0x8A4A)
  GL_PROGRAM_PIPELINE_OBJECT_EXT*: GLenum = GLenum(0x8A4F)
  GL_RGB_RAW_422_APPLE*: GLenum = GLenum(0x8A51)
  GL_FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT*: GLenum = GLenum(0x8A52)
  GL_SYNC_OBJECT_APPLE*: GLenum = GLenum(0x8A53)
  GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT*: GLenum = GLenum(0x8A54)
  GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT*: GLenum = GLenum(0x8A55)
  GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT*: GLenum = GLenum(0x8A56)
  GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT*: GLenum = GLenum(0x8A57)
  GL_FRAGMENT_SHADER*: GLenum = GLenum(0x8B30)
  GL_FRAGMENT_SHADER_ARB*: GLenum = GLenum(0x8B30)
  GL_VERTEX_SHADER*: GLenum = GLenum(0x8B31)
  GL_VERTEX_SHADER_ARB*: GLenum = GLenum(0x8B31)
  GL_PROGRAM_OBJECT_ARB*: GLenum = GLenum(0x8B40)
  GL_PROGRAM_OBJECT_EXT*: GLenum = GLenum(0x8B40)
  GL_SHADER_OBJECT_ARB*: GLenum = GLenum(0x8B48)
  GL_SHADER_OBJECT_EXT*: GLenum = GLenum(0x8B48)
  GL_MAX_FRAGMENT_UNIFORM_COMPONENTS*: GLenum = GLenum(0x8B49)
  GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB*: GLenum = GLenum(0x8B49)
  GL_MAX_VERTEX_UNIFORM_COMPONENTS*: GLenum = GLenum(0x8B4A)
  GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB*: GLenum = GLenum(0x8B4A)
  GL_MAX_VARYING_FLOATS*: GLenum = GLenum(0x8B4B)
  GL_MAX_VARYING_COMPONENTS*: GLenum = GLenum(0x8B4B)
  GL_MAX_VARYING_COMPONENTS_EXT*: GLenum = GLenum(0x8B4B)
  GL_MAX_VARYING_FLOATS_ARB*: GLenum = GLenum(0x8B4B)
  GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS*: GLenum = GLenum(0x8B4C)
  GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB*: GLenum = GLenum(0x8B4C)
  GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS*: GLenum = GLenum(0x8B4D)
  GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB*: GLenum = GLenum(0x8B4D)
  GL_OBJECT_TYPE_ARB*: GLenum = GLenum(0x8B4E)
  GL_SHADER_TYPE*: GLenum = GLenum(0x8B4F)
  GL_OBJECT_SUBTYPE_ARB*: GLenum = GLenum(0x8B4F)
  GL_FLOAT_VEC2*: GLenum = GLenum(0x8B50)
  GL_FLOAT_VEC2_ARB*: GLenum = GLenum(0x8B50)
  GL_FLOAT_VEC3*: GLenum = GLenum(0x8B51)
  GL_FLOAT_VEC3_ARB*: GLenum = GLenum(0x8B51)
  GL_FLOAT_VEC4*: GLenum = GLenum(0x8B52)
  GL_FLOAT_VEC4_ARB*: GLenum = GLenum(0x8B52)
  GL_INT_VEC2*: GLenum = GLenum(0x8B53)
  GL_INT_VEC2_ARB*: GLenum = GLenum(0x8B53)
  GL_INT_VEC3*: GLenum = GLenum(0x8B54)
  GL_INT_VEC3_ARB*: GLenum = GLenum(0x8B54)
  GL_INT_VEC4*: GLenum = GLenum(0x8B55)
  GL_INT_VEC4_ARB*: GLenum = GLenum(0x8B55)
  GL_BOOL*: GLenum = GLenum(0x8B56)
  GL_BOOL_ARB*: GLenum = GLenum(0x8B56)
  GL_BOOL_VEC2*: GLenum = GLenum(0x8B57)
  GL_BOOL_VEC2_ARB*: GLenum = GLenum(0x8B57)
  GL_BOOL_VEC3*: GLenum = GLenum(0x8B58)
  GL_BOOL_VEC3_ARB*: GLenum = GLenum(0x8B58)
  GL_BOOL_VEC4*: GLenum = GLenum(0x8B59)
  GL_BOOL_VEC4_ARB*: GLenum = GLenum(0x8B59)
  GL_FLOAT_MAT2*: GLenum = GLenum(0x8B5A)
  GL_FLOAT_MAT2_ARB*: GLenum = GLenum(0x8B5A)
  GL_FLOAT_MAT3*: GLenum = GLenum(0x8B5B)
  GL_FLOAT_MAT3_ARB*: GLenum = GLenum(0x8B5B)
  GL_FLOAT_MAT4*: GLenum = GLenum(0x8B5C)
  GL_FLOAT_MAT4_ARB*: GLenum = GLenum(0x8B5C)
  GL_SAMPLER_1D*: GLenum = GLenum(0x8B5D)
  GL_SAMPLER_1D_ARB*: GLenum = GLenum(0x8B5D)
  GL_SAMPLER_2D*: GLenum = GLenum(0x8B5E)
  GL_SAMPLER_2D_ARB*: GLenum = GLenum(0x8B5E)
  GL_SAMPLER_3D*: GLenum = GLenum(0x8B5F)
  GL_SAMPLER_3D_ARB*: GLenum = GLenum(0x8B5F)
  GL_SAMPLER_3D_OES*: GLenum = GLenum(0x8B5F)
  GL_SAMPLER_CUBE*: GLenum = GLenum(0x8B60)
  GL_SAMPLER_CUBE_ARB*: GLenum = GLenum(0x8B60)
  GL_SAMPLER_1D_SHADOW*: GLenum = GLenum(0x8B61)
  GL_SAMPLER_1D_SHADOW_ARB*: GLenum = GLenum(0x8B61)
  GL_SAMPLER_2D_SHADOW*: GLenum = GLenum(0x8B62)
  GL_SAMPLER_2D_SHADOW_ARB*: GLenum = GLenum(0x8B62)
  GL_SAMPLER_2D_SHADOW_EXT*: GLenum = GLenum(0x8B62)
  GL_SAMPLER_2D_RECT*: GLenum = GLenum(0x8B63)
  GL_SAMPLER_2D_RECT_ARB*: GLenum = GLenum(0x8B63)
  GL_SAMPLER_2D_RECT_SHADOW*: GLenum = GLenum(0x8B64)
  GL_SAMPLER_2D_RECT_SHADOW_ARB*: GLenum = GLenum(0x8B64)
  GL_FLOAT_MAT2x3*: GLenum = GLenum(0x8B65)
  GL_FLOAT_MAT2x3_NV*: GLenum = GLenum(0x8B65)
  GL_FLOAT_MAT2x4*: GLenum = GLenum(0x8B66)
  GL_FLOAT_MAT2x4_NV*: GLenum = GLenum(0x8B66)
  GL_FLOAT_MAT3x2*: GLenum = GLenum(0x8B67)
  GL_FLOAT_MAT3x2_NV*: GLenum = GLenum(0x8B67)
  GL_FLOAT_MAT3x4*: GLenum = GLenum(0x8B68)
  GL_FLOAT_MAT3x4_NV*: GLenum = GLenum(0x8B68)
  GL_FLOAT_MAT4x2*: GLenum = GLenum(0x8B69)
  GL_FLOAT_MAT4x2_NV*: GLenum = GLenum(0x8B69)
  GL_FLOAT_MAT4x3*: GLenum = GLenum(0x8B6A)
  GL_FLOAT_MAT4x3_NV*: GLenum = GLenum(0x8B6A)
  GL_DELETE_STATUS*: GLenum = GLenum(0x8B80)
  GL_OBJECT_DELETE_STATUS_ARB*: GLenum = GLenum(0x8B80)
  GL_COMPILE_STATUS*: GLenum = GLenum(0x8B81)
  GL_OBJECT_COMPILE_STATUS_ARB*: GLenum = GLenum(0x8B81)
  GL_LINK_STATUS*: GLenum = GLenum(0x8B82)
  GL_OBJECT_LINK_STATUS_ARB*: GLenum = GLenum(0x8B82)
  GL_VALIDATE_STATUS*: GLenum = GLenum(0x8B83)
  GL_OBJECT_VALIDATE_STATUS_ARB*: GLenum = GLenum(0x8B83)
  GL_INFO_LOG_LENGTH*: GLenum = GLenum(0x8B84)
  GL_OBJECT_INFO_LOG_LENGTH_ARB*: GLenum = GLenum(0x8B84)
  GL_ATTACHED_SHADERS*: GLenum = GLenum(0x8B85)
  GL_OBJECT_ATTACHED_OBJECTS_ARB*: GLenum = GLenum(0x8B85)
  GL_ACTIVE_UNIFORMS*: GLenum = GLenum(0x8B86)
  GL_OBJECT_ACTIVE_UNIFORMS_ARB*: GLenum = GLenum(0x8B86)
  GL_ACTIVE_UNIFORM_MAX_LENGTH*: GLenum = GLenum(0x8B87)
  GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB*: GLenum = GLenum(0x8B87)
  GL_SHADER_SOURCE_LENGTH*: GLenum = GLenum(0x8B88)
  GL_OBJECT_SHADER_SOURCE_LENGTH_ARB*: GLenum = GLenum(0x8B88)
  GL_ACTIVE_ATTRIBUTES*: GLenum = GLenum(0x8B89)
  GL_OBJECT_ACTIVE_ATTRIBUTES_ARB*: GLenum = GLenum(0x8B89)
  GL_ACTIVE_ATTRIBUTE_MAX_LENGTH*: GLenum = GLenum(0x8B8A)
  GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB*: GLenum = GLenum(0x8B8A)
  GL_FRAGMENT_SHADER_DERIVATIVE_HINT*: GLenum = GLenum(0x8B8B)
  GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB*: GLenum = GLenum(0x8B8B)
  GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES*: GLenum = GLenum(0x8B8B)
  GL_SHADING_LANGUAGE_VERSION*: GLenum = GLenum(0x8B8C)
  GL_SHADING_LANGUAGE_VERSION_ARB*: GLenum = GLenum(0x8B8C)
  GL_CURRENT_PROGRAM*: GLenum = GLenum(0x8B8D)
  GL_PALETTE4_RGB8_OES*: GLenum = GLenum(0x8B90)
  GL_PALETTE4_RGBA8_OES*: GLenum = GLenum(0x8B91)
  GL_PALETTE4_R5_G6_B5_OES*: GLenum = GLenum(0x8B92)
  GL_PALETTE4_RGBA4_OES*: GLenum = GLenum(0x8B93)
  GL_PALETTE4_RGB5_A1_OES*: GLenum = GLenum(0x8B94)
  GL_PALETTE8_RGB8_OES*: GLenum = GLenum(0x8B95)
  GL_PALETTE8_RGBA8_OES*: GLenum = GLenum(0x8B96)
  GL_PALETTE8_R5_G6_B5_OES*: GLenum = GLenum(0x8B97)
  GL_PALETTE8_RGBA4_OES*: GLenum = GLenum(0x8B98)
  GL_PALETTE8_RGB5_A1_OES*: GLenum = GLenum(0x8B99)
  GL_IMPLEMENTATION_COLOR_READ_TYPE*: GLenum = GLenum(0x8B9A)
  GL_IMPLEMENTATION_COLOR_READ_TYPE_OES*: GLenum = GLenum(0x8B9A)
  GL_IMPLEMENTATION_COLOR_READ_FORMAT*: GLenum = GLenum(0x8B9B)
  GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES*: GLenum = GLenum(0x8B9B)
  GL_POINT_SIZE_ARRAY_OES*: GLenum = GLenum(0x8B9C)
  GL_TEXTURE_CROP_RECT_OES*: GLenum = GLenum(0x8B9D)
  GL_MATRIX_INDEX_ARRAY_BUFFER_BINDING_OES*: GLenum = GLenum(0x8B9E)
  GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES*: GLenum = GLenum(0x8B9F)
  GL_FRAGMENT_PROGRAM_POSITION_MESA*: GLenum = GLenum(0x8BB0)
  GL_FRAGMENT_PROGRAM_CALLBACK_MESA*: GLenum = GLenum(0x8BB1)
  GL_FRAGMENT_PROGRAM_CALLBACK_FUNC_MESA*: GLenum = GLenum(0x8BB2)
  GL_FRAGMENT_PROGRAM_CALLBACK_DATA_MESA*: GLenum = GLenum(0x8BB3)
  GL_VERTEX_PROGRAM_POSITION_MESA*: GLenum = GLenum(0x8BB4)
  GL_VERTEX_PROGRAM_CALLBACK_MESA*: GLenum = GLenum(0x8BB5)
  GL_VERTEX_PROGRAM_CALLBACK_FUNC_MESA*: GLenum = GLenum(0x8BB6)
  GL_VERTEX_PROGRAM_CALLBACK_DATA_MESA*: GLenum = GLenum(0x8BB7)
  GL_TILE_RASTER_ORDER_FIXED_MESA*: GLenum = GLenum(0x8BB8)
  GL_TILE_RASTER_ORDER_INCREASING_X_MESA*: GLenum = GLenum(0x8BB9)
  GL_TILE_RASTER_ORDER_INCREASING_Y_MESA*: GLenum = GLenum(0x8BBA)
  GL_FRAMEBUFFER_FLIP_Y_MESA*: GLenum = GLenum(0x8BBB)
  GL_COUNTER_TYPE_AMD*: GLenum = GLenum(0x8BC0)
  GL_COUNTER_RANGE_AMD*: GLenum = GLenum(0x8BC1)
  GL_UNSIGNED_INT64_AMD*: GLenum = GLenum(0x8BC2)
  GL_PERCENTAGE_AMD*: GLenum = GLenum(0x8BC3)
  GL_PERFMON_RESULT_AVAILABLE_AMD*: GLenum = GLenum(0x8BC4)
  GL_PERFMON_RESULT_SIZE_AMD*: GLenum = GLenum(0x8BC5)
  GL_PERFMON_RESULT_AMD*: GLenum = GLenum(0x8BC6)
  GL_TEXTURE_WIDTH_QCOM*: GLenum = GLenum(0x8BD2)
  GL_TEXTURE_HEIGHT_QCOM*: GLenum = GLenum(0x8BD3)
  GL_TEXTURE_DEPTH_QCOM*: GLenum = GLenum(0x8BD4)
  GL_TEXTURE_INTERNAL_FORMAT_QCOM*: GLenum = GLenum(0x8BD5)
  GL_TEXTURE_FORMAT_QCOM*: GLenum = GLenum(0x8BD6)
  GL_TEXTURE_TYPE_QCOM*: GLenum = GLenum(0x8BD7)
  GL_TEXTURE_IMAGE_VALID_QCOM*: GLenum = GLenum(0x8BD8)
  GL_TEXTURE_NUM_LEVELS_QCOM*: GLenum = GLenum(0x8BD9)
  GL_TEXTURE_TARGET_QCOM*: GLenum = GLenum(0x8BDA)
  GL_TEXTURE_OBJECT_VALID_QCOM*: GLenum = GLenum(0x8BDB)
  GL_STATE_RESTORE*: GLenum = GLenum(0x8BDC)
  GL_SAMPLER_EXTERNAL_2D_Y2Y_EXT*: GLenum = GLenum(0x8BE7)
  GL_TEXTURE_PROTECTED_EXT*: GLenum = GLenum(0x8BFA)
  GL_TEXTURE_FOVEATED_FEATURE_BITS_QCOM*: GLenum = GLenum(0x8BFB)
  GL_TEXTURE_FOVEATED_MIN_PIXEL_DENSITY_QCOM*: GLenum = GLenum(0x8BFC)
  GL_TEXTURE_FOVEATED_FEATURE_QUERY_QCOM*: GLenum = GLenum(0x8BFD)
  GL_TEXTURE_FOVEATED_NUM_FOCAL_POINTS_QUERY_QCOM*: GLenum = GLenum(0x8BFE)
  GL_FRAMEBUFFER_INCOMPLETE_FOVEATION_QCOM*: GLenum = GLenum(0x8BFF)
  GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG*: GLenum = GLenum(0x8C00)
  GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG*: GLenum = GLenum(0x8C01)
  GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG*: GLenum = GLenum(0x8C02)
  GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG*: GLenum = GLenum(0x8C03)
  GL_MODULATE_COLOR_IMG*: GLenum = GLenum(0x8C04)
  GL_RECIP_ADD_SIGNED_ALPHA_IMG*: GLenum = GLenum(0x8C05)
  GL_TEXTURE_ALPHA_MODULATE_IMG*: GLenum = GLenum(0x8C06)
  GL_FACTOR_ALPHA_MODULATE_IMG*: GLenum = GLenum(0x8C07)
  GL_FRAGMENT_ALPHA_MODULATE_IMG*: GLenum = GLenum(0x8C08)
  GL_ADD_BLEND_IMG*: GLenum = GLenum(0x8C09)
  GL_SGX_BINARY_IMG*: GLenum = GLenum(0x8C0A)
  GL_TEXTURE_RED_TYPE*: GLenum = GLenum(0x8C10)
  GL_TEXTURE_RED_TYPE_ARB*: GLenum = GLenum(0x8C10)
  GL_TEXTURE_GREEN_TYPE*: GLenum = GLenum(0x8C11)
  GL_TEXTURE_GREEN_TYPE_ARB*: GLenum = GLenum(0x8C11)
  GL_TEXTURE_BLUE_TYPE*: GLenum = GLenum(0x8C12)
  GL_TEXTURE_BLUE_TYPE_ARB*: GLenum = GLenum(0x8C12)
  GL_TEXTURE_ALPHA_TYPE*: GLenum = GLenum(0x8C13)
  GL_TEXTURE_ALPHA_TYPE_ARB*: GLenum = GLenum(0x8C13)
  GL_FRAGMENT_COVERAGE_TO_COLOR_NV*: GLenum = GLenum(0x92DD)
  GL_TEXTURE_LUMINANCE_TYPE_ARB*: GLenum = GLenum(0x8C14)
  GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS*: GLenum = GLenum(0x92DC)
  GL_TEXTURE_INTENSITY_TYPE_ARB*: GLenum = GLenum(0x8C15)
  GL_TEXTURE_DEPTH_TYPE*: GLenum = GLenum(0x8C16)
  GL_TEXTURE_DEPTH_TYPE_ARB*: GLenum = GLenum(0x8C16)
  GL_UNSIGNED_NORMALIZED*: GLenum = GLenum(0x8C17)
  GL_UNSIGNED_NORMALIZED_ARB*: GLenum = GLenum(0x8C17)
  GL_UNSIGNED_NORMALIZED_EXT*: GLenum = GLenum(0x8C17)
  GL_TEXTURE_1D_ARRAY*: GLenum = GLenum(0x8C18)
  GL_TEXTURE_1D_ARRAY_EXT*: GLenum = GLenum(0x8C18)
  GL_PROXY_TEXTURE_1D_ARRAY*: GLenum = GLenum(0x8C19)
  GL_PROXY_TEXTURE_1D_ARRAY_EXT*: GLenum = GLenum(0x8C19)
  GL_TEXTURE_2D_ARRAY*: GLenum = GLenum(0x8C1A)
  GL_TEXTURE_2D_ARRAY_EXT*: GLenum = GLenum(0x8C1A)
  GL_PROXY_TEXTURE_2D_ARRAY*: GLenum = GLenum(0x8C1B)
  GL_PROXY_TEXTURE_2D_ARRAY_EXT*: GLenum = GLenum(0x8C1B)
  GL_TEXTURE_BINDING_1D_ARRAY*: GLenum = GLenum(0x8C1C)
  GL_TEXTURE_BINDING_1D_ARRAY_EXT*: GLenum = GLenum(0x8C1C)
  GL_TEXTURE_BINDING_2D_ARRAY*: GLenum = GLenum(0x8C1D)
  GL_TEXTURE_BINDING_2D_ARRAY_EXT*: GLenum = GLenum(0x8C1D)
  GL_GEOMETRY_PROGRAM_NV*: GLenum = GLenum(0x8C26)
  GL_MAX_PROGRAM_OUTPUT_VERTICES_NV*: GLenum = GLenum(0x8C27)
  GL_MAX_PROGRAM_TOTAL_OUTPUT_COMPONENTS_NV*: GLenum = GLenum(0x8C28)
  GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS*: GLenum = GLenum(0x8C29)
  GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB*: GLenum = GLenum(0x8C29)
  GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT*: GLenum = GLenum(0x8C29)
  GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_OES*: GLenum = GLenum(0x8C29)
  GL_TEXTURE_BUFFER*: GLenum = GLenum(0x8C2A)
  GL_TEXTURE_BUFFER_ARB*: GLenum = GLenum(0x8C2A)
  GL_TEXTURE_BUFFER_EXT*: GLenum = GLenum(0x8C2A)
  GL_TEXTURE_BUFFER_OES*: GLenum = GLenum(0x8C2A)
  GL_TEXTURE_BUFFER_BINDING*: GLenum = GLenum(0x8C2A) ## Equivalent to GL_TEXTURE_BUFFER_ARB query, but named more consistently
  GL_TEXTURE_BUFFER_BINDING_EXT*: GLenum = GLenum(0x8C2A)
  GL_TEXTURE_BUFFER_BINDING_OES*: GLenum = GLenum(0x8C2A)
  GL_MAX_TEXTURE_BUFFER_SIZE*: GLenum = GLenum(0x8C2B)
  GL_MAX_TEXTURE_BUFFER_SIZE_ARB*: GLenum = GLenum(0x8C2B)
  GL_MAX_TEXTURE_BUFFER_SIZE_EXT*: GLenum = GLenum(0x8C2B)
  GL_MAX_TEXTURE_BUFFER_SIZE_OES*: GLenum = GLenum(0x8C2B)
  GL_TEXTURE_BINDING_BUFFER*: GLenum = GLenum(0x8C2C)
  GL_TEXTURE_BINDING_BUFFER_ARB*: GLenum = GLenum(0x8C2C)
  GL_TEXTURE_BINDING_BUFFER_EXT*: GLenum = GLenum(0x8C2C)
  GL_TEXTURE_BINDING_BUFFER_OES*: GLenum = GLenum(0x8C2C)
  GL_TEXTURE_BUFFER_DATA_STORE_BINDING*: GLenum = GLenum(0x8C2D)
  GL_TEXTURE_BUFFER_DATA_STORE_BINDING_ARB*: GLenum = GLenum(0x8C2D)
  GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT*: GLenum = GLenum(0x8C2D)
  GL_TEXTURE_BUFFER_DATA_STORE_BINDING_OES*: GLenum = GLenum(0x8C2D)
  GL_TEXTURE_BUFFER_FORMAT_ARB*: GLenum = GLenum(0x8C2E)
  GL_TEXTURE_BUFFER_FORMAT_EXT*: GLenum = GLenum(0x8C2E)
  GL_ANY_SAMPLES_PASSED*: GLenum = GLenum(0x8C2F)
  GL_ANY_SAMPLES_PASSED_EXT*: GLenum = GLenum(0x8C2F)
  GL_SAMPLE_SHADING*: GLenum = GLenum(0x8C36)
  GL_SAMPLE_SHADING_ARB*: GLenum = GLenum(0x8C36)
  GL_SAMPLE_SHADING_OES*: GLenum = GLenum(0x8C36)
  GL_MIN_SAMPLE_SHADING_VALUE*: GLenum = GLenum(0x8C37)
  GL_MIN_SAMPLE_SHADING_VALUE_ARB*: GLenum = GLenum(0x8C37)
  GL_MIN_SAMPLE_SHADING_VALUE_OES*: GLenum = GLenum(0x8C37)
  GL_R11F_G11F_B10F*: GLenum = GLenum(0x8C3A)
  GL_R11F_G11F_B10F_APPLE*: GLenum = GLenum(0x8C3A)
  GL_R11F_G11F_B10F_EXT*: GLenum = GLenum(0x8C3A)
  GL_UNSIGNED_INT_10F_11F_11F_REV*: GLenum = GLenum(0x8C3B)
  GL_UNSIGNED_INT_10F_11F_11F_REV_APPLE*: GLenum = GLenum(0x8C3B)
  GL_UNSIGNED_INT_10F_11F_11F_REV_EXT*: GLenum = GLenum(0x8C3B)
  GL_RGBA_SIGNED_COMPONENTS_EXT*: GLenum = GLenum(0x8C3C)
  GL_RGB9_E5*: GLenum = GLenum(0x8C3D)
  GL_RGB9_E5_APPLE*: GLenum = GLenum(0x8C3D)
  GL_RGB9_E5_EXT*: GLenum = GLenum(0x8C3D)
  GL_UNSIGNED_INT_5_9_9_9_REV*: GLenum = GLenum(0x8C3E)
  GL_UNSIGNED_INT_5_9_9_9_REV_APPLE*: GLenum = GLenum(0x8C3E)
  GL_UNSIGNED_INT_5_9_9_9_REV_EXT*: GLenum = GLenum(0x8C3E)
  GL_TEXTURE_SHARED_SIZE*: GLenum = GLenum(0x8C3F)
  GL_TEXTURE_SHARED_SIZE_EXT*: GLenum = GLenum(0x8C3F)
  GL_SRGB*: GLenum = GLenum(0x8C40)
  GL_SRGB_EXT*: GLenum = GLenum(0x8C40)
  GL_SRGB8*: GLenum = GLenum(0x8C41)
  GL_SRGB8_EXT*: GLenum = GLenum(0x8C41)
  GL_SRGB8_NV*: GLenum = GLenum(0x8C41)
  GL_SRGB_ALPHA*: GLenum = GLenum(0x8C42)
  GL_SRGB_ALPHA_EXT*: GLenum = GLenum(0x8C42)
  GL_SRGB8_ALPHA8*: GLenum = GLenum(0x8C43)
  GL_SRGB8_ALPHA8_EXT*: GLenum = GLenum(0x8C43)
  GL_SHADER_STORAGE_BLOCK*: GLenum = GLenum(0x92E6)
  GL_SLUMINANCE_ALPHA_EXT*: GLenum = GLenum(0x8C44)
  GL_SLUMINANCE_ALPHA_NV*: GLenum = GLenum(0x8C44)
  GL_BUFFER_VARIABLE*: GLenum = GLenum(0x92E5)
  GL_SLUMINANCE8_ALPHA8_EXT*: GLenum = GLenum(0x8C45)
  GL_SLUMINANCE8_ALPHA8_NV*: GLenum = GLenum(0x8C45)
  GL_PROGRAM_OUTPUT*: GLenum = GLenum(0x92E4)
  GL_SLUMINANCE_EXT*: GLenum = GLenum(0x8C46)
  GL_SLUMINANCE_NV*: GLenum = GLenum(0x8C46)
  GL_PROGRAM_INPUT*: GLenum = GLenum(0x92E3)
  GL_SLUMINANCE8_EXT*: GLenum = GLenum(0x8C47)
  GL_SLUMINANCE8_NV*: GLenum = GLenum(0x8C47)
  GL_COMPRESSED_SRGB*: GLenum = GLenum(0x8C48)
  GL_COMPRESSED_SRGB_EXT*: GLenum = GLenum(0x8C48)
  GL_COMPRESSED_SRGB_ALPHA*: GLenum = GLenum(0x8C49)
  GL_COMPRESSED_SRGB_ALPHA_EXT*: GLenum = GLenum(0x8C49)
  GL_UNIFORM_BLOCK*: GLenum = GLenum(0x92E2)
  GL_COMPRESSED_SLUMINANCE_EXT*: GLenum = GLenum(0x8C4A)
  GL_UNIFORM*: GLenum = GLenum(0x92E1)
  GL_COMPRESSED_SLUMINANCE_ALPHA_EXT*: GLenum = GLenum(0x8C4B)
  GL_COMPRESSED_SRGB_S3TC_DXT1_EXT*: GLenum = GLenum(0x8C4C)
  GL_COMPRESSED_SRGB_S3TC_DXT1_NV*: GLenum = GLenum(0x8C4C)
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT*: GLenum = GLenum(0x8C4D)
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_NV*: GLenum = GLenum(0x8C4D)
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT*: GLenum = GLenum(0x8C4E)
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_NV*: GLenum = GLenum(0x8C4E)
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT*: GLenum = GLenum(0x8C4F)
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_NV*: GLenum = GLenum(0x8C4F)
  GL_COMPRESSED_LUMINANCE_LATC1_EXT*: GLenum = GLenum(0x8C70)
  GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT*: GLenum = GLenum(0x8C71)
  GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT*: GLenum = GLenum(0x8C72)
  GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT*: GLenum = GLenum(0x8C73)
  GL_TESS_CONTROL_PROGRAM_PARAMETER_BUFFER_NV*: GLenum = GLenum(0x8C74)
  GL_TESS_EVALUATION_PROGRAM_PARAMETER_BUFFER_NV*: GLenum = GLenum(0x8C75)
  GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH*: GLenum = GLenum(0x8C76)
  GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH_EXT*: GLenum = GLenum(0x8C76)
  GL_BACK_PRIMARY_COLOR_NV*: GLenum = GLenum(0x8C77)
  GL_BACK_SECONDARY_COLOR_NV*: GLenum = GLenum(0x8C78)
  GL_TEXTURE_COORD_NV*: GLenum = GLenum(0x8C79)
  GL_CLIP_DISTANCE_NV*: GLenum = GLenum(0x8C7A)
  GL_VERTEX_ID_NV*: GLenum = GLenum(0x8C7B)
  GL_PRIMITIVE_ID_NV*: GLenum = GLenum(0x8C7C)
  GL_GENERIC_ATTRIB_NV*: GLenum = GLenum(0x8C7D)
  GL_TRANSFORM_FEEDBACK_ATTRIBS_NV*: GLenum = GLenum(0x8C7E)
  GL_TRANSFORM_FEEDBACK_BUFFER_MODE*: GLenum = GLenum(0x8C7F)
  GL_TRANSFORM_FEEDBACK_BUFFER_MODE_EXT*: GLenum = GLenum(0x8C7F)
  GL_TRANSFORM_FEEDBACK_BUFFER_MODE_NV*: GLenum = GLenum(0x8C7F)
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS*: GLenum = GLenum(0x8C80)
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_EXT*: GLenum = GLenum(0x8C80)
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_NV*: GLenum = GLenum(0x8C80)
  GL_ACTIVE_VARYINGS_NV*: GLenum = GLenum(0x8C81)
  GL_ACTIVE_VARYING_MAX_LENGTH_NV*: GLenum = GLenum(0x8C82)
  GL_TRANSFORM_FEEDBACK_VARYINGS*: GLenum = GLenum(0x8C83)
  GL_TRANSFORM_FEEDBACK_VARYINGS_EXT*: GLenum = GLenum(0x8C83)
  GL_TRANSFORM_FEEDBACK_VARYINGS_NV*: GLenum = GLenum(0x8C83)
  GL_TRANSFORM_FEEDBACK_BUFFER_START*: GLenum = GLenum(0x8C84)
  GL_TRANSFORM_FEEDBACK_BUFFER_START_EXT*: GLenum = GLenum(0x8C84)
  GL_TRANSFORM_FEEDBACK_BUFFER_START_NV*: GLenum = GLenum(0x8C84)
  GL_TRANSFORM_FEEDBACK_BUFFER_SIZE*: GLenum = GLenum(0x8C85)
  GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_EXT*: GLenum = GLenum(0x8C85)
  GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_NV*: GLenum = GLenum(0x8C85)
  GL_TRANSFORM_FEEDBACK_RECORD_NV*: GLenum = GLenum(0x8C86)
  GL_PRIMITIVES_GENERATED*: GLenum = GLenum(0x8C87)
  GL_PRIMITIVES_GENERATED_EXT*: GLenum = GLenum(0x8C87)
  GL_PRIMITIVES_GENERATED_NV*: GLenum = GLenum(0x8C87)
  GL_PRIMITIVES_GENERATED_OES*: GLenum = GLenum(0x8C87)
  GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN*: GLenum = GLenum(0x8C88)
  GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_EXT*: GLenum = GLenum(0x8C88)
  GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV*: GLenum = GLenum(0x8C88)
  GL_RASTERIZER_DISCARD*: GLenum = GLenum(0x8C89)
  GL_RASTERIZER_DISCARD_EXT*: GLenum = GLenum(0x8C89)
  GL_RASTERIZER_DISCARD_NV*: GLenum = GLenum(0x8C89)
  GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS*: GLenum = GLenum(0x8C8A)
  GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_EXT*: GLenum = GLenum(0x8C8A)
  GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_NV*: GLenum = GLenum(0x8C8A)
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS*: GLenum = GLenum(0x8C8B)
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_EXT*: GLenum = GLenum(0x8C8B)
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_NV*: GLenum = GLenum(0x8C8B)
  GL_INTERLEAVED_ATTRIBS*: GLenum = GLenum(0x8C8C)
  GL_INTERLEAVED_ATTRIBS_EXT*: GLenum = GLenum(0x8C8C)
  GL_INTERLEAVED_ATTRIBS_NV*: GLenum = GLenum(0x8C8C)
  GL_SEPARATE_ATTRIBS*: GLenum = GLenum(0x8C8D)
  GL_SEPARATE_ATTRIBS_EXT*: GLenum = GLenum(0x8C8D)
  GL_SEPARATE_ATTRIBS_NV*: GLenum = GLenum(0x8C8D)
  GL_TRANSFORM_FEEDBACK_BUFFER*: GLenum = GLenum(0x8C8E)
  GL_TRANSFORM_FEEDBACK_BUFFER_EXT*: GLenum = GLenum(0x8C8E)
  GL_TRANSFORM_FEEDBACK_BUFFER_NV*: GLenum = GLenum(0x8C8E)
  GL_TRANSFORM_FEEDBACK_BUFFER_BINDING*: GLenum = GLenum(0x8C8F)
  GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_EXT*: GLenum = GLenum(0x8C8F)
  GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_NV*: GLenum = GLenum(0x8C8F)
  GL_ATC_RGB_AMD*: GLenum = GLenum(0x8C92)
  GL_ATC_RGBA_EXPLICIT_ALPHA_AMD*: GLenum = GLenum(0x8C93)
  GL_POINT_SPRITE_COORD_ORIGIN*: GLenum = GLenum(0x8CA0)
  GL_LOWER_LEFT*: GLenum = GLenum(0x8CA1)
  GL_LOWER_LEFT_EXT*: GLenum = GLenum(0x8CA1)
  GL_UPPER_LEFT*: GLenum = GLenum(0x8CA2)
  GL_UPPER_LEFT_EXT*: GLenum = GLenum(0x8CA2)
  GL_STENCIL_BACK_REF*: GLenum = GLenum(0x8CA3)
  GL_STENCIL_BACK_VALUE_MASK*: GLenum = GLenum(0x8CA4)
  GL_STENCIL_BACK_WRITEMASK*: GLenum = GLenum(0x8CA5)
  GL_DRAW_FRAMEBUFFER_BINDING*: GLenum = GLenum(0x8CA6)
  GL_DRAW_FRAMEBUFFER_BINDING_ANGLE*: GLenum = GLenum(0x8CA6)
  GL_DRAW_FRAMEBUFFER_BINDING_APPLE*: GLenum = GLenum(0x8CA6)
  GL_DRAW_FRAMEBUFFER_BINDING_EXT*: GLenum = GLenum(0x8CA6)
  GL_DRAW_FRAMEBUFFER_BINDING_NV*: GLenum = GLenum(0x8CA6)
  GL_FRAMEBUFFER_BINDING*: GLenum = GLenum(0x8CA6)
  GL_FRAMEBUFFER_BINDING_ANGLE*: GLenum = GLenum(0x8CA6)
  GL_FRAMEBUFFER_BINDING_EXT*: GLenum = GLenum(0x8CA6)
  GL_FRAMEBUFFER_BINDING_OES*: GLenum = GLenum(0x8CA6)
  GL_RENDERBUFFER_BINDING*: GLenum = GLenum(0x8CA7)
  GL_RENDERBUFFER_BINDING_ANGLE*: GLenum = GLenum(0x8CA7)
  GL_RENDERBUFFER_BINDING_EXT*: GLenum = GLenum(0x8CA7)
  GL_RENDERBUFFER_BINDING_OES*: GLenum = GLenum(0x8CA7)
  GL_READ_FRAMEBUFFER*: GLenum = GLenum(0x8CA8)
  GL_READ_FRAMEBUFFER_ANGLE*: GLenum = GLenum(0x8CA8)
  GL_READ_FRAMEBUFFER_APPLE*: GLenum = GLenum(0x8CA8)
  GL_READ_FRAMEBUFFER_EXT*: GLenum = GLenum(0x8CA8)
  GL_READ_FRAMEBUFFER_NV*: GLenum = GLenum(0x8CA8)
  GL_DRAW_FRAMEBUFFER*: GLenum = GLenum(0x8CA9)
  GL_DRAW_FRAMEBUFFER_ANGLE*: GLenum = GLenum(0x8CA9)
  GL_DRAW_FRAMEBUFFER_APPLE*: GLenum = GLenum(0x8CA9)
  GL_DRAW_FRAMEBUFFER_EXT*: GLenum = GLenum(0x8CA9)
  GL_DRAW_FRAMEBUFFER_NV*: GLenum = GLenum(0x8CA9)
  GL_READ_FRAMEBUFFER_BINDING*: GLenum = GLenum(0x8CAA)
  GL_READ_FRAMEBUFFER_BINDING_ANGLE*: GLenum = GLenum(0x8CAA)
  GL_READ_FRAMEBUFFER_BINDING_APPLE*: GLenum = GLenum(0x8CAA)
  GL_READ_FRAMEBUFFER_BINDING_EXT*: GLenum = GLenum(0x8CAA)
  GL_READ_FRAMEBUFFER_BINDING_NV*: GLenum = GLenum(0x8CAA)
  GL_RENDERBUFFER_COVERAGE_SAMPLES_NV*: GLenum = GLenum(0x8CAB)
  GL_RENDERBUFFER_SAMPLES*: GLenum = GLenum(0x8CAB)
  GL_RENDERBUFFER_SAMPLES_ANGLE*: GLenum = GLenum(0x8CAB)
  GL_RENDERBUFFER_SAMPLES_APPLE*: GLenum = GLenum(0x8CAB)
  GL_RENDERBUFFER_SAMPLES_EXT*: GLenum = GLenum(0x8CAB)
  GL_RENDERBUFFER_SAMPLES_NV*: GLenum = GLenum(0x8CAB)
  GL_DEPTH_COMPONENT32F*: GLenum = GLenum(0x8CAC)
  GL_DEPTH32F_STENCIL8*: GLenum = GLenum(0x8CAD)
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE*: GLenum = GLenum(0x8CD0)
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT*: GLenum = GLenum(0x8CD0)
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_OES*: GLenum = GLenum(0x8CD0)
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME*: GLenum = GLenum(0x8CD1)
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT*: GLenum = GLenum(0x8CD1)
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_OES*: GLenum = GLenum(0x8CD1)
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL*: GLenum = GLenum(0x8CD2)
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT*: GLenum = GLenum(0x8CD2)
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_OES*: GLenum = GLenum(0x8CD2)
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE*: GLenum = GLenum(0x8CD3)
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT*: GLenum = GLenum(0x8CD3)
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_OES*: GLenum = GLenum(0x8CD3)
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT*: GLenum = GLenum(0x8CD4)
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES*: GLenum = GLenum(0x8CD4)
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER*: GLenum = GLenum(0x8CD4)
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT*: GLenum = GLenum(0x8CD4)
  GL_FRAMEBUFFER_COMPLETE*: GLenum = GLenum(0x8CD5)
  GL_FRAMEBUFFER_COMPLETE_EXT*: GLenum = GLenum(0x8CD5)
  GL_FRAMEBUFFER_COMPLETE_OES*: GLenum = GLenum(0x8CD5)
  GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT*: GLenum = GLenum(0x8CD6)
  GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT*: GLenum = GLenum(0x8CD6)
  GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_OES*: GLenum = GLenum(0x8CD6)
  GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT*: GLenum = GLenum(0x8CD7)
  GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT*: GLenum = GLenum(0x8CD7)
  GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_OES*: GLenum = GLenum(0x8CD7)
  GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS*: GLenum = GLenum(0x8CD9)
  GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT*: GLenum = GLenum(0x8CD9)
  GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_OES*: GLenum = GLenum(0x8CD9)
  GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT*: GLenum = GLenum(0x8CDA)
  GL_FRAMEBUFFER_INCOMPLETE_FORMATS_OES*: GLenum = GLenum(0x8CDA)
  GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER*: GLenum = GLenum(0x8CDB)
  GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT*: GLenum = GLenum(0x8CDB)
  GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_OES*: GLenum = GLenum(0x8CDB)
  GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER*: GLenum = GLenum(0x8CDC)
  GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT*: GLenum = GLenum(0x8CDC)
  GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_OES*: GLenum = GLenum(0x8CDC)
  GL_FRAMEBUFFER_UNSUPPORTED*: GLenum = GLenum(0x8CDD)
  GL_FRAMEBUFFER_UNSUPPORTED_EXT*: GLenum = GLenum(0x8CDD)
  GL_FRAMEBUFFER_UNSUPPORTED_OES*: GLenum = GLenum(0x8CDD)
  GL_MAX_COLOR_ATTACHMENTS*: GLenum = GLenum(0x8CDF)
  GL_MAX_COLOR_ATTACHMENTS_EXT*: GLenum = GLenum(0x8CDF)
  GL_MAX_COLOR_ATTACHMENTS_NV*: GLenum = GLenum(0x8CDF)
  GL_COLOR_ATTACHMENT0*: GLenum = GLenum(0x8CE0)
  GL_COLOR_ATTACHMENT0_EXT*: GLenum = GLenum(0x8CE0)
  GL_COLOR_ATTACHMENT0_NV*: GLenum = GLenum(0x8CE0)
  GL_COLOR_ATTACHMENT0_OES*: GLenum = GLenum(0x8CE0)
  GL_COLOR_ATTACHMENT1*: GLenum = GLenum(0x8CE1)
  GL_COLOR_ATTACHMENT1_EXT*: GLenum = GLenum(0x8CE1)
  GL_COLOR_ATTACHMENT1_NV*: GLenum = GLenum(0x8CE1)
  GL_COLOR_ATTACHMENT2*: GLenum = GLenum(0x8CE2)
  GL_COLOR_ATTACHMENT2_EXT*: GLenum = GLenum(0x8CE2)
  GL_COLOR_ATTACHMENT2_NV*: GLenum = GLenum(0x8CE2)
  GL_COLOR_ATTACHMENT3*: GLenum = GLenum(0x8CE3)
  GL_COLOR_ATTACHMENT3_EXT*: GLenum = GLenum(0x8CE3)
  GL_COLOR_ATTACHMENT3_NV*: GLenum = GLenum(0x8CE3)
  GL_COLOR_ATTACHMENT4*: GLenum = GLenum(0x8CE4)
  GL_COLOR_ATTACHMENT4_EXT*: GLenum = GLenum(0x8CE4)
  GL_COLOR_ATTACHMENT4_NV*: GLenum = GLenum(0x8CE4)
  GL_COLOR_ATTACHMENT5*: GLenum = GLenum(0x8CE5)
  GL_COLOR_ATTACHMENT5_EXT*: GLenum = GLenum(0x8CE5)
  GL_COLOR_ATTACHMENT5_NV*: GLenum = GLenum(0x8CE5)
  GL_COLOR_ATTACHMENT6*: GLenum = GLenum(0x8CE6)
  GL_COLOR_ATTACHMENT6_EXT*: GLenum = GLenum(0x8CE6)
  GL_COLOR_ATTACHMENT6_NV*: GLenum = GLenum(0x8CE6)
  GL_COLOR_ATTACHMENT7*: GLenum = GLenum(0x8CE7)
  GL_COLOR_ATTACHMENT7_EXT*: GLenum = GLenum(0x8CE7)
  GL_COLOR_ATTACHMENT7_NV*: GLenum = GLenum(0x8CE7)
  GL_COLOR_ATTACHMENT8*: GLenum = GLenum(0x8CE8)
  GL_COLOR_ATTACHMENT8_EXT*: GLenum = GLenum(0x8CE8)
  GL_COLOR_ATTACHMENT8_NV*: GLenum = GLenum(0x8CE8)
  GL_COLOR_ATTACHMENT9*: GLenum = GLenum(0x8CE9)
  GL_COLOR_ATTACHMENT9_EXT*: GLenum = GLenum(0x8CE9)
  GL_COLOR_ATTACHMENT9_NV*: GLenum = GLenum(0x8CE9)
  GL_COLOR_ATTACHMENT10*: GLenum = GLenum(0x8CEA)
  GL_COLOR_ATTACHMENT10_EXT*: GLenum = GLenum(0x8CEA)
  GL_COLOR_ATTACHMENT10_NV*: GLenum = GLenum(0x8CEA)
  GL_COLOR_ATTACHMENT11*: GLenum = GLenum(0x8CEB)
  GL_COLOR_ATTACHMENT11_EXT*: GLenum = GLenum(0x8CEB)
  GL_COLOR_ATTACHMENT11_NV*: GLenum = GLenum(0x8CEB)
  GL_COLOR_ATTACHMENT12*: GLenum = GLenum(0x8CEC)
  GL_COLOR_ATTACHMENT12_EXT*: GLenum = GLenum(0x8CEC)
  GL_COLOR_ATTACHMENT12_NV*: GLenum = GLenum(0x8CEC)
  GL_COLOR_ATTACHMENT13*: GLenum = GLenum(0x8CED)
  GL_COLOR_ATTACHMENT13_EXT*: GLenum = GLenum(0x8CED)
  GL_COLOR_ATTACHMENT13_NV*: GLenum = GLenum(0x8CED)
  GL_COLOR_ATTACHMENT14*: GLenum = GLenum(0x8CEE)
  GL_COLOR_ATTACHMENT14_EXT*: GLenum = GLenum(0x8CEE)
  GL_COLOR_ATTACHMENT14_NV*: GLenum = GLenum(0x8CEE)
  GL_COLOR_ATTACHMENT15*: GLenum = GLenum(0x8CEF)
  GL_COLOR_ATTACHMENT15_EXT*: GLenum = GLenum(0x8CEF)
  GL_COLOR_ATTACHMENT15_NV*: GLenum = GLenum(0x8CEF)
  GL_COLOR_ATTACHMENT16*: GLenum = GLenum(0x8CF0)
  GL_COLOR_ATTACHMENT17*: GLenum = GLenum(0x8CF1)
  GL_COLOR_ATTACHMENT18*: GLenum = GLenum(0x8CF2)
  GL_COLOR_ATTACHMENT19*: GLenum = GLenum(0x8CF3)
  GL_COLOR_ATTACHMENT20*: GLenum = GLenum(0x8CF4)
  GL_COLOR_ATTACHMENT21*: GLenum = GLenum(0x8CF5)
  GL_COLOR_ATTACHMENT22*: GLenum = GLenum(0x8CF6)
  GL_COLOR_ATTACHMENT23*: GLenum = GLenum(0x8CF7)
  GL_COLOR_ATTACHMENT24*: GLenum = GLenum(0x8CF8)
  GL_COLOR_ATTACHMENT25*: GLenum = GLenum(0x8CF9)
  GL_COLOR_ATTACHMENT26*: GLenum = GLenum(0x8CFA)
  GL_COLOR_ATTACHMENT27*: GLenum = GLenum(0x8CFB)
  GL_COLOR_ATTACHMENT28*: GLenum = GLenum(0x8CFC)
  GL_COLOR_ATTACHMENT29*: GLenum = GLenum(0x8CFD)
  GL_COLOR_ATTACHMENT30*: GLenum = GLenum(0x8CFE)
  GL_COLOR_ATTACHMENT31*: GLenum = GLenum(0x8CFF)
  GL_DEPTH_ATTACHMENT*: GLenum = GLenum(0x8D00)
  GL_DEPTH_ATTACHMENT_EXT*: GLenum = GLenum(0x8D00)
  GL_DEPTH_ATTACHMENT_OES*: GLenum = GLenum(0x8D00)
  GL_STENCIL_ATTACHMENT*: GLenum = GLenum(0x8D20)
  GL_STENCIL_ATTACHMENT_EXT*: GLenum = GLenum(0x8D20)
  GL_STENCIL_ATTACHMENT_OES*: GLenum = GLenum(0x8D20)
  GL_FRAMEBUFFER*: GLenum = GLenum(0x8D40)
  GL_FRAMEBUFFER_EXT*: GLenum = GLenum(0x8D40)
  GL_FRAMEBUFFER_OES*: GLenum = GLenum(0x8D40)
  GL_RENDERBUFFER*: GLenum = GLenum(0x8D41)
  GL_RENDERBUFFER_EXT*: GLenum = GLenum(0x8D41)
  GL_RENDERBUFFER_OES*: GLenum = GLenum(0x8D41)
  GL_RENDERBUFFER_WIDTH*: GLenum = GLenum(0x8D42)
  GL_RENDERBUFFER_WIDTH_EXT*: GLenum = GLenum(0x8D42)
  GL_RENDERBUFFER_WIDTH_OES*: GLenum = GLenum(0x8D42)
  GL_RENDERBUFFER_HEIGHT*: GLenum = GLenum(0x8D43)
  GL_RENDERBUFFER_HEIGHT_EXT*: GLenum = GLenum(0x8D43)
  GL_RENDERBUFFER_HEIGHT_OES*: GLenum = GLenum(0x8D43)
  GL_RENDERBUFFER_INTERNAL_FORMAT*: GLenum = GLenum(0x8D44)
  GL_RENDERBUFFER_INTERNAL_FORMAT_EXT*: GLenum = GLenum(0x8D44)
  GL_RENDERBUFFER_INTERNAL_FORMAT_OES*: GLenum = GLenum(0x8D44)
  GL_STENCIL_INDEX1*: GLenum = GLenum(0x8D46)
  GL_STENCIL_INDEX1_EXT*: GLenum = GLenum(0x8D46)
  GL_STENCIL_INDEX1_OES*: GLenum = GLenum(0x8D46)
  GL_STENCIL_INDEX4*: GLenum = GLenum(0x8D47)
  GL_STENCIL_INDEX4_EXT*: GLenum = GLenum(0x8D47)
  GL_STENCIL_INDEX4_OES*: GLenum = GLenum(0x8D47)
  GL_STENCIL_INDEX8*: GLenum = GLenum(0x8D48)
  GL_STENCIL_INDEX8_EXT*: GLenum = GLenum(0x8D48)
  GL_STENCIL_INDEX8_OES*: GLenum = GLenum(0x8D48)
  GL_STENCIL_INDEX16*: GLenum = GLenum(0x8D49)
  GL_STENCIL_INDEX16_EXT*: GLenum = GLenum(0x8D49)
  GL_RENDERBUFFER_RED_SIZE*: GLenum = GLenum(0x8D50)
  GL_RENDERBUFFER_RED_SIZE_EXT*: GLenum = GLenum(0x8D50)
  GL_RENDERBUFFER_RED_SIZE_OES*: GLenum = GLenum(0x8D50)
  GL_RENDERBUFFER_GREEN_SIZE*: GLenum = GLenum(0x8D51)
  GL_RENDERBUFFER_GREEN_SIZE_EXT*: GLenum = GLenum(0x8D51)
  GL_RENDERBUFFER_GREEN_SIZE_OES*: GLenum = GLenum(0x8D51)
  GL_RENDERBUFFER_BLUE_SIZE*: GLenum = GLenum(0x8D52)
  GL_RENDERBUFFER_BLUE_SIZE_EXT*: GLenum = GLenum(0x8D52)
  GL_RENDERBUFFER_BLUE_SIZE_OES*: GLenum = GLenum(0x8D52)
  GL_RENDERBUFFER_ALPHA_SIZE*: GLenum = GLenum(0x8D53)
  GL_RENDERBUFFER_ALPHA_SIZE_EXT*: GLenum = GLenum(0x8D53)
  GL_RENDERBUFFER_ALPHA_SIZE_OES*: GLenum = GLenum(0x8D53)
  GL_RENDERBUFFER_DEPTH_SIZE*: GLenum = GLenum(0x8D54)
  GL_RENDERBUFFER_DEPTH_SIZE_EXT*: GLenum = GLenum(0x8D54)
  GL_RENDERBUFFER_DEPTH_SIZE_OES*: GLenum = GLenum(0x8D54)
  GL_RENDERBUFFER_STENCIL_SIZE*: GLenum = GLenum(0x8D55)
  GL_RENDERBUFFER_STENCIL_SIZE_EXT*: GLenum = GLenum(0x8D55)
  GL_RENDERBUFFER_STENCIL_SIZE_OES*: GLenum = GLenum(0x8D55)
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE*: GLenum = GLenum(0x8D56)
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE*: GLenum = GLenum(0x8D56)
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_APPLE*: GLenum = GLenum(0x8D56)
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT*: GLenum = GLenum(0x8D56)
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_NV*: GLenum = GLenum(0x8D56)
  GL_MAX_SAMPLES*: GLenum = GLenum(0x8D57)
  GL_MAX_SAMPLES_ANGLE*: GLenum = GLenum(0x8D57)
  GL_MAX_SAMPLES_APPLE*: GLenum = GLenum(0x8D57)
  GL_MAX_SAMPLES_EXT*: GLenum = GLenum(0x8D57)
  GL_MAX_SAMPLES_NV*: GLenum = GLenum(0x8D57)
  GL_TEXTURE_GEN_STR_OES*: GLenum = GLenum(0x8D60)
  GL_HALF_FLOAT_OES*: GLenum = GLenum(0x8D61)
  GL_RGB565_OES*: GLenum = GLenum(0x8D62)
  GL_RGB565*: GLenum = GLenum(0x8D62)
  GL_ETC1_RGB8_OES*: GLenum = GLenum(0x8D64)
  GL_TEXTURE_EXTERNAL_OES*: GLenum = GLenum(0x8D65)
  GL_SAMPLER_EXTERNAL_OES*: GLenum = GLenum(0x8D66)
  GL_TEXTURE_BINDING_EXTERNAL_OES*: GLenum = GLenum(0x8D67)
  GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES*: GLenum = GLenum(0x8D68)
  GL_PRIMITIVE_RESTART_FIXED_INDEX*: GLenum = GLenum(0x8D69)
  GL_ANY_SAMPLES_PASSED_CONSERVATIVE*: GLenum = GLenum(0x8D6A)
  GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT*: GLenum = GLenum(0x8D6A)
  GL_MAX_ELEMENT_INDEX*: GLenum = GLenum(0x8D6B)
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT*: GLenum = GLenum(0x8D6C)
  GL_RGBA32UI*: GLenum = GLenum(0x8D70)
  GL_RGBA32UI_EXT*: GLenum = GLenum(0x8D70)
  GL_RGB32UI*: GLenum = GLenum(0x8D71)
  GL_RGB32UI_EXT*: GLenum = GLenum(0x8D71)
  GL_ALPHA32UI_EXT*: GLenum = GLenum(0x8D72)
  GL_INTENSITY32UI_EXT*: GLenum = GLenum(0x8D73)
  GL_LUMINANCE32UI_EXT*: GLenum = GLenum(0x8D74)
  GL_LUMINANCE_ALPHA32UI_EXT*: GLenum = GLenum(0x8D75)
  GL_RGBA16UI*: GLenum = GLenum(0x8D76)
  GL_RGBA16UI_EXT*: GLenum = GLenum(0x8D76)
  GL_RGB16UI*: GLenum = GLenum(0x8D77)
  GL_RGB16UI_EXT*: GLenum = GLenum(0x8D77)
  GL_ALPHA16UI_EXT*: GLenum = GLenum(0x8D78)
  GL_INTENSITY16UI_EXT*: GLenum = GLenum(0x8D79)
  GL_LUMINANCE16UI_EXT*: GLenum = GLenum(0x8D7A)
  GL_LUMINANCE_ALPHA16UI_EXT*: GLenum = GLenum(0x8D7B)
  GL_RGBA8UI*: GLenum = GLenum(0x8D7C)
  GL_RGBA8UI_EXT*: GLenum = GLenum(0x8D7C)
  GL_RGB8UI*: GLenum = GLenum(0x8D7D)
  GL_RGB8UI_EXT*: GLenum = GLenum(0x8D7D)
  GL_ALPHA8UI_EXT*: GLenum = GLenum(0x8D7E)
  GL_INTENSITY8UI_EXT*: GLenum = GLenum(0x8D7F)
  GL_LUMINANCE8UI_EXT*: GLenum = GLenum(0x8D80)
  GL_LUMINANCE_ALPHA8UI_EXT*: GLenum = GLenum(0x8D81)
  GL_RGBA32I*: GLenum = GLenum(0x8D82)
  GL_RGBA32I_EXT*: GLenum = GLenum(0x8D82)
  GL_RGB32I*: GLenum = GLenum(0x8D83)
  GL_RGB32I_EXT*: GLenum = GLenum(0x8D83)
  GL_ALPHA32I_EXT*: GLenum = GLenum(0x8D84)
  GL_INTENSITY32I_EXT*: GLenum = GLenum(0x8D85)
  GL_LUMINANCE32I_EXT*: GLenum = GLenum(0x8D86)
  GL_LUMINANCE_ALPHA32I_EXT*: GLenum = GLenum(0x8D87)
  GL_RGBA16I*: GLenum = GLenum(0x8D88)
  GL_RGBA16I_EXT*: GLenum = GLenum(0x8D88)
  GL_RGB16I*: GLenum = GLenum(0x8D89)
  GL_RGB16I_EXT*: GLenum = GLenum(0x8D89)
  GL_ALPHA16I_EXT*: GLenum = GLenum(0x8D8A)
  GL_INTENSITY16I_EXT*: GLenum = GLenum(0x8D8B)
  GL_LUMINANCE16I_EXT*: GLenum = GLenum(0x8D8C)
  GL_LUMINANCE_ALPHA16I_EXT*: GLenum = GLenum(0x8D8D)
  GL_RGBA8I*: GLenum = GLenum(0x8D8E)
  GL_RGBA8I_EXT*: GLenum = GLenum(0x8D8E)
  GL_RGB8I*: GLenum = GLenum(0x8D8F)
  GL_RGB8I_EXT*: GLenum = GLenum(0x8D8F)
  GL_ALPHA8I_EXT*: GLenum = GLenum(0x8D90)
  GL_INTENSITY8I_EXT*: GLenum = GLenum(0x8D91)
  GL_LUMINANCE8I_EXT*: GLenum = GLenum(0x8D92)
  GL_LUMINANCE_ALPHA8I_EXT*: GLenum = GLenum(0x8D93)
  GL_RED_INTEGER*: GLenum = GLenum(0x8D94)
  GL_RED_INTEGER_EXT*: GLenum = GLenum(0x8D94)
  GL_GREEN_INTEGER*: GLenum = GLenum(0x8D95)
  GL_GREEN_INTEGER_EXT*: GLenum = GLenum(0x8D95)
  GL_BLUE_INTEGER*: GLenum = GLenum(0x8D96)
  GL_BLUE_INTEGER_EXT*: GLenum = GLenum(0x8D96)
  GL_MESH_OUTPUT_PER_VERTEX_GRANULARITY_NV*: GLenum = GLenum(0x92DF)
  GL_ALPHA_INTEGER_EXT*: GLenum = GLenum(0x8D97)
  GL_RGB_INTEGER*: GLenum = GLenum(0x8D98)
  GL_RGB_INTEGER_EXT*: GLenum = GLenum(0x8D98)
  GL_RGBA_INTEGER*: GLenum = GLenum(0x8D99)
  GL_RGBA_INTEGER_EXT*: GLenum = GLenum(0x8D99)
  GL_BGR_INTEGER*: GLenum = GLenum(0x8D9A)
  GL_BGR_INTEGER_EXT*: GLenum = GLenum(0x8D9A)
  GL_BGRA_INTEGER*: GLenum = GLenum(0x8D9B)
  GL_BGRA_INTEGER_EXT*: GLenum = GLenum(0x8D9B)
  GL_LUMINANCE_INTEGER_EXT*: GLenum = GLenum(0x8D9C)
  GL_LUMINANCE_ALPHA_INTEGER_EXT*: GLenum = GLenum(0x8D9D)
  GL_RGBA_INTEGER_MODE_EXT*: GLenum = GLenum(0x8D9E)
  GL_INT_2_10_10_10_REV*: GLenum = GLenum(0x8D9F)
  GL_MAX_PROGRAM_PARAMETER_BUFFER_BINDINGS_NV*: GLenum = GLenum(0x8DA0)
  GL_MAX_PROGRAM_PARAMETER_BUFFER_SIZE_NV*: GLenum = GLenum(0x8DA1)
  GL_VERTEX_PROGRAM_PARAMETER_BUFFER_NV*: GLenum = GLenum(0x8DA2)
  GL_GEOMETRY_PROGRAM_PARAMETER_BUFFER_NV*: GLenum = GLenum(0x8DA3)
  GL_FRAGMENT_PROGRAM_PARAMETER_BUFFER_NV*: GLenum = GLenum(0x8DA4)
  GL_MAX_PROGRAM_GENERIC_ATTRIBS_NV*: GLenum = GLenum(0x8DA5)
  GL_MAX_PROGRAM_GENERIC_RESULTS_NV*: GLenum = GLenum(0x8DA6)
  GL_FRAMEBUFFER_ATTACHMENT_LAYERED*: GLenum = GLenum(0x8DA7)
  GL_FRAMEBUFFER_ATTACHMENT_LAYERED_ARB*: GLenum = GLenum(0x8DA7)
  GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT*: GLenum = GLenum(0x8DA7)
  GL_FRAMEBUFFER_ATTACHMENT_LAYERED_OES*: GLenum = GLenum(0x8DA7)
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS*: GLenum = GLenum(0x8DA8)
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_ARB*: GLenum = GLenum(0x8DA8)
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT*: GLenum = GLenum(0x8DA8)
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_OES*: GLenum = GLenum(0x8DA8)
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB*: GLenum = GLenum(0x8DA9)
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT*: GLenum = GLenum(0x8DA9)
  GL_LAYER_NV*: GLenum = GLenum(0x8DAA)
  GL_DEPTH_COMPONENT32F_NV*: GLenum = GLenum(0x8DAB)
  GL_DEPTH32F_STENCIL8_NV*: GLenum = GLenum(0x8DAC)
  GL_FLOAT_32_UNSIGNED_INT_24_8_REV*: GLenum = GLenum(0x8DAD)
  GL_FLOAT_32_UNSIGNED_INT_24_8_REV_NV*: GLenum = GLenum(0x8DAD)
  GL_SHADER_INCLUDE_ARB*: GLenum = GLenum(0x8DAE)
  GL_DEPTH_BUFFER_FLOAT_MODE_NV*: GLenum = GLenum(0x8DAF)
  GL_FRAMEBUFFER_SRGB*: GLenum = GLenum(0x8DB9)
  GL_FRAMEBUFFER_SRGB_EXT*: GLenum = GLenum(0x8DB9)
  GL_FRAMEBUFFER_SRGB_CAPABLE_EXT*: GLenum = GLenum(0x8DBA)
  GL_COMPRESSED_RED_RGTC1*: GLenum = GLenum(0x8DBB)
  GL_COMPRESSED_RED_RGTC1_EXT*: GLenum = GLenum(0x8DBB)
  GL_COMPRESSED_SIGNED_RED_RGTC1*: GLenum = GLenum(0x8DBC)
  GL_COMPRESSED_SIGNED_RED_RGTC1_EXT*: GLenum = GLenum(0x8DBC)
  GL_COMPRESSED_RED_GREEN_RGTC2_EXT*: GLenum = GLenum(0x8DBD)
  GL_COMPRESSED_RG_RGTC2*: GLenum = GLenum(0x8DBD)
  GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT*: GLenum = GLenum(0x8DBE)
  GL_COMPRESSED_SIGNED_RG_RGTC2*: GLenum = GLenum(0x8DBE)
  GL_SAMPLER_1D_ARRAY*: GLenum = GLenum(0x8DC0)
  GL_SAMPLER_1D_ARRAY_EXT*: GLenum = GLenum(0x8DC0)
  GL_SAMPLER_2D_ARRAY*: GLenum = GLenum(0x8DC1)
  GL_SAMPLER_2D_ARRAY_EXT*: GLenum = GLenum(0x8DC1)
  GL_SAMPLER_BUFFER*: GLenum = GLenum(0x8DC2)
  GL_SAMPLER_BUFFER_EXT*: GLenum = GLenum(0x8DC2)
  GL_SAMPLER_BUFFER_OES*: GLenum = GLenum(0x8DC2)
  GL_SAMPLER_1D_ARRAY_SHADOW*: GLenum = GLenum(0x8DC3)
  GL_SAMPLER_1D_ARRAY_SHADOW_EXT*: GLenum = GLenum(0x8DC3)
  GL_SAMPLER_2D_ARRAY_SHADOW*: GLenum = GLenum(0x8DC4)
  GL_SAMPLER_2D_ARRAY_SHADOW_EXT*: GLenum = GLenum(0x8DC4)
  GL_SAMPLER_2D_ARRAY_SHADOW_NV*: GLenum = GLenum(0x8DC4)
  GL_SAMPLER_CUBE_SHADOW*: GLenum = GLenum(0x8DC5)
  GL_SAMPLER_CUBE_SHADOW_EXT*: GLenum = GLenum(0x8DC5)
  GL_SAMPLER_CUBE_SHADOW_NV*: GLenum = GLenum(0x8DC5)
  GL_UNSIGNED_INT_VEC2*: GLenum = GLenum(0x8DC6)
  GL_UNSIGNED_INT_VEC2_EXT*: GLenum = GLenum(0x8DC6)
  GL_UNSIGNED_INT_VEC3*: GLenum = GLenum(0x8DC7)
  GL_UNSIGNED_INT_VEC3_EXT*: GLenum = GLenum(0x8DC7)
  GL_UNSIGNED_INT_VEC4*: GLenum = GLenum(0x8DC8)
  GL_UNSIGNED_INT_VEC4_EXT*: GLenum = GLenum(0x8DC8)
  GL_INT_SAMPLER_1D*: GLenum = GLenum(0x8DC9)
  GL_INT_SAMPLER_1D_EXT*: GLenum = GLenum(0x8DC9)
  GL_INT_SAMPLER_2D*: GLenum = GLenum(0x8DCA)
  GL_INT_SAMPLER_2D_EXT*: GLenum = GLenum(0x8DCA)
  GL_INT_SAMPLER_3D*: GLenum = GLenum(0x8DCB)
  GL_INT_SAMPLER_3D_EXT*: GLenum = GLenum(0x8DCB)
  GL_INT_SAMPLER_CUBE*: GLenum = GLenum(0x8DCC)
  GL_INT_SAMPLER_CUBE_EXT*: GLenum = GLenum(0x8DCC)
  GL_INT_SAMPLER_2D_RECT*: GLenum = GLenum(0x8DCD)
  GL_INT_SAMPLER_2D_RECT_EXT*: GLenum = GLenum(0x8DCD)
  GL_INT_SAMPLER_1D_ARRAY*: GLenum = GLenum(0x8DCE)
  GL_INT_SAMPLER_1D_ARRAY_EXT*: GLenum = GLenum(0x8DCE)
  GL_INT_SAMPLER_2D_ARRAY*: GLenum = GLenum(0x8DCF)
  GL_INT_SAMPLER_2D_ARRAY_EXT*: GLenum = GLenum(0x8DCF)
  GL_INT_SAMPLER_BUFFER*: GLenum = GLenum(0x8DD0)
  GL_INT_SAMPLER_BUFFER_EXT*: GLenum = GLenum(0x8DD0)
  GL_INT_SAMPLER_BUFFER_OES*: GLenum = GLenum(0x8DD0)
  GL_UNSIGNED_INT_SAMPLER_1D*: GLenum = GLenum(0x8DD1)
  GL_UNSIGNED_INT_SAMPLER_1D_EXT*: GLenum = GLenum(0x8DD1)
  GL_UNSIGNED_INT_SAMPLER_2D*: GLenum = GLenum(0x8DD2)
  GL_UNSIGNED_INT_SAMPLER_2D_EXT*: GLenum = GLenum(0x8DD2)
  GL_UNSIGNED_INT_SAMPLER_3D*: GLenum = GLenum(0x8DD3)
  GL_UNSIGNED_INT_SAMPLER_3D_EXT*: GLenum = GLenum(0x8DD3)
  GL_UNSIGNED_INT_SAMPLER_CUBE*: GLenum = GLenum(0x8DD4)
  GL_UNSIGNED_INT_SAMPLER_CUBE_EXT*: GLenum = GLenum(0x8DD4)
  GL_UNSIGNED_INT_SAMPLER_2D_RECT*: GLenum = GLenum(0x8DD5)
  GL_UNSIGNED_INT_SAMPLER_2D_RECT_EXT*: GLenum = GLenum(0x8DD5)
  GL_UNSIGNED_INT_SAMPLER_1D_ARRAY*: GLenum = GLenum(0x8DD6)
  GL_UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT*: GLenum = GLenum(0x8DD6)
  GL_UNSIGNED_INT_SAMPLER_2D_ARRAY*: GLenum = GLenum(0x8DD7)
  GL_UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT*: GLenum = GLenum(0x8DD7)
  GL_UNSIGNED_INT_SAMPLER_BUFFER*: GLenum = GLenum(0x8DD8)
  GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT*: GLenum = GLenum(0x8DD8)
  GL_UNSIGNED_INT_SAMPLER_BUFFER_OES*: GLenum = GLenum(0x8DD8)
  GL_GEOMETRY_SHADER*: GLenum = GLenum(0x8DD9)
  GL_GEOMETRY_SHADER_ARB*: GLenum = GLenum(0x8DD9)
  GL_GEOMETRY_SHADER_EXT*: GLenum = GLenum(0x8DD9)
  GL_GEOMETRY_SHADER_OES*: GLenum = GLenum(0x8DD9)
  GL_GEOMETRY_VERTICES_OUT_ARB*: GLenum = GLenum(0x8DDA)
  GL_GEOMETRY_VERTICES_OUT_EXT*: GLenum = GLenum(0x8DDA)
  GL_GEOMETRY_INPUT_TYPE_ARB*: GLenum = GLenum(0x8DDB)
  GL_GEOMETRY_INPUT_TYPE_EXT*: GLenum = GLenum(0x8DDB)
  GL_GEOMETRY_OUTPUT_TYPE_ARB*: GLenum = GLenum(0x8DDC)
  GL_GEOMETRY_OUTPUT_TYPE_EXT*: GLenum = GLenum(0x8DDC)
  GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB*: GLenum = GLenum(0x8DDD)
  GL_MAX_GEOMETRY_VARYING_COMPONENTS_EXT*: GLenum = GLenum(0x8DDD)
  GL_MAX_VERTEX_VARYING_COMPONENTS_ARB*: GLenum = GLenum(0x8DDE)
  GL_MAX_VERTEX_VARYING_COMPONENTS_EXT*: GLenum = GLenum(0x8DDE)
  GL_MAX_GEOMETRY_UNIFORM_COMPONENTS*: GLenum = GLenum(0x8DDF)
  GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB*: GLenum = GLenum(0x8DDF)
  GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT*: GLenum = GLenum(0x8DDF)
  GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_OES*: GLenum = GLenum(0x8DDF)
  GL_MAX_GEOMETRY_OUTPUT_VERTICES*: GLenum = GLenum(0x8DE0)
  GL_MAX_GEOMETRY_OUTPUT_VERTICES_ARB*: GLenum = GLenum(0x8DE0)
  GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT*: GLenum = GLenum(0x8DE0)
  GL_MAX_GEOMETRY_OUTPUT_VERTICES_OES*: GLenum = GLenum(0x8DE0)
  GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS*: GLenum = GLenum(0x8DE1)
  GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB*: GLenum = GLenum(0x8DE1)
  GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT*: GLenum = GLenum(0x8DE1)
  GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_OES*: GLenum = GLenum(0x8DE1)
  GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT*: GLenum = GLenum(0x8DE2)
  GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT*: GLenum = GLenum(0x8DE3)
  GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT*: GLenum = GLenum(0x8DE4)
  GL_ACTIVE_SUBROUTINES*: GLenum = GLenum(0x8DE5)
  GL_ACTIVE_SUBROUTINE_UNIFORMS*: GLenum = GLenum(0x8DE6)
  GL_MAX_SUBROUTINES*: GLenum = GLenum(0x8DE7)
  GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS*: GLenum = GLenum(0x8DE8)
  GL_NAMED_STRING_LENGTH_ARB*: GLenum = GLenum(0x8DE9)
  GL_NAMED_STRING_TYPE_ARB*: GLenum = GLenum(0x8DEA)
  GL_MAX_BINDABLE_UNIFORM_SIZE_EXT*: GLenum = GLenum(0x8DED)
  GL_UNIFORM_BUFFER_EXT*: GLenum = GLenum(0x8DEE)
  GL_UNIFORM_BUFFER_BINDING_EXT*: GLenum = GLenum(0x8DEF)
  GL_LOW_FLOAT*: GLenum = GLenum(0x8DF0)
  GL_MEDIUM_FLOAT*: GLenum = GLenum(0x8DF1)
  GL_HIGH_FLOAT*: GLenum = GLenum(0x8DF2)
  GL_LOW_INT*: GLenum = GLenum(0x8DF3)
  GL_MEDIUM_INT*: GLenum = GLenum(0x8DF4)
  GL_HIGH_INT*: GLenum = GLenum(0x8DF5)
  GL_UNSIGNED_INT_10_10_10_2_OES*: GLenum = GLenum(0x8DF6)
  GL_INT_10_10_10_2_OES*: GLenum = GLenum(0x8DF7)
  GL_SHADER_BINARY_FORMATS*: GLenum = GLenum(0x8DF8)
  GL_NUM_SHADER_BINARY_FORMATS*: GLenum = GLenum(0x8DF9)
  GL_SHADER_COMPILER*: GLenum = GLenum(0x8DFA)
  GL_MAX_VERTEX_UNIFORM_VECTORS*: GLenum = GLenum(0x8DFB)
  GL_MAX_VARYING_VECTORS*: GLenum = GLenum(0x8DFC)
  GL_MAX_FRAGMENT_UNIFORM_VECTORS*: GLenum = GLenum(0x8DFD)
  GL_RENDERBUFFER_COLOR_SAMPLES_NV*: GLenum = GLenum(0x8E10)
  GL_MAX_MULTISAMPLE_COVERAGE_MODES_NV*: GLenum = GLenum(0x8E11)
  GL_MULTISAMPLE_COVERAGE_MODES_NV*: GLenum = GLenum(0x8E12)
  GL_QUERY_WAIT*: GLenum = GLenum(0x8E13)
  GL_QUERY_WAIT_NV*: GLenum = GLenum(0x8E13)
  GL_QUERY_NO_WAIT*: GLenum = GLenum(0x8E14)
  GL_QUERY_NO_WAIT_NV*: GLenum = GLenum(0x8E14)
  GL_QUERY_BY_REGION_WAIT*: GLenum = GLenum(0x8E15)
  GL_QUERY_BY_REGION_WAIT_NV*: GLenum = GLenum(0x8E15)
  GL_QUERY_BY_REGION_NO_WAIT*: GLenum = GLenum(0x8E16)
  GL_QUERY_BY_REGION_NO_WAIT_NV*: GLenum = GLenum(0x8E16)
  GL_QUERY_WAIT_INVERTED*: GLenum = GLenum(0x8E17)
  GL_QUERY_NO_WAIT_INVERTED*: GLenum = GLenum(0x8E18)
  GL_QUERY_BY_REGION_WAIT_INVERTED*: GLenum = GLenum(0x8E19)
  GL_QUERY_BY_REGION_NO_WAIT_INVERTED*: GLenum = GLenum(0x8E1A)
  GL_POLYGON_OFFSET_CLAMP*: GLenum = GLenum(0x8E1B)
  GL_POLYGON_OFFSET_CLAMP_EXT*: GLenum = GLenum(0x8E1B)
  GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS*: GLenum = GLenum(0x8E1E)
  GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_EXT*: GLenum = GLenum(0x8E1E)
  GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_OES*: GLenum = GLenum(0x8E1E)
  GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS*: GLenum = GLenum(0x8E1F)
  GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT*: GLenum = GLenum(0x8E1F)
  GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_OES*: GLenum = GLenum(0x8E1F)
  GL_COLOR_SAMPLES_NV*: GLenum = GLenum(0x8E20)
  GL_TRANSFORM_FEEDBACK*: GLenum = GLenum(0x8E22)
  GL_TRANSFORM_FEEDBACK_NV*: GLenum = GLenum(0x8E22)
  GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED*: GLenum = GLenum(0x8E23)
  GL_TRANSFORM_FEEDBACK_PAUSED*: GLenum = GLenum(0x8E23)
  GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED_NV*: GLenum = GLenum(0x8E23)
  GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE*: GLenum = GLenum(0x8E24)
  GL_TRANSFORM_FEEDBACK_ACTIVE*: GLenum = GLenum(0x8E24)
  GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE_NV*: GLenum = GLenum(0x8E24)
  GL_TRANSFORM_FEEDBACK_BINDING*: GLenum = GLenum(0x8E25)
  GL_TRANSFORM_FEEDBACK_BINDING_NV*: GLenum = GLenum(0x8E25)
  GL_FRAME_NV*: GLenum = GLenum(0x8E26)
  GL_FIELDS_NV*: GLenum = GLenum(0x8E27)
  GL_CURRENT_TIME_NV*: GLenum = GLenum(0x8E28)
  GL_TIMESTAMP*: GLenum = GLenum(0x8E28)
  GL_TIMESTAMP_EXT*: GLenum = GLenum(0x8E28)
  GL_NUM_FILL_STREAMS_NV*: GLenum = GLenum(0x8E29)
  GL_PRESENT_TIME_NV*: GLenum = GLenum(0x8E2A)
  GL_PRESENT_DURATION_NV*: GLenum = GLenum(0x8E2B)
  GL_DEPTH_COMPONENT16_NONLINEAR_NV*: GLenum = GLenum(0x8E2C)
  GL_PROGRAM_MATRIX_EXT*: GLenum = GLenum(0x8E2D)
  GL_TRANSPOSE_PROGRAM_MATRIX_EXT*: GLenum = GLenum(0x8E2E)
  GL_PROGRAM_MATRIX_STACK_DEPTH_EXT*: GLenum = GLenum(0x8E2F)
  GL_TEXTURE_SWIZZLE_R*: GLenum = GLenum(0x8E42)
  GL_TEXTURE_SWIZZLE_R_EXT*: GLenum = GLenum(0x8E42)
  GL_TEXTURE_SWIZZLE_G*: GLenum = GLenum(0x8E43)
  GL_TEXTURE_SWIZZLE_G_EXT*: GLenum = GLenum(0x8E43)
  GL_TEXTURE_SWIZZLE_B*: GLenum = GLenum(0x8E44)
  GL_TEXTURE_SWIZZLE_B_EXT*: GLenum = GLenum(0x8E44)
  GL_TEXTURE_SWIZZLE_A*: GLenum = GLenum(0x8E45)
  GL_TEXTURE_SWIZZLE_A_EXT*: GLenum = GLenum(0x8E45)
  GL_TEXTURE_SWIZZLE_RGBA*: GLenum = GLenum(0x8E46)
  GL_TEXTURE_SWIZZLE_RGBA_EXT*: GLenum = GLenum(0x8E46)
  GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS*: GLenum = GLenum(0x8E47)
  GL_ACTIVE_SUBROUTINE_MAX_LENGTH*: GLenum = GLenum(0x8E48)
  GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH*: GLenum = GLenum(0x8E49)
  GL_NUM_COMPATIBLE_SUBROUTINES*: GLenum = GLenum(0x8E4A)
  GL_COMPATIBLE_SUBROUTINES*: GLenum = GLenum(0x8E4B)
  GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION*: GLenum = GLenum(0x8E4C)
  GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT*: GLenum = GLenum(0x8E4C)
  GL_FIRST_VERTEX_CONVENTION*: GLenum = GLenum(0x8E4D)
  GL_FIRST_VERTEX_CONVENTION_EXT*: GLenum = GLenum(0x8E4D)
  GL_FIRST_VERTEX_CONVENTION_OES*: GLenum = GLenum(0x8E4D)
  GL_LAST_VERTEX_CONVENTION*: GLenum = GLenum(0x8E4E)
  GL_LAST_VERTEX_CONVENTION_EXT*: GLenum = GLenum(0x8E4E)
  GL_LAST_VERTEX_CONVENTION_OES*: GLenum = GLenum(0x8E4E)
  GL_PROVOKING_VERTEX*: GLenum = GLenum(0x8E4F)
  GL_PROVOKING_VERTEX_EXT*: GLenum = GLenum(0x8E4F)
  GL_SAMPLE_POSITION*: GLenum = GLenum(0x8E50)
  GL_SAMPLE_POSITION_NV*: GLenum = GLenum(0x8E50)
  GL_SAMPLE_LOCATION_ARB*: GLenum = GLenum(0x8E50)
  GL_SAMPLE_LOCATION_NV*: GLenum = GLenum(0x8E50)
  GL_SAMPLE_MASK*: GLenum = GLenum(0x8E51)
  GL_SAMPLE_MASK_NV*: GLenum = GLenum(0x8E51)
  GL_SAMPLE_MASK_VALUE*: GLenum = GLenum(0x8E52)
  GL_SAMPLE_MASK_VALUE_NV*: GLenum = GLenum(0x8E52)
  GL_TEXTURE_BINDING_RENDERBUFFER_NV*: GLenum = GLenum(0x8E53)
  GL_TEXTURE_RENDERBUFFER_DATA_STORE_BINDING_NV*: GLenum = GLenum(0x8E54)
  GL_TEXTURE_RENDERBUFFER_NV*: GLenum = GLenum(0x8E55)
  GL_SAMPLER_RENDERBUFFER_NV*: GLenum = GLenum(0x8E56)
  GL_INT_SAMPLER_RENDERBUFFER_NV*: GLenum = GLenum(0x8E57)
  GL_UNSIGNED_INT_SAMPLER_RENDERBUFFER_NV*: GLenum = GLenum(0x8E58)
  GL_MAX_SAMPLE_MASK_WORDS*: GLenum = GLenum(0x8E59)
  GL_MAX_SAMPLE_MASK_WORDS_NV*: GLenum = GLenum(0x8E59)
  GL_MAX_GEOMETRY_PROGRAM_INVOCATIONS_NV*: GLenum = GLenum(0x8E5A)
  GL_MAX_GEOMETRY_SHADER_INVOCATIONS*: GLenum = GLenum(0x8E5A)
  GL_MAX_GEOMETRY_SHADER_INVOCATIONS_EXT*: GLenum = GLenum(0x8E5A)
  GL_MAX_GEOMETRY_SHADER_INVOCATIONS_OES*: GLenum = GLenum(0x8E5A)
  GL_MIN_FRAGMENT_INTERPOLATION_OFFSET*: GLenum = GLenum(0x8E5B)
  GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_OES*: GLenum = GLenum(0x8E5B)
  GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_NV*: GLenum = GLenum(0x8E5B)
  GL_MAX_FRAGMENT_INTERPOLATION_OFFSET*: GLenum = GLenum(0x8E5C)
  GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_OES*: GLenum = GLenum(0x8E5C)
  GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_NV*: GLenum = GLenum(0x8E5C)
  GL_FRAGMENT_INTERPOLATION_OFFSET_BITS*: GLenum = GLenum(0x8E5D)
  GL_FRAGMENT_INTERPOLATION_OFFSET_BITS_OES*: GLenum = GLenum(0x8E5D)
  GL_FRAGMENT_PROGRAM_INTERPOLATION_OFFSET_BITS_NV*: GLenum = GLenum(0x8E5D)
  GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET*: GLenum = GLenum(0x8E5E)
  GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB*: GLenum = GLenum(0x8E5E)
  GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_NV*: GLenum = GLenum(0x8E5E)
  GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET*: GLenum = GLenum(0x8E5F)
  GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB*: GLenum = GLenum(0x8E5F)
  GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_NV*: GLenum = GLenum(0x8E5F)
  GL_MAX_MESH_UNIFORM_BLOCKS_NV*: GLenum = GLenum(0x8E60)
  GL_MAX_MESH_TEXTURE_IMAGE_UNITS_NV*: GLenum = GLenum(0x8E61)
  GL_MAX_MESH_IMAGE_UNIFORMS_NV*: GLenum = GLenum(0x8E62)
  GL_MAX_MESH_UNIFORM_COMPONENTS_NV*: GLenum = GLenum(0x8E63)
  GL_MAX_MESH_ATOMIC_COUNTER_BUFFERS_NV*: GLenum = GLenum(0x8E64)
  GL_MAX_MESH_ATOMIC_COUNTERS_NV*: GLenum = GLenum(0x8E65)
  GL_MAX_MESH_SHADER_STORAGE_BLOCKS_NV*: GLenum = GLenum(0x8E66)
  GL_MAX_COMBINED_MESH_UNIFORM_COMPONENTS_NV*: GLenum = GLenum(0x8E67)
  GL_MAX_TASK_UNIFORM_BLOCKS_NV*: GLenum = GLenum(0x8E68)
  GL_MAX_TASK_TEXTURE_IMAGE_UNITS_NV*: GLenum = GLenum(0x8E69)
  GL_MAX_TASK_IMAGE_UNIFORMS_NV*: GLenum = GLenum(0x8E6A)
  GL_MAX_TASK_UNIFORM_COMPONENTS_NV*: GLenum = GLenum(0x8E6B)
  GL_MAX_TASK_ATOMIC_COUNTER_BUFFERS_NV*: GLenum = GLenum(0x8E6C)
  GL_MAX_TASK_ATOMIC_COUNTERS_NV*: GLenum = GLenum(0x8E6D)
  GL_MAX_TASK_SHADER_STORAGE_BLOCKS_NV*: GLenum = GLenum(0x8E6E)
  GL_MAX_COMBINED_TASK_UNIFORM_COMPONENTS_NV*: GLenum = GLenum(0x8E6F)
  GL_MAX_TRANSFORM_FEEDBACK_BUFFERS*: GLenum = GLenum(0x8E70)
  GL_MAX_VERTEX_STREAMS*: GLenum = GLenum(0x8E71)
  GL_PATCH_VERTICES*: GLenum = GLenum(0x8E72)
  GL_PATCH_VERTICES_EXT*: GLenum = GLenum(0x8E72)
  GL_PATCH_VERTICES_OES*: GLenum = GLenum(0x8E72)
  GL_PATCH_DEFAULT_INNER_LEVEL*: GLenum = GLenum(0x8E73)
  GL_PATCH_DEFAULT_INNER_LEVEL_EXT*: GLenum = GLenum(0x8E73)
  GL_PATCH_DEFAULT_OUTER_LEVEL*: GLenum = GLenum(0x8E74)
  GL_PATCH_DEFAULT_OUTER_LEVEL_EXT*: GLenum = GLenum(0x8E74)
  GL_TESS_CONTROL_OUTPUT_VERTICES*: GLenum = GLenum(0x8E75)
  GL_TESS_CONTROL_OUTPUT_VERTICES_EXT*: GLenum = GLenum(0x8E75)
  GL_TESS_CONTROL_OUTPUT_VERTICES_OES*: GLenum = GLenum(0x8E75)
  GL_TESS_GEN_MODE*: GLenum = GLenum(0x8E76)
  GL_TESS_GEN_MODE_EXT*: GLenum = GLenum(0x8E76)
  GL_TESS_GEN_MODE_OES*: GLenum = GLenum(0x8E76)
  GL_TESS_GEN_SPACING*: GLenum = GLenum(0x8E77)
  GL_TESS_GEN_SPACING_EXT*: GLenum = GLenum(0x8E77)
  GL_TESS_GEN_SPACING_OES*: GLenum = GLenum(0x8E77)
  GL_TESS_GEN_VERTEX_ORDER*: GLenum = GLenum(0x8E78)
  GL_TESS_GEN_VERTEX_ORDER_EXT*: GLenum = GLenum(0x8E78)
  GL_TESS_GEN_VERTEX_ORDER_OES*: GLenum = GLenum(0x8E78)
  GL_TESS_GEN_POINT_MODE*: GLenum = GLenum(0x8E79)
  GL_TESS_GEN_POINT_MODE_EXT*: GLenum = GLenum(0x8E79)
  GL_TESS_GEN_POINT_MODE_OES*: GLenum = GLenum(0x8E79)
  GL_ISOLINES*: GLenum = GLenum(0x8E7A)
  GL_ISOLINES_EXT*: GLenum = GLenum(0x8E7A)
  GL_ISOLINES_OES*: GLenum = GLenum(0x8E7A)
  GL_FRACTIONAL_ODD*: GLenum = GLenum(0x8E7B)
  GL_FRACTIONAL_ODD_EXT*: GLenum = GLenum(0x8E7B)
  GL_FRACTIONAL_ODD_OES*: GLenum = GLenum(0x8E7B)
  GL_FRACTIONAL_EVEN*: GLenum = GLenum(0x8E7C)
  GL_FRACTIONAL_EVEN_EXT*: GLenum = GLenum(0x8E7C)
  GL_FRACTIONAL_EVEN_OES*: GLenum = GLenum(0x8E7C)
  GL_MAX_PATCH_VERTICES*: GLenum = GLenum(0x8E7D)
  GL_MAX_PATCH_VERTICES_EXT*: GLenum = GLenum(0x8E7D)
  GL_MAX_PATCH_VERTICES_OES*: GLenum = GLenum(0x8E7D)
  GL_MAX_TESS_GEN_LEVEL*: GLenum = GLenum(0x8E7E)
  GL_MAX_TESS_GEN_LEVEL_EXT*: GLenum = GLenum(0x8E7E)
  GL_MAX_TESS_GEN_LEVEL_OES*: GLenum = GLenum(0x8E7E)
  GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS*: GLenum = GLenum(0x8E7F)
  GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_EXT*: GLenum = GLenum(0x8E7F)
  GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_OES*: GLenum = GLenum(0x8E7F)
  GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS*: GLenum = GLenum(0x8E80)
  GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT*: GLenum = GLenum(0x8E80)
  GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_OES*: GLenum = GLenum(0x8E80)
  GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS*: GLenum = GLenum(0x8E81)
  GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_EXT*: GLenum = GLenum(0x8E81)
  GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_OES*: GLenum = GLenum(0x8E81)
  GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS*: GLenum = GLenum(0x8E82)
  GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_EXT*: GLenum = GLenum(0x8E82)
  GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_OES*: GLenum = GLenum(0x8E82)
  GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS*: GLenum = GLenum(0x8E83)
  GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_EXT*: GLenum = GLenum(0x8E83)
  GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_OES*: GLenum = GLenum(0x8E83)
  GL_MAX_TESS_PATCH_COMPONENTS*: GLenum = GLenum(0x8E84)
  GL_MAX_TESS_PATCH_COMPONENTS_EXT*: GLenum = GLenum(0x8E84)
  GL_MAX_TESS_PATCH_COMPONENTS_OES*: GLenum = GLenum(0x8E84)
  GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS*: GLenum = GLenum(0x8E85)
  GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_EXT*: GLenum = GLenum(0x8E85)
  GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_OES*: GLenum = GLenum(0x8E85)
  GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS*: GLenum = GLenum(0x8E86)
  GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_EXT*: GLenum = GLenum(0x8E86)
  GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_OES*: GLenum = GLenum(0x8E86)
  GL_TESS_EVALUATION_SHADER*: GLenum = GLenum(0x8E87)
  GL_TESS_EVALUATION_SHADER_EXT*: GLenum = GLenum(0x8E87)
  GL_TESS_EVALUATION_SHADER_OES*: GLenum = GLenum(0x8E87)
  GL_TESS_CONTROL_SHADER*: GLenum = GLenum(0x8E88)
  GL_TESS_CONTROL_SHADER_EXT*: GLenum = GLenum(0x8E88)
  GL_TESS_CONTROL_SHADER_OES*: GLenum = GLenum(0x8E88)
  GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS*: GLenum = GLenum(0x8E89)
  GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_EXT*: GLenum = GLenum(0x8E89)
  GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_OES*: GLenum = GLenum(0x8E89)
  GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS*: GLenum = GLenum(0x8E8A)
  GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_EXT*: GLenum = GLenum(0x8E8A)
  GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_OES*: GLenum = GLenum(0x8E8A)
  GL_COMPRESSED_RGBA_BPTC_UNORM*: GLenum = GLenum(0x8E8C)
  GL_COMPRESSED_RGBA_BPTC_UNORM_ARB*: GLenum = GLenum(0x8E8C)
  GL_COMPRESSED_RGBA_BPTC_UNORM_EXT*: GLenum = GLenum(0x8E8C)
  GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM*: GLenum = GLenum(0x8E8D)
  GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB*: GLenum = GLenum(0x8E8D)
  GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT*: GLenum = GLenum(0x8E8D)
  GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT*: GLenum = GLenum(0x8E8E)
  GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB*: GLenum = GLenum(0x8E8E)
  GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT*: GLenum = GLenum(0x8E8E)
  GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT*: GLenum = GLenum(0x8E8F)
  GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB*: GLenum = GLenum(0x8E8F)
  GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT*: GLenum = GLenum(0x8E8F)
  GL_COVERAGE_COMPONENT_NV*: GLenum = GLenum(0x8ED0)
  GL_COVERAGE_COMPONENT4_NV*: GLenum = GLenum(0x8ED1)
  GL_COVERAGE_ATTACHMENT_NV*: GLenum = GLenum(0x8ED2)
  GL_COVERAGE_BUFFERS_NV*: GLenum = GLenum(0x8ED3)
  GL_COVERAGE_SAMPLES_NV*: GLenum = GLenum(0x8ED4)
  GL_COVERAGE_ALL_FRAGMENTS_NV*: GLenum = GLenum(0x8ED5)
  GL_COVERAGE_EDGE_FRAGMENTS_NV*: GLenum = GLenum(0x8ED6)
  GL_COVERAGE_AUTOMATIC_NV*: GLenum = GLenum(0x8ED7)
  GL_INCLUSIVE_EXT*: GLenum = GLenum(0x8F10)
  GL_EXCLUSIVE_EXT*: GLenum = GLenum(0x8F11)
  GL_WINDOW_RECTANGLE_EXT*: GLenum = GLenum(0x8F12)
  GL_WINDOW_RECTANGLE_MODE_EXT*: GLenum = GLenum(0x8F13)
  GL_MAX_WINDOW_RECTANGLES_EXT*: GLenum = GLenum(0x8F14)
  GL_NUM_WINDOW_RECTANGLES_EXT*: GLenum = GLenum(0x8F15)
  GL_BUFFER_GPU_ADDRESS_NV*: GLenum = GLenum(0x8F1D)
  GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV*: GLenum = GLenum(0x8F1E)
  GL_ELEMENT_ARRAY_UNIFIED_NV*: GLenum = GLenum(0x8F1F)
  GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV*: GLenum = GLenum(0x8F20)
  GL_VERTEX_ARRAY_ADDRESS_NV*: GLenum = GLenum(0x8F21)
  GL_NORMAL_ARRAY_ADDRESS_NV*: GLenum = GLenum(0x8F22)
  GL_COLOR_ARRAY_ADDRESS_NV*: GLenum = GLenum(0x8F23)
  GL_INDEX_ARRAY_ADDRESS_NV*: GLenum = GLenum(0x8F24)
  GL_TEXTURE_COORD_ARRAY_ADDRESS_NV*: GLenum = GLenum(0x8F25)
  GL_EDGE_FLAG_ARRAY_ADDRESS_NV*: GLenum = GLenum(0x8F26)
  GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV*: GLenum = GLenum(0x8F27)
  GL_FOG_COORD_ARRAY_ADDRESS_NV*: GLenum = GLenum(0x8F28)
  GL_ELEMENT_ARRAY_ADDRESS_NV*: GLenum = GLenum(0x8F29)
  GL_VERTEX_ATTRIB_ARRAY_LENGTH_NV*: GLenum = GLenum(0x8F2A)
  GL_VERTEX_ARRAY_LENGTH_NV*: GLenum = GLenum(0x8F2B)
  GL_NORMAL_ARRAY_LENGTH_NV*: GLenum = GLenum(0x8F2C)
  GL_COLOR_ARRAY_LENGTH_NV*: GLenum = GLenum(0x8F2D)
  GL_INDEX_ARRAY_LENGTH_NV*: GLenum = GLenum(0x8F2E)
  GL_TEXTURE_COORD_ARRAY_LENGTH_NV*: GLenum = GLenum(0x8F2F)
  GL_EDGE_FLAG_ARRAY_LENGTH_NV*: GLenum = GLenum(0x8F30)
  GL_SECONDARY_COLOR_ARRAY_LENGTH_NV*: GLenum = GLenum(0x8F31)
  GL_FOG_COORD_ARRAY_LENGTH_NV*: GLenum = GLenum(0x8F32)
  GL_ELEMENT_ARRAY_LENGTH_NV*: GLenum = GLenum(0x8F33)
  GL_GPU_ADDRESS_NV*: GLenum = GLenum(0x8F34)
  GL_MAX_SHADER_BUFFER_ADDRESS_NV*: GLenum = GLenum(0x8F35)
  GL_COPY_READ_BUFFER*: GLenum = GLenum(0x8F36)
  GL_COPY_READ_BUFFER_NV*: GLenum = GLenum(0x8F36)
  GL_COPY_READ_BUFFER_BINDING*: GLenum = GLenum(0x8F36)
  GL_COPY_WRITE_BUFFER*: GLenum = GLenum(0x8F37)
  GL_COPY_WRITE_BUFFER_NV*: GLenum = GLenum(0x8F37)
  GL_COPY_WRITE_BUFFER_BINDING*: GLenum = GLenum(0x8F37)
  GL_MAX_IMAGE_UNITS*: GLenum = GLenum(0x8F38)
  GL_MAX_IMAGE_UNITS_EXT*: GLenum = GLenum(0x8F38)
  GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS*: GLenum = GLenum(0x8F39)
  GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS_EXT*: GLenum = GLenum(0x8F39)
  GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES*: GLenum = GLenum(0x8F39)
  GL_IMAGE_BINDING_NAME*: GLenum = GLenum(0x8F3A)
  GL_IMAGE_BINDING_NAME_EXT*: GLenum = GLenum(0x8F3A)
  GL_IMAGE_BINDING_LEVEL*: GLenum = GLenum(0x8F3B)
  GL_IMAGE_BINDING_LEVEL_EXT*: GLenum = GLenum(0x8F3B)
  GL_IMAGE_BINDING_LAYERED*: GLenum = GLenum(0x8F3C)
  GL_IMAGE_BINDING_LAYERED_EXT*: GLenum = GLenum(0x8F3C)
  GL_IMAGE_BINDING_LAYER*: GLenum = GLenum(0x8F3D)
  GL_IMAGE_BINDING_LAYER_EXT*: GLenum = GLenum(0x8F3D)
  GL_IMAGE_BINDING_ACCESS*: GLenum = GLenum(0x8F3E)
  GL_IMAGE_BINDING_ACCESS_EXT*: GLenum = GLenum(0x8F3E)
  GL_DRAW_INDIRECT_BUFFER*: GLenum = GLenum(0x8F3F)
  GL_DRAW_INDIRECT_UNIFIED_NV*: GLenum = GLenum(0x8F40)
  GL_DRAW_INDIRECT_ADDRESS_NV*: GLenum = GLenum(0x8F41)
  GL_DRAW_INDIRECT_LENGTH_NV*: GLenum = GLenum(0x8F42)
  GL_DRAW_INDIRECT_BUFFER_BINDING*: GLenum = GLenum(0x8F43)
  GL_MAX_PROGRAM_SUBROUTINE_PARAMETERS_NV*: GLenum = GLenum(0x8F44)
  GL_MAX_PROGRAM_SUBROUTINE_NUM_NV*: GLenum = GLenum(0x8F45)
  GL_DOUBLE_MAT2*: GLenum = GLenum(0x8F46)
  GL_DOUBLE_MAT2_EXT*: GLenum = GLenum(0x8F46)
  GL_DOUBLE_MAT3*: GLenum = GLenum(0x8F47)
  GL_DOUBLE_MAT3_EXT*: GLenum = GLenum(0x8F47)
  GL_DOUBLE_MAT4*: GLenum = GLenum(0x8F48)
  GL_DOUBLE_MAT4_EXT*: GLenum = GLenum(0x8F48)
  GL_DOUBLE_MAT2x3*: GLenum = GLenum(0x8F49)
  GL_DOUBLE_MAT2x3_EXT*: GLenum = GLenum(0x8F49)
  GL_DOUBLE_MAT2x4*: GLenum = GLenum(0x8F4A)
  GL_DOUBLE_MAT2x4_EXT*: GLenum = GLenum(0x8F4A)
  GL_DOUBLE_MAT3x2*: GLenum = GLenum(0x8F4B)
  GL_DOUBLE_MAT3x2_EXT*: GLenum = GLenum(0x8F4B)
  GL_DOUBLE_MAT3x4*: GLenum = GLenum(0x8F4C)
  GL_DOUBLE_MAT3x4_EXT*: GLenum = GLenum(0x8F4C)
  GL_DOUBLE_MAT4x2*: GLenum = GLenum(0x8F4D)
  GL_DOUBLE_MAT4x2_EXT*: GLenum = GLenum(0x8F4D)
  GL_DOUBLE_MAT4x3*: GLenum = GLenum(0x8F4E)
  GL_DOUBLE_MAT4x3_EXT*: GLenum = GLenum(0x8F4E)
  GL_VERTEX_BINDING_BUFFER*: GLenum = GLenum(0x8F4F)
  GL_MALI_SHADER_BINARY_ARM*: GLenum = GLenum(0x8F60)
  GL_MALI_PROGRAM_BINARY_ARM*: GLenum = GLenum(0x8F61)
  GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT*: GLenum = GLenum(0x8F63)
  GL_SHADER_PIXEL_LOCAL_STORAGE_EXT*: GLenum = GLenum(0x8F64)
  GL_FETCH_PER_SAMPLE_ARM*: GLenum = GLenum(0x8F65)
  GL_FRAGMENT_SHADER_FRAMEBUFFER_FETCH_MRT_ARM*: GLenum = GLenum(0x8F66)
  GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT*: GLenum = GLenum(0x8F67)
  GL_TEXTURE_ASTC_DECODE_PRECISION_EXT*: GLenum = GLenum(0x8F69)
  GL_RED_SNORM*: GLenum = GLenum(0x8F90)
  GL_RG_SNORM*: GLenum = GLenum(0x8F91)
  GL_RGB_SNORM*: GLenum = GLenum(0x8F92)
  GL_RGBA_SNORM*: GLenum = GLenum(0x8F93)
  GL_R8_SNORM*: GLenum = GLenum(0x8F94)
  GL_RG8_SNORM*: GLenum = GLenum(0x8F95)
  GL_RGB8_SNORM*: GLenum = GLenum(0x8F96)
  GL_RGBA8_SNORM*: GLenum = GLenum(0x8F97)
  GL_R16_SNORM*: GLenum = GLenum(0x8F98)
  GL_R16_SNORM_EXT*: GLenum = GLenum(0x8F98)
  GL_RG16_SNORM*: GLenum = GLenum(0x8F99)
  GL_RG16_SNORM_EXT*: GLenum = GLenum(0x8F99)
  GL_RGB16_SNORM*: GLenum = GLenum(0x8F9A)
  GL_RGB16_SNORM_EXT*: GLenum = GLenum(0x8F9A)
  GL_RGBA16_SNORM*: GLenum = GLenum(0x8F9B)
  GL_RGBA16_SNORM_EXT*: GLenum = GLenum(0x8F9B)
  GL_SIGNED_NORMALIZED*: GLenum = GLenum(0x8F9C)
  GL_PRIMITIVE_RESTART*: GLenum = GLenum(0x8F9D)
  GL_PRIMITIVE_RESTART_INDEX*: GLenum = GLenum(0x8F9E)
  GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB*: GLenum = GLenum(0x8F9F)
  GL_PERFMON_GLOBAL_MODE_QCOM*: GLenum = GLenum(0x8FA0)
  GL_MAX_SHADER_SUBSAMPLED_IMAGE_UNITS_QCOM*: GLenum = GLenum(0x8FA1)
  GL_BINNING_CONTROL_HINT_QCOM*: GLenum = GLenum(0x8FB0)
  GL_CPU_OPTIMIZED_QCOM*: GLenum = GLenum(0x8FB1)
  GL_GPU_OPTIMIZED_QCOM*: GLenum = GLenum(0x8FB2)
  GL_RENDER_DIRECT_TO_FRAMEBUFFER_QCOM*: GLenum = GLenum(0x8FB3)
  GL_GPU_DISJOINT_EXT*: GLenum = GLenum(0x8FBB)
  GL_SR8_EXT*: GLenum = GLenum(0x8FBD)
  GL_SRG8_EXT*: GLenum = GLenum(0x8FBE)
  GL_TEXTURE_FORMAT_SRGB_OVERRIDE_EXT*: GLenum = GLenum(0x8FBF)
  GL_SHADER_BINARY_VIV*: GLenum = GLenum(0x8FC4)
  GL_INT8_NV*: GLenum = GLenum(0x8FE0)
  GL_INT8_VEC2_NV*: GLenum = GLenum(0x8FE1)
  GL_INT8_VEC3_NV*: GLenum = GLenum(0x8FE2)
  GL_INT8_VEC4_NV*: GLenum = GLenum(0x8FE3)
  GL_INT16_NV*: GLenum = GLenum(0x8FE4)
  GL_INT16_VEC2_NV*: GLenum = GLenum(0x8FE5)
  GL_INT16_VEC3_NV*: GLenum = GLenum(0x8FE6)
  GL_INT16_VEC4_NV*: GLenum = GLenum(0x8FE7)
  GL_INT64_VEC2_ARB*: GLenum = GLenum(0x8FE9)
  GL_INT64_VEC2_NV*: GLenum = GLenum(0x8FE9)
  GL_INT64_VEC3_ARB*: GLenum = GLenum(0x8FEA)
  GL_INT64_VEC3_NV*: GLenum = GLenum(0x8FEA)
  GL_INT64_VEC4_ARB*: GLenum = GLenum(0x8FEB)
  GL_INT64_VEC4_NV*: GLenum = GLenum(0x8FEB)
  GL_UNSIGNED_INT8_NV*: GLenum = GLenum(0x8FEC)
  GL_UNSIGNED_INT8_VEC2_NV*: GLenum = GLenum(0x8FED)
  GL_UNSIGNED_INT8_VEC3_NV*: GLenum = GLenum(0x8FEE)
  GL_UNSIGNED_INT8_VEC4_NV*: GLenum = GLenum(0x8FEF)
  GL_UNSIGNED_INT16_NV*: GLenum = GLenum(0x8FF0)
  GL_UNSIGNED_INT16_VEC2_NV*: GLenum = GLenum(0x8FF1)
  GL_UNSIGNED_INT16_VEC3_NV*: GLenum = GLenum(0x8FF2)
  GL_UNSIGNED_INT16_VEC4_NV*: GLenum = GLenum(0x8FF3)
  GL_UNSIGNED_INT64_VEC2_ARB*: GLenum = GLenum(0x8FF5)
  GL_UNSIGNED_INT64_VEC2_NV*: GLenum = GLenum(0x8FF5)
  GL_UNSIGNED_INT64_VEC3_ARB*: GLenum = GLenum(0x8FF6)
  GL_UNSIGNED_INT64_VEC3_NV*: GLenum = GLenum(0x8FF6)
  GL_UNSIGNED_INT64_VEC4_ARB*: GLenum = GLenum(0x8FF7)
  GL_UNSIGNED_INT64_VEC4_NV*: GLenum = GLenum(0x8FF7)
  GL_FLOAT16_NV*: GLenum = GLenum(0x8FF8)
  GL_FLOAT16_VEC2_NV*: GLenum = GLenum(0x8FF9)
  GL_FLOAT16_VEC3_NV*: GLenum = GLenum(0x8FFA)
  GL_FLOAT16_VEC4_NV*: GLenum = GLenum(0x8FFB)
  GL_DOUBLE_VEC2*: GLenum = GLenum(0x8FFC)
  GL_DOUBLE_VEC2_EXT*: GLenum = GLenum(0x8FFC)
  GL_DOUBLE_VEC3*: GLenum = GLenum(0x8FFD)
  GL_DOUBLE_VEC3_EXT*: GLenum = GLenum(0x8FFD)
  GL_DOUBLE_VEC4*: GLenum = GLenum(0x8FFE)
  GL_DOUBLE_VEC4_EXT*: GLenum = GLenum(0x8FFE)
  GL_SAMPLER_BUFFER_AMD*: GLenum = GLenum(0x9001)
  GL_INT_SAMPLER_BUFFER_AMD*: GLenum = GLenum(0x9002)
  GL_UNSIGNED_INT_SAMPLER_BUFFER_AMD*: GLenum = GLenum(0x9003)
  GL_TESSELLATION_MODE_AMD*: GLenum = GLenum(0x9004)
  GL_TESSELLATION_FACTOR_AMD*: GLenum = GLenum(0x9005)
  GL_DISCRETE_AMD*: GLenum = GLenum(0x9006)
  GL_CONTINUOUS_AMD*: GLenum = GLenum(0x9007)
  GL_TEXTURE_CUBE_MAP_ARRAY*: GLenum = GLenum(0x9009)
  GL_TEXTURE_CUBE_MAP_ARRAY_ARB*: GLenum = GLenum(0x9009)
  GL_TEXTURE_CUBE_MAP_ARRAY_EXT*: GLenum = GLenum(0x9009)
  GL_TEXTURE_CUBE_MAP_ARRAY_OES*: GLenum = GLenum(0x9009)
  GL_TEXTURE_BINDING_CUBE_MAP_ARRAY*: GLenum = GLenum(0x900A)
  GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB*: GLenum = GLenum(0x900A)
  GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_EXT*: GLenum = GLenum(0x900A)
  GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_OES*: GLenum = GLenum(0x900A)
  GL_PROXY_TEXTURE_CUBE_MAP_ARRAY*: GLenum = GLenum(0x900B)
  GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB*: GLenum = GLenum(0x900B)
  GL_SAMPLER_CUBE_MAP_ARRAY*: GLenum = GLenum(0x900C)
  GL_SAMPLER_CUBE_MAP_ARRAY_ARB*: GLenum = GLenum(0x900C)
  GL_SAMPLER_CUBE_MAP_ARRAY_EXT*: GLenum = GLenum(0x900C)
  GL_SAMPLER_CUBE_MAP_ARRAY_OES*: GLenum = GLenum(0x900C)
  GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW*: GLenum = GLenum(0x900D)
  GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB*: GLenum = GLenum(0x900D)
  GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_EXT*: GLenum = GLenum(0x900D)
  GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_OES*: GLenum = GLenum(0x900D)
  GL_INT_SAMPLER_CUBE_MAP_ARRAY*: GLenum = GLenum(0x900E)
  GL_INT_SAMPLER_CUBE_MAP_ARRAY_ARB*: GLenum = GLenum(0x900E)
  GL_INT_SAMPLER_CUBE_MAP_ARRAY_EXT*: GLenum = GLenum(0x900E)
  GL_INT_SAMPLER_CUBE_MAP_ARRAY_OES*: GLenum = GLenum(0x900E)
  GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY*: GLenum = GLenum(0x900F)
  GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB*: GLenum = GLenum(0x900F)
  GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_EXT*: GLenum = GLenum(0x900F)
  GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_OES*: GLenum = GLenum(0x900F)
  GL_ALPHA_SNORM*: GLenum = GLenum(0x9010)
  GL_LUMINANCE_SNORM*: GLenum = GLenum(0x9011)
  GL_LUMINANCE_ALPHA_SNORM*: GLenum = GLenum(0x9012)
  GL_INTENSITY_SNORM*: GLenum = GLenum(0x9013)
  GL_ALPHA8_SNORM*: GLenum = GLenum(0x9014)
  GL_LUMINANCE8_SNORM*: GLenum = GLenum(0x9015)
  GL_LUMINANCE8_ALPHA8_SNORM*: GLenum = GLenum(0x9016)
  GL_INTENSITY8_SNORM*: GLenum = GLenum(0x9017)
  GL_ALPHA16_SNORM*: GLenum = GLenum(0x9018)
  GL_LUMINANCE16_SNORM*: GLenum = GLenum(0x9019)
  GL_LUMINANCE16_ALPHA16_SNORM*: GLenum = GLenum(0x901A)
  GL_INTENSITY16_SNORM*: GLenum = GLenum(0x901B)
  GL_FACTOR_MIN_AMD*: GLenum = GLenum(0x901C)
  GL_FACTOR_MAX_AMD*: GLenum = GLenum(0x901D)
  GL_DEPTH_CLAMP_NEAR_AMD*: GLenum = GLenum(0x901E)
  GL_DEPTH_CLAMP_FAR_AMD*: GLenum = GLenum(0x901F)
  GL_VIDEO_BUFFER_NV*: GLenum = GLenum(0x9020)
  GL_VIDEO_BUFFER_BINDING_NV*: GLenum = GLenum(0x9021)
  GL_FIELD_UPPER_NV*: GLenum = GLenum(0x9022)
  GL_FIELD_LOWER_NV*: GLenum = GLenum(0x9023)
  GL_NUM_VIDEO_CAPTURE_STREAMS_NV*: GLenum = GLenum(0x9024)
  GL_NEXT_VIDEO_CAPTURE_BUFFER_STATUS_NV*: GLenum = GLenum(0x9025)
  GL_VIDEO_CAPTURE_TO_422_SUPPORTED_NV*: GLenum = GLenum(0x9026)
  GL_LAST_VIDEO_CAPTURE_STATUS_NV*: GLenum = GLenum(0x9027)
  GL_VIDEO_BUFFER_PITCH_NV*: GLenum = GLenum(0x9028)
  GL_VIDEO_COLOR_CONVERSION_MATRIX_NV*: GLenum = GLenum(0x9029)
  GL_VIDEO_COLOR_CONVERSION_MAX_NV*: GLenum = GLenum(0x902A)
  GL_VIDEO_COLOR_CONVERSION_MIN_NV*: GLenum = GLenum(0x902B)
  GL_VIDEO_COLOR_CONVERSION_OFFSET_NV*: GLenum = GLenum(0x902C)
  GL_VIDEO_BUFFER_INTERNAL_FORMAT_NV*: GLenum = GLenum(0x902D)
  GL_PARTIAL_SUCCESS_NV*: GLenum = GLenum(0x902E)
  GL_SUCCESS_NV*: GLenum = GLenum(0x902F)
  GL_FAILURE_NV*: GLenum = GLenum(0x9030)
  GL_YCBYCR8_422_NV*: GLenum = GLenum(0x9031)
  GL_YCBAYCR8A_4224_NV*: GLenum = GLenum(0x9032)
  GL_Z6Y10Z6CB10Z6Y10Z6CR10_422_NV*: GLenum = GLenum(0x9033)
  GL_Z6Y10Z6CB10Z6A10Z6Y10Z6CR10Z6A10_4224_NV*: GLenum = GLenum(0x9034)
  GL_Z4Y12Z4CB12Z4Y12Z4CR12_422_NV*: GLenum = GLenum(0x9035)
  GL_Z4Y12Z4CB12Z4A12Z4Y12Z4CR12Z4A12_4224_NV*: GLenum = GLenum(0x9036)
  GL_Z4Y12Z4CB12Z4CR12_444_NV*: GLenum = GLenum(0x9037)
  GL_VIDEO_CAPTURE_FRAME_WIDTH_NV*: GLenum = GLenum(0x9038)
  GL_VIDEO_CAPTURE_FRAME_HEIGHT_NV*: GLenum = GLenum(0x9039)
  GL_VIDEO_CAPTURE_FIELD_UPPER_HEIGHT_NV*: GLenum = GLenum(0x903A)
  GL_VIDEO_CAPTURE_FIELD_LOWER_HEIGHT_NV*: GLenum = GLenum(0x903B)
  GL_VIDEO_CAPTURE_SURFACE_ORIGIN_NV*: GLenum = GLenum(0x903C)
  GL_TEXTURE_COVERAGE_SAMPLES_NV*: GLenum = GLenum(0x9045)
  GL_TEXTURE_COLOR_SAMPLES_NV*: GLenum = GLenum(0x9046)
  GL_GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX*: GLenum = GLenum(0x9047)
  GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX*: GLenum = GLenum(0x9048)
  GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX*: GLenum = GLenum(0x9049)
  GL_GPU_MEMORY_INFO_EVICTION_COUNT_NVX*: GLenum = GLenum(0x904A)
  GL_GPU_MEMORY_INFO_EVICTED_MEMORY_NVX*: GLenum = GLenum(0x904B)
  GL_IMAGE_1D*: GLenum = GLenum(0x904C)
  GL_IMAGE_1D_EXT*: GLenum = GLenum(0x904C)
  GL_IMAGE_2D*: GLenum = GLenum(0x904D)
  GL_IMAGE_2D_EXT*: GLenum = GLenum(0x904D)
  GL_IMAGE_3D*: GLenum = GLenum(0x904E)
  GL_IMAGE_3D_EXT*: GLenum = GLenum(0x904E)
  GL_IMAGE_2D_RECT*: GLenum = GLenum(0x904F)
  GL_IMAGE_2D_RECT_EXT*: GLenum = GLenum(0x904F)
  GL_IMAGE_CUBE*: GLenum = GLenum(0x9050)
  GL_IMAGE_CUBE_EXT*: GLenum = GLenum(0x9050)
  GL_IMAGE_BUFFER*: GLenum = GLenum(0x9051)
  GL_IMAGE_BUFFER_EXT*: GLenum = GLenum(0x9051)
  GL_IMAGE_BUFFER_OES*: GLenum = GLenum(0x9051)
  GL_IMAGE_1D_ARRAY*: GLenum = GLenum(0x9052)
  GL_IMAGE_1D_ARRAY_EXT*: GLenum = GLenum(0x9052)
  GL_IMAGE_2D_ARRAY*: GLenum = GLenum(0x9053)
  GL_IMAGE_2D_ARRAY_EXT*: GLenum = GLenum(0x9053)
  GL_IMAGE_CUBE_MAP_ARRAY*: GLenum = GLenum(0x9054)
  GL_IMAGE_CUBE_MAP_ARRAY_EXT*: GLenum = GLenum(0x9054)
  GL_IMAGE_CUBE_MAP_ARRAY_OES*: GLenum = GLenum(0x9054)
  GL_IMAGE_2D_MULTISAMPLE*: GLenum = GLenum(0x9055)
  GL_IMAGE_2D_MULTISAMPLE_EXT*: GLenum = GLenum(0x9055)
  GL_IMAGE_2D_MULTISAMPLE_ARRAY*: GLenum = GLenum(0x9056)
  GL_IMAGE_2D_MULTISAMPLE_ARRAY_EXT*: GLenum = GLenum(0x9056)
  GL_INT_IMAGE_1D*: GLenum = GLenum(0x9057)
  GL_INT_IMAGE_1D_EXT*: GLenum = GLenum(0x9057)
  GL_INT_IMAGE_2D*: GLenum = GLenum(0x9058)
  GL_INT_IMAGE_2D_EXT*: GLenum = GLenum(0x9058)
  GL_INT_IMAGE_3D*: GLenum = GLenum(0x9059)
  GL_INT_IMAGE_3D_EXT*: GLenum = GLenum(0x9059)
  GL_INT_IMAGE_2D_RECT*: GLenum = GLenum(0x905A)
  GL_INT_IMAGE_2D_RECT_EXT*: GLenum = GLenum(0x905A)
  GL_INT_IMAGE_CUBE*: GLenum = GLenum(0x905B)
  GL_INT_IMAGE_CUBE_EXT*: GLenum = GLenum(0x905B)
  GL_INT_IMAGE_BUFFER*: GLenum = GLenum(0x905C)
  GL_INT_IMAGE_BUFFER_EXT*: GLenum = GLenum(0x905C)
  GL_INT_IMAGE_BUFFER_OES*: GLenum = GLenum(0x905C)
  GL_INT_IMAGE_1D_ARRAY*: GLenum = GLenum(0x905D)
  GL_INT_IMAGE_1D_ARRAY_EXT*: GLenum = GLenum(0x905D)
  GL_INT_IMAGE_2D_ARRAY*: GLenum = GLenum(0x905E)
  GL_INT_IMAGE_2D_ARRAY_EXT*: GLenum = GLenum(0x905E)
  GL_INT_IMAGE_CUBE_MAP_ARRAY*: GLenum = GLenum(0x905F)
  GL_INT_IMAGE_CUBE_MAP_ARRAY_EXT*: GLenum = GLenum(0x905F)
  GL_INT_IMAGE_CUBE_MAP_ARRAY_OES*: GLenum = GLenum(0x905F)
  GL_INT_IMAGE_2D_MULTISAMPLE*: GLenum = GLenum(0x9060)
  GL_INT_IMAGE_2D_MULTISAMPLE_EXT*: GLenum = GLenum(0x9060)
  GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY*: GLenum = GLenum(0x9061)
  GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT*: GLenum = GLenum(0x9061)
  GL_UNSIGNED_INT_IMAGE_1D*: GLenum = GLenum(0x9062)
  GL_UNSIGNED_INT_IMAGE_1D_EXT*: GLenum = GLenum(0x9062)
  GL_UNSIGNED_INT_IMAGE_2D*: GLenum = GLenum(0x9063)
  GL_UNSIGNED_INT_IMAGE_2D_EXT*: GLenum = GLenum(0x9063)
  GL_UNSIGNED_INT_IMAGE_3D*: GLenum = GLenum(0x9064)
  GL_UNSIGNED_INT_IMAGE_3D_EXT*: GLenum = GLenum(0x9064)
  GL_UNSIGNED_INT_IMAGE_2D_RECT*: GLenum = GLenum(0x9065)
  GL_UNSIGNED_INT_IMAGE_2D_RECT_EXT*: GLenum = GLenum(0x9065)
  GL_UNSIGNED_INT_IMAGE_CUBE*: GLenum = GLenum(0x9066)
  GL_UNSIGNED_INT_IMAGE_CUBE_EXT*: GLenum = GLenum(0x9066)
  GL_UNSIGNED_INT_IMAGE_BUFFER*: GLenum = GLenum(0x9067)
  GL_UNSIGNED_INT_IMAGE_BUFFER_EXT*: GLenum = GLenum(0x9067)
  GL_UNSIGNED_INT_IMAGE_BUFFER_OES*: GLenum = GLenum(0x9067)
  GL_UNSIGNED_INT_IMAGE_1D_ARRAY*: GLenum = GLenum(0x9068)
  GL_UNSIGNED_INT_IMAGE_1D_ARRAY_EXT*: GLenum = GLenum(0x9068)
  GL_UNSIGNED_INT_IMAGE_2D_ARRAY*: GLenum = GLenum(0x9069)
  GL_UNSIGNED_INT_IMAGE_2D_ARRAY_EXT*: GLenum = GLenum(0x9069)
  GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY*: GLenum = GLenum(0x906A)
  GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_EXT*: GLenum = GLenum(0x906A)
  GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_OES*: GLenum = GLenum(0x906A)
  GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE*: GLenum = GLenum(0x906B)
  GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_EXT*: GLenum = GLenum(0x906B)
  GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY*: GLenum = GLenum(0x906C)
  GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT*: GLenum = GLenum(0x906C)
  GL_MAX_IMAGE_SAMPLES*: GLenum = GLenum(0x906D)
  GL_MAX_IMAGE_SAMPLES_EXT*: GLenum = GLenum(0x906D)
  GL_IMAGE_BINDING_FORMAT*: GLenum = GLenum(0x906E)
  GL_IMAGE_BINDING_FORMAT_EXT*: GLenum = GLenum(0x906E)
  GL_RGB10_A2UI*: GLenum = GLenum(0x906F)
  GL_PATH_FORMAT_SVG_NV*: GLenum = GLenum(0x9070)
  GL_PATH_FORMAT_PS_NV*: GLenum = GLenum(0x9071)
  GL_STANDARD_FONT_NAME_NV*: GLenum = GLenum(0x9072)
  GL_SYSTEM_FONT_NAME_NV*: GLenum = GLenum(0x9073)
  GL_FILE_NAME_NV*: GLenum = GLenum(0x9074)
  GL_PATH_STROKE_WIDTH_NV*: GLenum = GLenum(0x9075)
  GL_PATH_END_CAPS_NV*: GLenum = GLenum(0x9076)
  GL_PATH_INITIAL_END_CAP_NV*: GLenum = GLenum(0x9077)
  GL_PATH_TERMINAL_END_CAP_NV*: GLenum = GLenum(0x9078)
  GL_PATH_JOIN_STYLE_NV*: GLenum = GLenum(0x9079)
  GL_PATH_MITER_LIMIT_NV*: GLenum = GLenum(0x907A)
  GL_PATH_DASH_CAPS_NV*: GLenum = GLenum(0x907B)
  GL_PATH_INITIAL_DASH_CAP_NV*: GLenum = GLenum(0x907C)
  GL_PATH_TERMINAL_DASH_CAP_NV*: GLenum = GLenum(0x907D)
  GL_PATH_DASH_OFFSET_NV*: GLenum = GLenum(0x907E)
  GL_PATH_CLIENT_LENGTH_NV*: GLenum = GLenum(0x907F)
  GL_PATH_FILL_MODE_NV*: GLenum = GLenum(0x9080)
  GL_PATH_FILL_MASK_NV*: GLenum = GLenum(0x9081)
  GL_PATH_FILL_COVER_MODE_NV*: GLenum = GLenum(0x9082)
  GL_PATH_STROKE_COVER_MODE_NV*: GLenum = GLenum(0x9083)
  GL_PATH_STROKE_MASK_NV*: GLenum = GLenum(0x9084)
  GL_COUNT_UP_NV*: GLenum = GLenum(0x9088)
  GL_COUNT_DOWN_NV*: GLenum = GLenum(0x9089)
  GL_PATH_OBJECT_BOUNDING_BOX_NV*: GLenum = GLenum(0x908A)
  GL_CONVEX_HULL_NV*: GLenum = GLenum(0x908B)
  GL_BOUNDING_BOX_NV*: GLenum = GLenum(0x908D)
  GL_TRANSLATE_X_NV*: GLenum = GLenum(0x908E)
  GL_TRANSLATE_Y_NV*: GLenum = GLenum(0x908F)
  GL_TRANSLATE_2D_NV*: GLenum = GLenum(0x9090)
  GL_TRANSLATE_3D_NV*: GLenum = GLenum(0x9091)
  GL_AFFINE_2D_NV*: GLenum = GLenum(0x9092)
  GL_AFFINE_3D_NV*: GLenum = GLenum(0x9094)
  GL_TRANSPOSE_AFFINE_2D_NV*: GLenum = GLenum(0x9096)
  GL_TRANSPOSE_AFFINE_3D_NV*: GLenum = GLenum(0x9098)
  GL_UTF8_NV*: GLenum = GLenum(0x909A)
  GL_UTF16_NV*: GLenum = GLenum(0x909B)
  GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV*: GLenum = GLenum(0x909C)
  GL_PATH_COMMAND_COUNT_NV*: GLenum = GLenum(0x909D)
  GL_PATH_COORD_COUNT_NV*: GLenum = GLenum(0x909E)
  GL_PATH_DASH_ARRAY_COUNT_NV*: GLenum = GLenum(0x909F)
  GL_PATH_COMPUTED_LENGTH_NV*: GLenum = GLenum(0x90A0)
  GL_PATH_FILL_BOUNDING_BOX_NV*: GLenum = GLenum(0x90A1)
  GL_PATH_STROKE_BOUNDING_BOX_NV*: GLenum = GLenum(0x90A2)
  GL_SQUARE_NV*: GLenum = GLenum(0x90A3)
  GL_ROUND_NV*: GLenum = GLenum(0x90A4)
  GL_TRIANGULAR_NV*: GLenum = GLenum(0x90A5)
  GL_BEVEL_NV*: GLenum = GLenum(0x90A6)
  GL_MITER_REVERT_NV*: GLenum = GLenum(0x90A7)
  GL_MITER_TRUNCATE_NV*: GLenum = GLenum(0x90A8)
  GL_SKIP_MISSING_GLYPH_NV*: GLenum = GLenum(0x90A9)
  GL_USE_MISSING_GLYPH_NV*: GLenum = GLenum(0x90AA)
  GL_PATH_ERROR_POSITION_NV*: GLenum = GLenum(0x90AB)
  GL_PATH_FOG_GEN_MODE_NV*: GLenum = GLenum(0x90AC)
  GL_ACCUM_ADJACENT_PAIRS_NV*: GLenum = GLenum(0x90AD)
  GL_ADJACENT_PAIRS_NV*: GLenum = GLenum(0x90AE)
  GL_FIRST_TO_REST_NV*: GLenum = GLenum(0x90AF)
  GL_PATH_GEN_MODE_NV*: GLenum = GLenum(0x90B0)
  GL_PATH_GEN_COEFF_NV*: GLenum = GLenum(0x90B1)
  GL_PATH_GEN_COLOR_FORMAT_NV*: GLenum = GLenum(0x90B2)
  GL_PATH_GEN_COMPONENTS_NV*: GLenum = GLenum(0x90B3)
  GL_PATH_DASH_OFFSET_RESET_NV*: GLenum = GLenum(0x90B4)
  GL_MOVE_TO_RESETS_NV*: GLenum = GLenum(0x90B5)
  GL_MOVE_TO_CONTINUES_NV*: GLenum = GLenum(0x90B6)
  GL_PATH_STENCIL_FUNC_NV*: GLenum = GLenum(0x90B7)
  GL_PATH_STENCIL_REF_NV*: GLenum = GLenum(0x90B8)
  GL_PATH_STENCIL_VALUE_MASK_NV*: GLenum = GLenum(0x90B9)
  GL_SCALED_RESOLVE_FASTEST_EXT*: GLenum = GLenum(0x90BA)
  GL_SCALED_RESOLVE_NICEST_EXT*: GLenum = GLenum(0x90BB)
  GL_MIN_MAP_BUFFER_ALIGNMENT*: GLenum = GLenum(0x90BC)
  GL_PATH_STENCIL_DEPTH_OFFSET_FACTOR_NV*: GLenum = GLenum(0x90BD)
  GL_PATH_STENCIL_DEPTH_OFFSET_UNITS_NV*: GLenum = GLenum(0x90BE)
  GL_PATH_COVER_DEPTH_FUNC_NV*: GLenum = GLenum(0x90BF)
  GL_IMAGE_FORMAT_COMPATIBILITY_TYPE*: GLenum = GLenum(0x90C7)
  GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE*: GLenum = GLenum(0x90C8)
  GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS*: GLenum = GLenum(0x90C9)
  GL_MAX_VERTEX_IMAGE_UNIFORMS*: GLenum = GLenum(0x90CA)
  GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS*: GLenum = GLenum(0x90CB)
  GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_EXT*: GLenum = GLenum(0x90CB)
  GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_OES*: GLenum = GLenum(0x90CB)
  GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS*: GLenum = GLenum(0x90CC)
  GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_EXT*: GLenum = GLenum(0x90CC)
  GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_OES*: GLenum = GLenum(0x90CC)
  GL_MAX_GEOMETRY_IMAGE_UNIFORMS*: GLenum = GLenum(0x90CD)
  GL_MAX_GEOMETRY_IMAGE_UNIFORMS_EXT*: GLenum = GLenum(0x90CD)
  GL_MAX_GEOMETRY_IMAGE_UNIFORMS_OES*: GLenum = GLenum(0x90CD)
  GL_MAX_FRAGMENT_IMAGE_UNIFORMS*: GLenum = GLenum(0x90CE)
  GL_MAX_COMBINED_IMAGE_UNIFORMS*: GLenum = GLenum(0x90CF)
  GL_MAX_DEEP_3D_TEXTURE_WIDTH_HEIGHT_NV*: GLenum = GLenum(0x90D0)
  GL_MAX_DEEP_3D_TEXTURE_DEPTH_NV*: GLenum = GLenum(0x90D1)
  GL_SHADER_STORAGE_BUFFER*: GLenum = GLenum(0x90D2)
  GL_SHADER_STORAGE_BUFFER_BINDING*: GLenum = GLenum(0x90D3)
  GL_SHADER_STORAGE_BUFFER_START*: GLenum = GLenum(0x90D4)
  GL_SHADER_STORAGE_BUFFER_SIZE*: GLenum = GLenum(0x90D5)
  GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS*: GLenum = GLenum(0x90D6)
  GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS*: GLenum = GLenum(0x90D7)
  GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_EXT*: GLenum = GLenum(0x90D7)
  GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_OES*: GLenum = GLenum(0x90D7)
  GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS*: GLenum = GLenum(0x90D8)
  GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_EXT*: GLenum = GLenum(0x90D8)
  GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_OES*: GLenum = GLenum(0x90D8)
  GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS*: GLenum = GLenum(0x90D9)
  GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_EXT*: GLenum = GLenum(0x90D9)
  GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_OES*: GLenum = GLenum(0x90D9)
  GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS*: GLenum = GLenum(0x90DA)
  GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS*: GLenum = GLenum(0x90DB)
  GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS*: GLenum = GLenum(0x90DC)
  GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS*: GLenum = GLenum(0x90DD)
  GL_MAX_SHADER_STORAGE_BLOCK_SIZE*: GLenum = GLenum(0x90DE)
  GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT*: GLenum = GLenum(0x90DF)
  GL_SYNC_X11_FENCE_EXT*: GLenum = GLenum(0x90E1)
  GL_DEPTH_STENCIL_TEXTURE_MODE*: GLenum = GLenum(0x90EA)
  GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS*: GLenum = GLenum(0x90EB)
  GL_MAX_COMPUTE_FIXED_GROUP_INVOCATIONS_ARB*: GLenum = GLenum(0x90EB)
  GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER*: GLenum = GLenum(0x90EC)
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER*: GLenum = GLenum(0x90ED)
  GL_DISPATCH_INDIRECT_BUFFER*: GLenum = GLenum(0x90EE)
  GL_DISPATCH_INDIRECT_BUFFER_BINDING*: GLenum = GLenum(0x90EF)
  GL_COLOR_ATTACHMENT_EXT*: GLenum = GLenum(0x90F0)
  GL_MULTIVIEW_EXT*: GLenum = GLenum(0x90F1)
  GL_MAX_MULTIVIEW_BUFFERS_EXT*: GLenum = GLenum(0x90F2)
  GL_CONTEXT_ROBUST_ACCESS*: GLenum = GLenum(0x90F3)
  GL_CONTEXT_ROBUST_ACCESS_EXT*: GLenum = GLenum(0x90F3)
  GL_CONTEXT_ROBUST_ACCESS_KHR*: GLenum = GLenum(0x90F3)
  GL_COMPUTE_PROGRAM_NV*: GLenum = GLenum(0x90FB)
  GL_COMPUTE_PROGRAM_PARAMETER_BUFFER_NV*: GLenum = GLenum(0x90FC)
  GL_TEXTURE_2D_MULTISAMPLE*: GLenum = GLenum(0x9100)
  GL_PROXY_TEXTURE_2D_MULTISAMPLE*: GLenum = GLenum(0x9101)
  GL_TEXTURE_2D_MULTISAMPLE_ARRAY*: GLenum = GLenum(0x9102)
  GL_TEXTURE_2D_MULTISAMPLE_ARRAY_OES*: GLenum = GLenum(0x9102)
  GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY*: GLenum = GLenum(0x9103)
  GL_TEXTURE_BINDING_2D_MULTISAMPLE*: GLenum = GLenum(0x9104)
  GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY*: GLenum = GLenum(0x9105)
  GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY_OES*: GLenum = GLenum(0x9105)
  GL_TEXTURE_SAMPLES*: GLenum = GLenum(0x9106)
  GL_TEXTURE_FIXED_SAMPLE_LOCATIONS*: GLenum = GLenum(0x9107)
  GL_SAMPLER_2D_MULTISAMPLE*: GLenum = GLenum(0x9108)
  GL_INT_SAMPLER_2D_MULTISAMPLE*: GLenum = GLenum(0x9109)
  GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE*: GLenum = GLenum(0x910A)
  GL_SAMPLER_2D_MULTISAMPLE_ARRAY*: GLenum = GLenum(0x910B)
  GL_SAMPLER_2D_MULTISAMPLE_ARRAY_OES*: GLenum = GLenum(0x910B)
  GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY*: GLenum = GLenum(0x910C)
  GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES*: GLenum = GLenum(0x910C)
  GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY*: GLenum = GLenum(0x910D)
  GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES*: GLenum = GLenum(0x910D)
  GL_MAX_COLOR_TEXTURE_SAMPLES*: GLenum = GLenum(0x910E)
  GL_MAX_DEPTH_TEXTURE_SAMPLES*: GLenum = GLenum(0x910F)
  GL_MAX_INTEGER_SAMPLES*: GLenum = GLenum(0x9110)
  GL_MAX_SERVER_WAIT_TIMEOUT*: GLenum = GLenum(0x9111)
  GL_MAX_SERVER_WAIT_TIMEOUT_APPLE*: GLenum = GLenum(0x9111)
  GL_OBJECT_TYPE*: GLenum = GLenum(0x9112)
  GL_OBJECT_TYPE_APPLE*: GLenum = GLenum(0x9112)
  GL_SYNC_CONDITION*: GLenum = GLenum(0x9113)
  GL_SYNC_CONDITION_APPLE*: GLenum = GLenum(0x9113)
  GL_SYNC_STATUS*: GLenum = GLenum(0x9114)
  GL_SYNC_STATUS_APPLE*: GLenum = GLenum(0x9114)
  GL_SYNC_FLAGS*: GLenum = GLenum(0x9115)
  GL_SYNC_FLAGS_APPLE*: GLenum = GLenum(0x9115)
  GL_SYNC_FENCE*: GLenum = GLenum(0x9116)
  GL_SYNC_FENCE_APPLE*: GLenum = GLenum(0x9116)
  GL_SYNC_GPU_COMMANDS_COMPLETE*: GLenum = GLenum(0x9117)
  GL_SYNC_GPU_COMMANDS_COMPLETE_APPLE*: GLenum = GLenum(0x9117)
  GL_UNSIGNALED*: GLenum = GLenum(0x9118)
  GL_UNSIGNALED_APPLE*: GLenum = GLenum(0x9118)
  GL_SIGNALED*: GLenum = GLenum(0x9119)
  GL_SIGNALED_APPLE*: GLenum = GLenum(0x9119)
  GL_ALREADY_SIGNALED*: GLenum = GLenum(0x911A)
  GL_ALREADY_SIGNALED_APPLE*: GLenum = GLenum(0x911A)
  GL_TIMEOUT_EXPIRED*: GLenum = GLenum(0x911B)
  GL_TIMEOUT_EXPIRED_APPLE*: GLenum = GLenum(0x911B)
  GL_CONDITION_SATISFIED*: GLenum = GLenum(0x911C)
  GL_CONDITION_SATISFIED_APPLE*: GLenum = GLenum(0x911C)
  GL_WAIT_FAILED*: GLenum = GLenum(0x911D)
  GL_WAIT_FAILED_APPLE*: GLenum = GLenum(0x911D)
  GL_BUFFER_ACCESS_FLAGS*: GLenum = GLenum(0x911F)
  GL_BUFFER_MAP_LENGTH*: GLenum = GLenum(0x9120)
  GL_BUFFER_MAP_OFFSET*: GLenum = GLenum(0x9121)
  GL_MAX_VERTEX_OUTPUT_COMPONENTS*: GLenum = GLenum(0x9122)
  GL_MAX_GEOMETRY_INPUT_COMPONENTS*: GLenum = GLenum(0x9123)
  GL_MAX_GEOMETRY_INPUT_COMPONENTS_EXT*: GLenum = GLenum(0x9123)
  GL_MAX_GEOMETRY_INPUT_COMPONENTS_OES*: GLenum = GLenum(0x9123)
  GL_MAX_GEOMETRY_OUTPUT_COMPONENTS*: GLenum = GLenum(0x9124)
  GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_EXT*: GLenum = GLenum(0x9124)
  GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_OES*: GLenum = GLenum(0x9124)
  GL_MAX_FRAGMENT_INPUT_COMPONENTS*: GLenum = GLenum(0x9125)
  GL_CONTEXT_PROFILE_MASK*: GLenum = GLenum(0x9126)
  GL_UNPACK_COMPRESSED_BLOCK_WIDTH*: GLenum = GLenum(0x9127)
  GL_UNPACK_COMPRESSED_BLOCK_HEIGHT*: GLenum = GLenum(0x9128)
  GL_UNPACK_COMPRESSED_BLOCK_DEPTH*: GLenum = GLenum(0x9129)
  GL_UNPACK_COMPRESSED_BLOCK_SIZE*: GLenum = GLenum(0x912A)
  GL_PACK_COMPRESSED_BLOCK_WIDTH*: GLenum = GLenum(0x912B)
  GL_PACK_COMPRESSED_BLOCK_HEIGHT*: GLenum = GLenum(0x912C)
  GL_PACK_COMPRESSED_BLOCK_DEPTH*: GLenum = GLenum(0x912D)
  GL_PACK_COMPRESSED_BLOCK_SIZE*: GLenum = GLenum(0x912E)
  GL_TEXTURE_IMMUTABLE_FORMAT*: GLenum = GLenum(0x912F)
  GL_TEXTURE_IMMUTABLE_FORMAT_EXT*: GLenum = GLenum(0x912F)
  GL_SGX_PROGRAM_BINARY_IMG*: GLenum = GLenum(0x9130)
  GL_RENDERBUFFER_SAMPLES_IMG*: GLenum = GLenum(0x9133)
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_IMG*: GLenum = GLenum(0x9134)
  GL_MAX_SAMPLES_IMG*: GLenum = GLenum(0x9135)
  GL_TEXTURE_SAMPLES_IMG*: GLenum = GLenum(0x9136)
  GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG*: GLenum = GLenum(0x9137)
  GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG*: GLenum = GLenum(0x9138)
  GL_CUBIC_IMG*: GLenum = GLenum(0x9139)
  GL_CUBIC_MIPMAP_NEAREST_IMG*: GLenum = GLenum(0x913A)
  GL_CUBIC_MIPMAP_LINEAR_IMG*: GLenum = GLenum(0x913B)
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_AND_DOWNSAMPLE_IMG*: GLenum = GLenum(0x913C)
  GL_NUM_DOWNSAMPLE_SCALES_IMG*: GLenum = GLenum(0x913D)
  GL_DOWNSAMPLE_SCALES_IMG*: GLenum = GLenum(0x913E)
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SCALE_IMG*: GLenum = GLenum(0x913F)
  GL_MAX_DEBUG_MESSAGE_LENGTH*: GLenum = GLenum(0x9143)
  GL_MAX_DEBUG_MESSAGE_LENGTH_AMD*: GLenum = GLenum(0x9143)
  GL_MAX_DEBUG_MESSAGE_LENGTH_ARB*: GLenum = GLenum(0x9143)
  GL_MAX_DEBUG_MESSAGE_LENGTH_KHR*: GLenum = GLenum(0x9143)
  GL_MAX_DEBUG_LOGGED_MESSAGES*: GLenum = GLenum(0x9144)
  GL_MAX_DEBUG_LOGGED_MESSAGES_AMD*: GLenum = GLenum(0x9144)
  GL_MAX_DEBUG_LOGGED_MESSAGES_ARB*: GLenum = GLenum(0x9144)
  GL_MAX_DEBUG_LOGGED_MESSAGES_KHR*: GLenum = GLenum(0x9144)
  GL_DEBUG_LOGGED_MESSAGES*: GLenum = GLenum(0x9145)
  GL_DEBUG_LOGGED_MESSAGES_AMD*: GLenum = GLenum(0x9145)
  GL_DEBUG_LOGGED_MESSAGES_ARB*: GLenum = GLenum(0x9145)
  GL_DEBUG_LOGGED_MESSAGES_KHR*: GLenum = GLenum(0x9145)
  GL_DEBUG_SEVERITY_HIGH*: GLenum = GLenum(0x9146)
  GL_DEBUG_SEVERITY_HIGH_AMD*: GLenum = GLenum(0x9146)
  GL_DEBUG_SEVERITY_HIGH_ARB*: GLenum = GLenum(0x9146)
  GL_DEBUG_SEVERITY_HIGH_KHR*: GLenum = GLenum(0x9146)
  GL_DEBUG_SEVERITY_MEDIUM*: GLenum = GLenum(0x9147)
  GL_DEBUG_SEVERITY_MEDIUM_AMD*: GLenum = GLenum(0x9147)
  GL_DEBUG_SEVERITY_MEDIUM_ARB*: GLenum = GLenum(0x9147)
  GL_DEBUG_SEVERITY_MEDIUM_KHR*: GLenum = GLenum(0x9147)
  GL_DEBUG_SEVERITY_LOW*: GLenum = GLenum(0x9148)
  GL_DEBUG_SEVERITY_LOW_AMD*: GLenum = GLenum(0x9148)
  GL_DEBUG_SEVERITY_LOW_ARB*: GLenum = GLenum(0x9148)
  GL_DEBUG_SEVERITY_LOW_KHR*: GLenum = GLenum(0x9148)
  GL_DEBUG_CATEGORY_API_ERROR_AMD*: GLenum = GLenum(0x9149)
  GL_DEBUG_CATEGORY_WINDOW_SYSTEM_AMD*: GLenum = GLenum(0x914A)
  GL_DEBUG_CATEGORY_DEPRECATION_AMD*: GLenum = GLenum(0x914B)
  GL_DEBUG_CATEGORY_UNDEFINED_BEHAVIOR_AMD*: GLenum = GLenum(0x914C)
  GL_DEBUG_CATEGORY_PERFORMANCE_AMD*: GLenum = GLenum(0x914D)
  GL_DEBUG_CATEGORY_SHADER_COMPILER_AMD*: GLenum = GLenum(0x914E)
  GL_DEBUG_CATEGORY_APPLICATION_AMD*: GLenum = GLenum(0x914F)
  GL_DEBUG_CATEGORY_OTHER_AMD*: GLenum = GLenum(0x9150)
  GL_BUFFER_OBJECT_EXT*: GLenum = GLenum(0x9151)
  GL_DATA_BUFFER_AMD*: GLenum = GLenum(0x9151)
  GL_PERFORMANCE_MONITOR_AMD*: GLenum = GLenum(0x9152)
  GL_QUERY_OBJECT_AMD*: GLenum = GLenum(0x9153)
  GL_QUERY_OBJECT_EXT*: GLenum = GLenum(0x9153)
  GL_VERTEX_ARRAY_OBJECT_AMD*: GLenum = GLenum(0x9154)
  GL_VERTEX_ARRAY_OBJECT_EXT*: GLenum = GLenum(0x9154)
  GL_SAMPLER_OBJECT_AMD*: GLenum = GLenum(0x9155)
  GL_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD*: GLenum = GLenum(0x9160)
  GL_QUERY_BUFFER*: GLenum = GLenum(0x9192)
  GL_QUERY_BUFFER_AMD*: GLenum = GLenum(0x9192)
  GL_QUERY_BUFFER_BINDING*: GLenum = GLenum(0x9193)
  GL_QUERY_BUFFER_BINDING_AMD*: GLenum = GLenum(0x9193)
  GL_QUERY_RESULT_NO_WAIT*: GLenum = GLenum(0x9194)
  GL_QUERY_RESULT_NO_WAIT_AMD*: GLenum = GLenum(0x9194)
  GL_VIRTUAL_PAGE_SIZE_X_ARB*: GLenum = GLenum(0x9195)
  GL_VIRTUAL_PAGE_SIZE_X_EXT*: GLenum = GLenum(0x9195)
  GL_VIRTUAL_PAGE_SIZE_X_AMD*: GLenum = GLenum(0x9195)
  GL_VIRTUAL_PAGE_SIZE_Y_ARB*: GLenum = GLenum(0x9196)
  GL_VIRTUAL_PAGE_SIZE_Y_EXT*: GLenum = GLenum(0x9196)
  GL_VIRTUAL_PAGE_SIZE_Y_AMD*: GLenum = GLenum(0x9196)
  GL_VIRTUAL_PAGE_SIZE_Z_ARB*: GLenum = GLenum(0x9197)
  GL_VIRTUAL_PAGE_SIZE_Z_EXT*: GLenum = GLenum(0x9197)
  GL_VIRTUAL_PAGE_SIZE_Z_AMD*: GLenum = GLenum(0x9197)
  GL_MAX_SPARSE_TEXTURE_SIZE_ARB*: GLenum = GLenum(0x9198)
  GL_MAX_SPARSE_TEXTURE_SIZE_EXT*: GLenum = GLenum(0x9198)
  GL_MAX_SPARSE_TEXTURE_SIZE_AMD*: GLenum = GLenum(0x9198)
  GL_MAX_SPARSE_3D_TEXTURE_SIZE_ARB*: GLenum = GLenum(0x9199)
  GL_MAX_SPARSE_3D_TEXTURE_SIZE_EXT*: GLenum = GLenum(0x9199)
  GL_MAX_SPARSE_3D_TEXTURE_SIZE_AMD*: GLenum = GLenum(0x9199)
  GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS*: GLenum = GLenum(0x919A)
  GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_ARB*: GLenum = GLenum(0x919A)
  GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_EXT*: GLenum = GLenum(0x919A)
  GL_MIN_SPARSE_LEVEL_AMD*: GLenum = GLenum(0x919B)
  GL_MIN_LOD_WARNING_AMD*: GLenum = GLenum(0x919C)
  GL_TEXTURE_BUFFER_OFFSET*: GLenum = GLenum(0x919D)
  GL_TEXTURE_BUFFER_OFFSET_EXT*: GLenum = GLenum(0x919D)
  GL_TEXTURE_BUFFER_OFFSET_OES*: GLenum = GLenum(0x919D)
  GL_TEXTURE_BUFFER_SIZE*: GLenum = GLenum(0x919E)
  GL_TEXTURE_BUFFER_SIZE_EXT*: GLenum = GLenum(0x919E)
  GL_TEXTURE_BUFFER_SIZE_OES*: GLenum = GLenum(0x919E)
  GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT*: GLenum = GLenum(0x919F)
  GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_EXT*: GLenum = GLenum(0x919F)
  GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_OES*: GLenum = GLenum(0x919F)
  GL_STREAM_RASTERIZATION_AMD*: GLenum = GLenum(0x91A0)
  GL_VERTEX_ELEMENT_SWIZZLE_AMD*: GLenum = GLenum(0x91A4)
  GL_VERTEX_ID_SWIZZLE_AMD*: GLenum = GLenum(0x91A5)
  GL_TEXTURE_SPARSE_ARB*: GLenum = GLenum(0x91A6)
  GL_TEXTURE_SPARSE_EXT*: GLenum = GLenum(0x91A6)
  GL_VIRTUAL_PAGE_SIZE_INDEX_ARB*: GLenum = GLenum(0x91A7)
  GL_VIRTUAL_PAGE_SIZE_INDEX_EXT*: GLenum = GLenum(0x91A7)
  GL_NUM_VIRTUAL_PAGE_SIZES_ARB*: GLenum = GLenum(0x91A8)
  GL_NUM_VIRTUAL_PAGE_SIZES_EXT*: GLenum = GLenum(0x91A8)
  GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_ARB*: GLenum = GLenum(0x91A9)
  GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_EXT*: GLenum = GLenum(0x91A9)
  GL_NUM_SPARSE_LEVELS_ARB*: GLenum = GLenum(0x91AA)
  GL_NUM_SPARSE_LEVELS_EXT*: GLenum = GLenum(0x91AA)
  GL_PIXELS_PER_SAMPLE_PATTERN_X_AMD*: GLenum = GLenum(0x91AE)
  GL_PIXELS_PER_SAMPLE_PATTERN_Y_AMD*: GLenum = GLenum(0x91AF)
  GL_MAX_SHADER_COMPILER_THREADS_KHR*: GLenum = GLenum(0x91B0)
  GL_MAX_SHADER_COMPILER_THREADS_ARB*: GLenum = GLenum(0x91B0)
  GL_COMPLETION_STATUS_KHR*: GLenum = GLenum(0x91B1)
  GL_COMPLETION_STATUS_ARB*: GLenum = GLenum(0x91B1)
  GL_RENDERBUFFER_STORAGE_SAMPLES_AMD*: GLenum = GLenum(0x91B2)
  GL_MAX_COLOR_FRAMEBUFFER_SAMPLES_AMD*: GLenum = GLenum(0x91B3)
  GL_MAX_COLOR_FRAMEBUFFER_STORAGE_SAMPLES_AMD*: GLenum = GLenum(0x91B4)
  GL_MAX_DEPTH_STENCIL_FRAMEBUFFER_SAMPLES_AMD*: GLenum = GLenum(0x91B5)
  GL_NUM_SUPPORTED_MULTISAMPLE_MODES_AMD*: GLenum = GLenum(0x91B6)
  GL_SUPPORTED_MULTISAMPLE_MODES_AMD*: GLenum = GLenum(0x91B7)
  GL_COMPUTE_SHADER*: GLenum = GLenum(0x91B9)
  GL_MAX_COMPUTE_UNIFORM_BLOCKS*: GLenum = GLenum(0x91BB)
  GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS*: GLenum = GLenum(0x91BC)
  GL_MAX_COMPUTE_IMAGE_UNIFORMS*: GLenum = GLenum(0x91BD)
  GL_MAX_COMPUTE_WORK_GROUP_COUNT*: GLenum = GLenum(0x91BE)
  GL_MAX_COMPUTE_WORK_GROUP_SIZE*: GLenum = GLenum(0x91BF)
  GL_MAX_COMPUTE_FIXED_GROUP_SIZE_ARB*: GLenum = GLenum(0x91BF)
  GL_FLOAT16_MAT2_AMD*: GLenum = GLenum(0x91C5)
  GL_FLOAT16_MAT3_AMD*: GLenum = GLenum(0x91C6)
  GL_FLOAT16_MAT4_AMD*: GLenum = GLenum(0x91C7)
  GL_FLOAT16_MAT2x3_AMD*: GLenum = GLenum(0x91C8)
  GL_FLOAT16_MAT2x4_AMD*: GLenum = GLenum(0x91C9)
  GL_FLOAT16_MAT3x2_AMD*: GLenum = GLenum(0x91CA)
  GL_FLOAT16_MAT3x4_AMD*: GLenum = GLenum(0x91CB)
  GL_FLOAT16_MAT4x2_AMD*: GLenum = GLenum(0x91CC)
  GL_FLOAT16_MAT4x3_AMD*: GLenum = GLenum(0x91CD)
  GL_UNPACK_FLIP_Y_WEBGL*: GLenum = GLenum(0x9240)
  GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL*: GLenum = GLenum(0x9241)
  GL_CONTEXT_LOST_WEBGL*: GLenum = GLenum(0x9242)
  GL_UNPACK_COLORSPACE_CONVERSION_WEBGL*: GLenum = GLenum(0x9243)
  GL_BROWSER_DEFAULT_WEBGL*: GLenum = GLenum(0x9244)
  GL_SHADER_BINARY_DMP*: GLenum = GLenum(0x9250)
  GL_SMAPHS30_PROGRAM_BINARY_DMP*: GLenum = GLenum(0x9251)
  GL_SMAPHS_PROGRAM_BINARY_DMP*: GLenum = GLenum(0x9252)
  GL_DMP_PROGRAM_BINARY_DMP*: GLenum = GLenum(0x9253)
  GL_GCCSO_SHADER_BINARY_FJ*: GLenum = GLenum(0x9260)
  GL_COMPRESSED_R11_EAC*: GLenum = GLenum(0x9270)
  GL_COMPRESSED_R11_EAC_OES*: GLenum = GLenum(0x9270)
  GL_COMPRESSED_SIGNED_R11_EAC*: GLenum = GLenum(0x9271)
  GL_COMPRESSED_SIGNED_R11_EAC_OES*: GLenum = GLenum(0x9271)
  GL_COMPRESSED_RG11_EAC*: GLenum = GLenum(0x9272)
  GL_COMPRESSED_RG11_EAC_OES*: GLenum = GLenum(0x9272)
  GL_COMPRESSED_SIGNED_RG11_EAC*: GLenum = GLenum(0x9273)
  GL_COMPRESSED_SIGNED_RG11_EAC_OES*: GLenum = GLenum(0x9273)
  GL_COMPRESSED_RGB8_ETC2*: GLenum = GLenum(0x9274)
  GL_COMPRESSED_RGB8_ETC2_OES*: GLenum = GLenum(0x9274)
  GL_COMPRESSED_SRGB8_ETC2*: GLenum = GLenum(0x9275)
  GL_COMPRESSED_SRGB8_ETC2_OES*: GLenum = GLenum(0x9275)
  GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2*: GLenum = GLenum(0x9276)
  GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2_OES*: GLenum = GLenum(0x9276)
  GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2*: GLenum = GLenum(0x9277)
  GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2_OES*: GLenum = GLenum(0x9277)
  GL_COMPRESSED_RGBA8_ETC2_EAC*: GLenum = GLenum(0x9278)
  GL_COMPRESSED_RGBA8_ETC2_EAC_OES*: GLenum = GLenum(0x9278)
  GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC*: GLenum = GLenum(0x9279)
  GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC_OES*: GLenum = GLenum(0x9279)
  GL_BLEND_PREMULTIPLIED_SRC_NV*: GLenum = GLenum(0x9280)
  GL_BLEND_OVERLAP_NV*: GLenum = GLenum(0x9281)
  GL_UNCORRELATED_NV*: GLenum = GLenum(0x9282)
  GL_DISJOINT_NV*: GLenum = GLenum(0x9283)
  GL_CONJOINT_NV*: GLenum = GLenum(0x9284)
  GL_BLEND_ADVANCED_COHERENT_KHR*: GLenum = GLenum(0x9285)
  GL_BLEND_ADVANCED_COHERENT_NV*: GLenum = GLenum(0x9285)
  GL_SRC_NV*: GLenum = GLenum(0x9286)
  GL_DST_NV*: GLenum = GLenum(0x9287)
  GL_SRC_OVER_NV*: GLenum = GLenum(0x9288)
  GL_DST_OVER_NV*: GLenum = GLenum(0x9289)
  GL_SRC_IN_NV*: GLenum = GLenum(0x928A)
  GL_DST_IN_NV*: GLenum = GLenum(0x928B)
  GL_SRC_OUT_NV*: GLenum = GLenum(0x928C)
  GL_DST_OUT_NV*: GLenum = GLenum(0x928D)
  GL_SRC_ATOP_NV*: GLenum = GLenum(0x928E)
  GL_DST_ATOP_NV*: GLenum = GLenum(0x928F)
  GL_PLUS_NV*: GLenum = GLenum(0x9291)
  GL_PLUS_DARKER_NV*: GLenum = GLenum(0x9292)
  GL_MULTIPLY*: GLenum = GLenum(0x9294)
  GL_MULTIPLY_KHR*: GLenum = GLenum(0x9294)
  GL_MULTIPLY_NV*: GLenum = GLenum(0x9294)
  GL_SCREEN*: GLenum = GLenum(0x9295)
  GL_SCREEN_KHR*: GLenum = GLenum(0x9295)
  GL_SCREEN_NV*: GLenum = GLenum(0x9295)
  GL_OVERLAY*: GLenum = GLenum(0x9296)
  GL_OVERLAY_KHR*: GLenum = GLenum(0x9296)
  GL_OVERLAY_NV*: GLenum = GLenum(0x9296)
  GL_DARKEN*: GLenum = GLenum(0x9297)
  GL_DARKEN_KHR*: GLenum = GLenum(0x9297)
  GL_DARKEN_NV*: GLenum = GLenum(0x9297)
  GL_LIGHTEN*: GLenum = GLenum(0x9298)
  GL_LIGHTEN_KHR*: GLenum = GLenum(0x9298)
  GL_LIGHTEN_NV*: GLenum = GLenum(0x9298)
  GL_COLORDODGE*: GLenum = GLenum(0x9299)
  GL_COLORDODGE_KHR*: GLenum = GLenum(0x9299)
  GL_COLORDODGE_NV*: GLenum = GLenum(0x9299)
  GL_COLORBURN*: GLenum = GLenum(0x929A)
  GL_COLORBURN_KHR*: GLenum = GLenum(0x929A)
  GL_COLORBURN_NV*: GLenum = GLenum(0x929A)
  GL_HARDLIGHT*: GLenum = GLenum(0x929B)
  GL_HARDLIGHT_KHR*: GLenum = GLenum(0x929B)
  GL_HARDLIGHT_NV*: GLenum = GLenum(0x929B)
  GL_SOFTLIGHT*: GLenum = GLenum(0x929C)
  GL_SOFTLIGHT_KHR*: GLenum = GLenum(0x929C)
  GL_SOFTLIGHT_NV*: GLenum = GLenum(0x929C)
  GL_DIFFERENCE*: GLenum = GLenum(0x929E)
  GL_DIFFERENCE_KHR*: GLenum = GLenum(0x929E)
  GL_DIFFERENCE_NV*: GLenum = GLenum(0x929E)
  GL_MINUS_NV*: GLenum = GLenum(0x929F)
  GL_EXCLUSION*: GLenum = GLenum(0x92A0)
  GL_EXCLUSION_KHR*: GLenum = GLenum(0x92A0)
  GL_EXCLUSION_NV*: GLenum = GLenum(0x92A0)
  GL_CONTRAST_NV*: GLenum = GLenum(0x92A1)
  GL_INVERT_RGB_NV*: GLenum = GLenum(0x92A3)
  GL_LINEARDODGE_NV*: GLenum = GLenum(0x92A4)
  GL_LINEARBURN_NV*: GLenum = GLenum(0x92A5)
  GL_VIVIDLIGHT_NV*: GLenum = GLenum(0x92A6)
  GL_LINEARLIGHT_NV*: GLenum = GLenum(0x92A7)
  GL_PINLIGHT_NV*: GLenum = GLenum(0x92A8)
  GL_HARDMIX_NV*: GLenum = GLenum(0x92A9)
  GL_HSL_HUE*: GLenum = GLenum(0x92AD)
  GL_HSL_HUE_KHR*: GLenum = GLenum(0x92AD)
  GL_HSL_HUE_NV*: GLenum = GLenum(0x92AD)
  GL_HSL_SATURATION*: GLenum = GLenum(0x92AE)
  GL_HSL_SATURATION_KHR*: GLenum = GLenum(0x92AE)
  GL_HSL_SATURATION_NV*: GLenum = GLenum(0x92AE)
  GL_HSL_COLOR*: GLenum = GLenum(0x92AF)
  GL_HSL_COLOR_KHR*: GLenum = GLenum(0x92AF)
  GL_HSL_COLOR_NV*: GLenum = GLenum(0x92AF)
  GL_HSL_LUMINOSITY*: GLenum = GLenum(0x92B0)
  GL_HSL_LUMINOSITY_KHR*: GLenum = GLenum(0x92B0)
  GL_HSL_LUMINOSITY_NV*: GLenum = GLenum(0x92B0)
  GL_PLUS_CLAMPED_NV*: GLenum = GLenum(0x92B1)
  GL_PLUS_CLAMPED_ALPHA_NV*: GLenum = GLenum(0x92B2)
  GL_MINUS_CLAMPED_NV*: GLenum = GLenum(0x92B3)
  GL_INVERT_OVG_NV*: GLenum = GLenum(0x92B4)
  GL_MAX_LGPU_GPUS_NVX*: GLenum = GLenum(0x92BA)
  GL_MULTICAST_GPUS_NV*: GLenum = GLenum(0x92BA)
  GL_PURGED_CONTEXT_RESET_NV*: GLenum = GLenum(0x92BB)
  GL_PRIMITIVE_BOUNDING_BOX_ARB*: GLenum = GLenum(0x92BE)
  GL_PRIMITIVE_BOUNDING_BOX*: GLenum = GLenum(0x92BE)
  GL_PRIMITIVE_BOUNDING_BOX_EXT*: GLenum = GLenum(0x92BE)
  GL_PRIMITIVE_BOUNDING_BOX_OES*: GLenum = GLenum(0x92BE)
  GL_ALPHA_TO_COVERAGE_DITHER_MODE_NV*: GLenum = GLenum(0x92BF)
  GL_ATOMIC_COUNTER_BUFFER*: GLenum = GLenum(0x92C0)
  GL_ATOMIC_COUNTER_BUFFER_BINDING*: GLenum = GLenum(0x92C1)
  GL_ATOMIC_COUNTER_BUFFER_START*: GLenum = GLenum(0x92C2)
  GL_ATOMIC_COUNTER_BUFFER_SIZE*: GLenum = GLenum(0x92C3)
  GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE*: GLenum = GLenum(0x92C4)
  GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS*: GLenum = GLenum(0x92C5)
  GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES*: GLenum = GLenum(0x92C6)
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER*: GLenum = GLenum(0x92C7)
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER*: GLenum = GLenum(0x92C8)
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER*: GLenum = GLenum(0x92C9)
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER*: GLenum = GLenum(0x92CA)
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER*: GLenum = GLenum(0x92CB)
  GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS*: GLenum = GLenum(0x92CC)
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS*: GLenum = GLenum(0x92CD)
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_EXT*: GLenum = GLenum(0x92CD)
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_OES*: GLenum = GLenum(0x92CD)
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS*: GLenum = GLenum(0x92CE)
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_EXT*: GLenum = GLenum(0x92CE)
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_OES*: GLenum = GLenum(0x92CE)
  GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS*: GLenum = GLenum(0x92CF)
  GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_EXT*: GLenum = GLenum(0x92CF)
  GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_OES*: GLenum = GLenum(0x92CF)
  GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS*: GLenum = GLenum(0x92D0)
  GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS*: GLenum = GLenum(0x92D1)
  GL_MAX_VERTEX_ATOMIC_COUNTERS*: GLenum = GLenum(0x92D2)
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS*: GLenum = GLenum(0x92D3)
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_EXT*: GLenum = GLenum(0x92D3)
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_OES*: GLenum = GLenum(0x92D3)
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS*: GLenum = GLenum(0x92D4)
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_EXT*: GLenum = GLenum(0x92D4)
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_OES*: GLenum = GLenum(0x92D4)
  GL_MAX_GEOMETRY_ATOMIC_COUNTERS*: GLenum = GLenum(0x92D5)
  GL_MAX_GEOMETRY_ATOMIC_COUNTERS_EXT*: GLenum = GLenum(0x92D5)
  GL_MAX_GEOMETRY_ATOMIC_COUNTERS_OES*: GLenum = GLenum(0x92D5)
  GL_MAX_FRAGMENT_ATOMIC_COUNTERS*: GLenum = GLenum(0x92D6)
  GL_MAX_COMBINED_ATOMIC_COUNTERS*: GLenum = GLenum(0x92D7)
  GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE*: GLenum = GLenum(0x92D8)
  GL_ACTIVE_ATOMIC_COUNTER_BUFFERS*: GLenum = GLenum(0x92D9)
  GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX*: GLenum = GLenum(0x92DA)
  GL_UNSIGNED_INT_ATOMIC_COUNTER*: GLenum = GLenum(0x92DB)


# Loaded Procedures
var
  cglActiveShaderProgram: proc (pipeline: GLuint, program: GLuint): void {.cdecl.}
  cglActiveTexture: proc (texture: GLenum): void {.cdecl.}
  cglVertexAttribIFormat: proc (attribindex: GLuint, size: GLint, `type`: GLenum, relativeoffset: GLuint): void {.cdecl.}
  cglAlphaFuncx: proc (`func`: GLenum, `ref`: GLfixed): void {.cdecl.}
  cglAttachShader: proc (program: GLuint, shader: GLuint): void {.cdecl.}
  cglBeginConditionalRender: proc (id: GLuint, mode: GLenum): void {.cdecl.}
  cglBeginQuery: proc (target: GLenum, id: GLuint): void {.cdecl.}
  cglBeginQueryIndexed: proc (target: GLenum, index: GLuint, id: GLuint): void {.cdecl.}
  cglBeginTransformFeedback: proc (primitiveMode: GLenum): void {.cdecl.}
  cglBindAttribLocation: proc (program: GLuint, index: GLuint, name: cstring): void {.cdecl.}
  cglBindBuffer: proc (target: GLenum, buffer: GLuint): void {.cdecl.}
  cglBindBufferBase: proc (target: GLenum, index: GLuint, buffer: GLuint): void {.cdecl.}
  cglBindBufferRange: proc (target: GLenum, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr): void {.cdecl.}
  cglBindBuffersBase: proc (target: GLenum, first: GLuint, count: GLsizei, buffers: ptr GLuint): void {.cdecl.}
  cglBindBuffersRange: proc (target: GLenum, first: GLuint, count: GLsizei, buffers: ptr GLuint, offsets: ptr GLintptr, sizes: ptr GLsizeiptr): void {.cdecl.}
  cglBindFragDataLocation: proc (program: GLuint, color: GLuint, name: cstring): void {.cdecl.}
  cglBindFragDataLocationIndexed: proc (program: GLuint, colorNumber: GLuint, index: GLuint, name: cstring): void {.cdecl.}
  cglBindFramebuffer: proc (target: GLenum, framebuffer: GLuint): void {.cdecl.}
  cglBindImageTexture: proc (unit: GLuint, texture: GLuint, level: GLint, layered: GLboolean, layer: GLint, access: GLenum, format: GLenum): void {.cdecl.}
  cglBindImageTextures: proc (first: GLuint, count: GLsizei, textures: ptr GLuint): void {.cdecl.}
  cglBindProgramPipeline: proc (pipeline: GLuint): void {.cdecl.}
  cglBindRenderbuffer: proc (target: GLenum, renderbuffer: GLuint): void {.cdecl.}
  cglBindSampler: proc (unit: GLuint, sampler: GLuint): void {.cdecl.}
  cglBindSamplers: proc (first: GLuint, count: GLsizei, samplers: ptr GLuint): void {.cdecl.}
  cglBindTexture: proc (target: GLenum, texture: GLuint): void {.cdecl.}
  cglBindTextureUnit: proc (unit: GLuint, texture: GLuint): void {.cdecl.}
  cglBindTextures: proc (first: GLuint, count: GLsizei, textures: ptr GLuint): void {.cdecl.}
  cglBindTransformFeedback: proc (target: GLenum, id: GLuint): void {.cdecl.}
  cglBindVertexArray: proc (array: GLuint): void {.cdecl.}
  cglBindVertexBuffer: proc (bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei): void {.cdecl.}
  cglBindVertexBuffers: proc (first: GLuint, count: GLsizei, buffers: ptr GLuint, offsets: ptr GLintptr, strides: ptr GLsizei): void {.cdecl.}
  cglBlendBarrier: proc (): void {.cdecl.}
  cglBlendColor: proc (red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat): void {.cdecl.}
  cglBlendEquation: proc (mode: GLenum): void {.cdecl.}
  cglBlendEquationSeparate: proc (modeRGB: GLenum, modeAlpha: GLenum): void {.cdecl.}
  cglBlendEquationSeparatei: proc (buf: GLuint, modeRGB: GLenum, modeAlpha: GLenum): void {.cdecl.}
  cglBlendEquationi: proc (buf: GLuint, mode: GLenum): void {.cdecl.}
  cglBlendFunc: proc (sfactor: GLenum, dfactor: GLenum): void {.cdecl.}
  cglBlendFuncSeparate: proc (sfactorRGB: GLenum, dfactorRGB: GLenum, sfactorAlpha: GLenum, dfactorAlpha: GLenum): void {.cdecl.}
  cglBlendFuncSeparatei: proc (buf: GLuint, srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum): void {.cdecl.}
  cglBlendFunci: proc (buf: GLuint, src: GLenum, dst: GLenum): void {.cdecl.}
  cglBlitFramebuffer: proc (srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum): void {.cdecl.}
  cglBlitNamedFramebuffer: proc (readFramebuffer: GLuint, drawFramebuffer: GLuint, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum): void {.cdecl.}
  cglBufferData: proc (target: GLenum, size: GLsizeiptr, data: pointer, usage: GLenum): void {.cdecl.}
  cglBufferStorage: proc (target: GLenum, size: GLsizeiptr, data: pointer, flags: GLbitfield): void {.cdecl.}
  cglBufferSubData: proc (target: GLenum, offset: GLintptr, size: GLsizeiptr, data: pointer): void {.cdecl.}
  cglCheckFramebufferStatus: proc (target: GLenum): GLenum {.cdecl.}
  cglCheckNamedFramebufferStatus: proc (framebuffer: GLuint, target: GLenum): GLenum {.cdecl.}
  cglClampColor: proc (target: GLenum, clamp: GLenum): void {.cdecl.}
  cglClear: proc (mask: GLbitfield): void {.cdecl.}
  cglClearBufferData: proc (target: GLenum, internalformat: GLenum, format: GLenum, `type`: GLenum, data: pointer): void {.cdecl.}
  cglClearBufferSubData: proc (target: GLenum, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, `type`: GLenum, data: pointer): void {.cdecl.}
  cglClearBufferfi: proc (buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint): void {.cdecl.}
  cglClearBufferfv: proc (buffer: GLenum, drawbuffer: GLint, value: ptr GLfloat): void {.cdecl.}
  cglClearBufferiv: proc (buffer: GLenum, drawbuffer: GLint, value: ptr GLint): void {.cdecl.}
  cglClearBufferuiv: proc (buffer: GLenum, drawbuffer: GLint, value: ptr GLuint): void {.cdecl.}
  cglClearColor: proc (red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat): void {.cdecl.}
  cglClearColorx: proc (red: GLfixed, green: GLfixed, blue: GLfixed, alpha: GLfixed): void {.cdecl.}
  cglClearDepth: proc (depth: GLdouble): void {.cdecl.}
  cglClearDepthf: proc (d: GLfloat): void {.cdecl.}
  cglClearDepthx: proc (depth: GLfixed): void {.cdecl.}
  cglClearNamedBufferData: proc (buffer: GLuint, internalformat: GLenum, format: GLenum, `type`: GLenum, data: pointer): void {.cdecl.}
  cglClearNamedBufferSubData: proc (buffer: GLuint, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, `type`: GLenum, data: pointer): void {.cdecl.}
  cglClearNamedFramebufferfi: proc (framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint): void {.cdecl.}
  cglClearNamedFramebufferfv: proc (framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: ptr GLfloat): void {.cdecl.}
  cglClearNamedFramebufferiv: proc (framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: ptr GLint): void {.cdecl.}
  cglClearNamedFramebufferuiv: proc (framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: ptr GLuint): void {.cdecl.}
  cglClearStencil: proc (s: GLint): void {.cdecl.}
  cglClearTexImage: proc (texture: GLuint, level: GLint, format: GLenum, `type`: GLenum, data: pointer): void {.cdecl.}
  cglClearTexSubImage: proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, `type`: GLenum, data: pointer): void {.cdecl.}
  cglVertexAttrib4sv: proc (index: GLuint, v: ptr GLshort): void {.cdecl.}
  cglClientWaitSync: proc (sync: GLsync, flags: GLbitfield, timeout: GLuint64): GLenum {.cdecl.}
  cglClipControl: proc (origin: GLenum, depth: GLenum): void {.cdecl.}
  cglClipPlanef: proc (p: GLenum, eqn: ptr GLfloat): void {.cdecl.}
  cglClipPlanex: proc (plane: GLenum, equation: ptr GLfixed): void {.cdecl.}
  cglVertexAttrib2dv: proc (index: GLuint, v: ptr GLdouble): void {.cdecl.}
  cglVertexAttrib2f: proc (index: GLuint, x: GLfloat, y: GLfloat): void {.cdecl.}
  cglColor4x: proc (red: GLfixed, green: GLfixed, blue: GLfixed, alpha: GLfixed): void {.cdecl.}
  cglColorMask: proc (red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean): void {.cdecl.}
  cglColorMaski: proc (index: GLuint, r: GLboolean, g: GLboolean, b: GLboolean, a: GLboolean): void {.cdecl.}
  cglColorP3ui: proc (`type`: GLenum, color: GLuint): void {.cdecl.}
  cglColorP3uiv: proc (`type`: GLenum, color: ptr GLuint): void {.cdecl.}
  cglColorP4ui: proc (`type`: GLenum, color: GLuint): void {.cdecl.}
  cglColorP4uiv: proc (`type`: GLenum, color: ptr GLuint): void {.cdecl.}
  cglCompileShader: proc (shader: GLuint): void {.cdecl.}
  cglCompressedTexImage1D: proc (target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, border: GLint, imageSize: GLsizei, data: pointer): void {.cdecl.}
  cglCompressedTexImage2D: proc (target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, imageSize: GLsizei, data: pointer): void {.cdecl.}
  cglCompressedTexImage3D: proc (target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, data: pointer): void {.cdecl.}
  cglCompressedTexSubImage1D: proc (target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void {.cdecl.}
  cglCompressedTexSubImage2D: proc (target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void {.cdecl.}
  cglCompressedTexSubImage3D: proc (target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void {.cdecl.}
  cglCompressedTextureSubImage1D: proc (texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void {.cdecl.}
  cglCompressedTextureSubImage2D: proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void {.cdecl.}
  cglCompressedTextureSubImage3D: proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void {.cdecl.}
  cglCopyBufferSubData: proc (readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr): void {.cdecl.}
  cglCopyImageSubData: proc (srcName: GLuint, srcTarget: GLenum, srcLevel: GLint, srcX: GLint, srcY: GLint, srcZ: GLint, dstName: GLuint, dstTarget: GLenum, dstLevel: GLint, dstX: GLint, dstY: GLint, dstZ: GLint, srcWidth: GLsizei, srcHeight: GLsizei, srcDepth: GLsizei): void {.cdecl.}
  cglCopyNamedBufferSubData: proc (readBuffer: GLuint, writeBuffer: GLuint, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr): void {.cdecl.}
  cglCopyTexImage1D: proc (target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, border: GLint): void {.cdecl.}
  cglCopyTexImage2D: proc (target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint): void {.cdecl.}
  cglCopyTexSubImage1D: proc (target: GLenum, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei): void {.cdecl.}
  cglCopyTexSubImage2D: proc (target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}
  cglCopyTexSubImage3D: proc (target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}
  cglCopyTextureSubImage1D: proc (texture: GLuint, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei): void {.cdecl.}
  cglCopyTextureSubImage2D: proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}
  cglCopyTextureSubImage3D: proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}
  cglCreateBuffers: proc (n: GLsizei, buffers: ptr GLuint): void {.cdecl.}
  cglCreateFramebuffers: proc (n: GLsizei, framebuffers: ptr GLuint): void {.cdecl.}
  cglCreateProgram: proc (): GLuint {.cdecl.}
  cglCreateProgramPipelines: proc (n: GLsizei, pipelines: ptr GLuint): void {.cdecl.}
  cglCreateQueries: proc (target: GLenum, n: GLsizei, ids: ptr GLuint): void {.cdecl.}
  cglCreateRenderbuffers: proc (n: GLsizei, renderbuffers: ptr GLuint): void {.cdecl.}
  cglCreateSamplers: proc (n: GLsizei, samplers: ptr GLuint): void {.cdecl.}
  cglCreateShader: proc (`type`: GLenum): GLuint {.cdecl.}
  cglCreateShaderProgramv: proc (`type`: GLenum, count: GLsizei, strings: ptr cstring): GLuint {.cdecl.}
  cglCreateTextures: proc (target: GLenum, n: GLsizei, textures: ptr GLuint): void {.cdecl.}
  cglCreateTransformFeedbacks: proc (n: GLsizei, ids: ptr GLuint): void {.cdecl.}
  cglCreateVertexArrays: proc (n: GLsizei, arrays: ptr GLuint): void {.cdecl.}
  cglCullFace: proc (mode: GLenum): void {.cdecl.}
  cglDebugMessageCallback: proc (callback: GLDEBUGPROC, userParam: pointer): void {.cdecl.}
  cglDebugMessageControl: proc (source: GLenum, `type`: GLenum, severity: GLenum, count: GLsizei, ids: ptr GLuint, enabled: GLboolean): void {.cdecl.}
  cglDebugMessageInsert: proc (source: GLenum, `type`: GLenum, id: GLuint, severity: GLenum, length: GLsizei, buf: cstring): void {.cdecl.}
  cglDeleteBuffers: proc (n: GLsizei, buffers: ptr GLuint): void {.cdecl.}
  cglDeleteFramebuffers: proc (n: GLsizei, framebuffers: ptr GLuint): void {.cdecl.}
  cglDeleteProgram: proc (program: GLuint): void {.cdecl.}
  cglDeleteProgramPipelines: proc (n: GLsizei, pipelines: ptr GLuint): void {.cdecl.}
  cglDeleteQueries: proc (n: GLsizei, ids: ptr GLuint): void {.cdecl.}
  cglDeleteRenderbuffers: proc (n: GLsizei, renderbuffers: ptr GLuint): void {.cdecl.}
  cglDeleteSamplers: proc (count: GLsizei, samplers: ptr GLuint): void {.cdecl.}
  cglDeleteShader: proc (shader: GLuint): void {.cdecl.}
  cglDeleteSync: proc (sync: GLsync): void {.cdecl.}
  cglDeleteTextures: proc (n: GLsizei, textures: ptr GLuint): void {.cdecl.}
  cglDeleteTransformFeedbacks: proc (n: GLsizei, ids: ptr GLuint): void {.cdecl.}
  cglDeleteVertexArrays: proc (n: GLsizei, arrays: ptr GLuint): void {.cdecl.}
  cglDepthFunc: proc (`func`: GLenum): void {.cdecl.}
  cglDepthMask: proc (flag: GLboolean): void {.cdecl.}
  cglDepthRange: proc (n: GLdouble, f: GLdouble): void {.cdecl.}
  cglDepthRangeArrayv: proc (first: GLuint, count: GLsizei, v: ptr GLdouble): void {.cdecl.}
  cglDepthRangeIndexed: proc (index: GLuint, n: GLdouble, f: GLdouble): void {.cdecl.}
  cglDepthRangef: proc (n: GLfloat, f: GLfloat): void {.cdecl.}
  cglDepthRangex: proc (n: GLfixed, f: GLfixed): void {.cdecl.}
  cglDetachShader: proc (program: GLuint, shader: GLuint): void {.cdecl.}
  cglDisable: proc (cap: GLenum): void {.cdecl.}
  cglDisableVertexArrayAttrib: proc (vaobj: GLuint, index: GLuint): void {.cdecl.}
  cglDisableVertexAttribArray: proc (index: GLuint): void {.cdecl.}
  cglDisablei: proc (target: GLenum, index: GLuint): void {.cdecl.}
  cglDispatchCompute: proc (num_groups_x: GLuint, num_groups_y: GLuint, num_groups_z: GLuint): void {.cdecl.}
  cglDispatchComputeIndirect: proc (indirect: GLintptr): void {.cdecl.}
  cglDrawArrays: proc (mode: GLenum, first: GLint, count: GLsizei): void {.cdecl.}
  cglDrawArraysIndirect: proc (mode: GLenum, indirect: pointer): void {.cdecl.}
  cglDrawArraysInstanced: proc (mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei): void {.cdecl.}
  cglDrawArraysInstancedBaseInstance: proc (mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei, baseinstance: GLuint): void {.cdecl.}
  cglDrawBuffer: proc (buf: GLenum): void {.cdecl.}
  cglDrawBuffers: proc (n: GLsizei, bufs: ptr GLenum): void {.cdecl.}
  cglDrawElements: proc (mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer): void {.cdecl.}
  cglDrawElementsBaseVertex: proc (mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer, basevertex: GLint): void {.cdecl.}
  cglDrawElementsIndirect: proc (mode: GLenum, `type`: GLenum, indirect: pointer): void {.cdecl.}
  cglDrawElementsInstanced: proc (mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer, instancecount: GLsizei): void {.cdecl.}
  cglDrawElementsInstancedBaseInstance: proc (mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer, instancecount: GLsizei, baseinstance: GLuint): void {.cdecl.}
  cglDrawElementsInstancedBaseVertex: proc (mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer, instancecount: GLsizei, basevertex: GLint): void {.cdecl.}
  cglDrawElementsInstancedBaseVertexBaseInstance: proc (mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer, instancecount: GLsizei, basevertex: GLint, baseinstance: GLuint): void {.cdecl.}
  cglVertexAttribI4ubv: proc (index: GLuint, v: ptr GLubyte): void {.cdecl.}
  cglDrawRangeElements: proc (mode: GLenum, start: GLuint, `end`: GLuint, count: GLsizei, `type`: GLenum, indices: pointer): void {.cdecl.}
  cglDrawRangeElementsBaseVertex: proc (mode: GLenum, start: GLuint, `end`: GLuint, count: GLsizei, `type`: GLenum, indices: pointer, basevertex: GLint): void {.cdecl.}
  cglDrawTransformFeedback: proc (mode: GLenum, id: GLuint): void {.cdecl.}
  cglDrawTransformFeedbackInstanced: proc (mode: GLenum, id: GLuint, instancecount: GLsizei): void {.cdecl.}
  cglDrawTransformFeedbackStream: proc (mode: GLenum, id: GLuint, stream: GLuint): void {.cdecl.}
  cglDrawTransformFeedbackStreamInstanced: proc (mode: GLenum, id: GLuint, stream: GLuint, instancecount: GLsizei): void {.cdecl.}
  cglVertexAttrib2fv: proc (index: GLuint, v: ptr GLfloat): void {.cdecl.}
  cglEnable: proc (cap: GLenum): void {.cdecl.}
  cglVertexAttribDivisor: proc (index: GLuint, divisor: GLuint): void {.cdecl.}
  cglEnableVertexArrayAttrib: proc (vaobj: GLuint, index: GLuint): void {.cdecl.}
  cglEnableVertexAttribArray: proc (index: GLuint): void {.cdecl.}
  cglEnablei: proc (target: GLenum, index: GLuint): void {.cdecl.}
  cglEndConditionalRender: proc (): void {.cdecl.}
  cglEndQuery: proc (target: GLenum): void {.cdecl.}
  cglEndQueryIndexed: proc (target: GLenum, index: GLuint): void {.cdecl.}
  cglEndTransformFeedback: proc (): void {.cdecl.}
  cglVertexAttribL1dv: proc (index: GLuint, v: ptr GLdouble): void {.cdecl.}
  cglVertexAttribL1d: proc (index: GLuint, x: GLdouble): void {.cdecl.}
  cglVertexAttribIPointer: proc (index: GLuint, size: GLint, `type`: GLenum, stride: GLsizei, pointer: pointer): void {.cdecl.}
  cglFenceSync: proc (condition: GLenum, flags: GLbitfield): GLsync {.cdecl.}
  cglFinish: proc (): void {.cdecl.}
  cglFlush: proc (): void {.cdecl.}
  cglFlushMappedBufferRange: proc (target: GLenum, offset: GLintptr, length: GLsizeiptr): void {.cdecl.}
  cglFlushMappedNamedBufferRange: proc (buffer: GLuint, offset: GLintptr, length: GLsizeiptr): void {.cdecl.}
  cglVertexAttrib3s: proc (index: GLuint, x: GLshort, y: GLshort, z: GLshort): void {.cdecl.}
  cglVertexAttrib3sv: proc (index: GLuint, v: ptr GLshort): void {.cdecl.}
  cglFogx: proc (pname: GLenum, param: GLfixed): void {.cdecl.}
  cglFogxv: proc (pname: GLenum, param: ptr GLfixed): void {.cdecl.}
  cglFramebufferParameteri: proc (target: GLenum, pname: GLenum, param: GLint): void {.cdecl.}
  cglFramebufferRenderbuffer: proc (target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint): void {.cdecl.}
  cglFramebufferTexture: proc (target: GLenum, attachment: GLenum, texture: GLuint, level: GLint): void {.cdecl.}
  cglFramebufferTexture1D: proc (target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint): void {.cdecl.}
  cglFramebufferTexture2D: proc (target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint): void {.cdecl.}
  cglFramebufferTexture3D: proc (target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint, zoffset: GLint): void {.cdecl.}
  cglFramebufferTextureLayer: proc (target: GLenum, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint): void {.cdecl.}
  cglFrontFace: proc (mode: GLenum): void {.cdecl.}
  cglFrustumf: proc (l: GLfloat, r: GLfloat, b: GLfloat, t: GLfloat, n: GLfloat, f: GLfloat): void {.cdecl.}
  cglFrustumx: proc (l: GLfixed, r: GLfixed, b: GLfixed, t: GLfixed, n: GLfixed, f: GLfixed): void {.cdecl.}
  cglGenBuffers: proc (n: GLsizei, buffers: ptr GLuint): void {.cdecl.}
  cglGenFramebuffers: proc (n: GLsizei, framebuffers: ptr GLuint): void {.cdecl.}
  cglGenProgramPipelines: proc (n: GLsizei, pipelines: ptr GLuint): void {.cdecl.}
  cglGenQueries: proc (n: GLsizei, ids: ptr GLuint): void {.cdecl.}
  cglGenRenderbuffers: proc (n: GLsizei, renderbuffers: ptr GLuint): void {.cdecl.}
  cglGenSamplers: proc (count: GLsizei, samplers: ptr GLuint): void {.cdecl.}
  cglGenTextures: proc (n: GLsizei, textures: ptr GLuint): void {.cdecl.}
  cglGenTransformFeedbacks: proc (n: GLsizei, ids: ptr GLuint): void {.cdecl.}
  cglGenVertexArrays: proc (n: GLsizei, arrays: ptr GLuint): void {.cdecl.}
  cglGenerateMipmap: proc (target: GLenum): void {.cdecl.}
  cglGenerateTextureMipmap: proc (texture: GLuint): void {.cdecl.}
  cglGetActiveAtomicCounterBufferiv: proc (program: GLuint, bufferIndex: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetActiveAttrib: proc (program: GLuint, index: GLuint, bufSize: GLsizei, length: ptr GLsizei, size: ptr GLint, `type`: ptr GLenum, name: cstring): void {.cdecl.}
  cglGetActiveSubroutineName: proc (program: GLuint, shadertype: GLenum, index: GLuint, bufsize: GLsizei, length: ptr GLsizei, name: cstring): void {.cdecl.}
  cglGetActiveSubroutineUniformName: proc (program: GLuint, shadertype: GLenum, index: GLuint, bufsize: GLsizei, length: ptr GLsizei, name: cstring): void {.cdecl.}
  cglGetActiveSubroutineUniformiv: proc (program: GLuint, shadertype: GLenum, index: GLuint, pname: GLenum, values: ptr GLint): void {.cdecl.}
  cglGetActiveUniform: proc (program: GLuint, index: GLuint, bufSize: GLsizei, length: ptr GLsizei, size: ptr GLint, `type`: ptr GLenum, name: cstring): void {.cdecl.}
  cglGetActiveUniformBlockName: proc (program: GLuint, uniformBlockIndex: GLuint, bufSize: GLsizei, length: ptr GLsizei, uniformBlockName: cstring): void {.cdecl.}
  cglGetActiveUniformBlockiv: proc (program: GLuint, uniformBlockIndex: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetActiveUniformName: proc (program: GLuint, uniformIndex: GLuint, bufSize: GLsizei, length: ptr GLsizei, uniformName: cstring): void {.cdecl.}
  cglGetActiveUniformsiv: proc (program: GLuint, uniformCount: GLsizei, uniformIndices: ptr GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetAttachedShaders: proc (program: GLuint, maxCount: GLsizei, count: ptr GLsizei, shaders: ptr GLuint): void {.cdecl.}
  cglGetAttribLocation: proc (program: GLuint, name: cstring): GLint {.cdecl.}
  cglGetBooleani_v: proc (target: GLenum, index: GLuint, data: ptr GLboolean): void {.cdecl.}
  cglGetBooleanv: proc (pname: GLenum, data: ptr GLboolean): void {.cdecl.}
  cglGetBufferParameteri64v: proc (target: GLenum, pname: GLenum, params: ptr GLint64): void {.cdecl.}
  cglGetBufferParameteriv: proc (target: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetBufferPointerv: proc (target: GLenum, pname: GLenum, params: ptr pointer): void {.cdecl.}
  cglGetBufferSubData: proc (target: GLenum, offset: GLintptr, size: GLsizeiptr, data: pointer): void {.cdecl.}
  cglGetClipPlanef: proc (plane: GLenum, equation: ptr GLfloat): void {.cdecl.}
  cglGetClipPlanex: proc (plane: GLenum, equation: ptr GLfixed): void {.cdecl.}
  cglGetCompressedTexImage: proc (target: GLenum, level: GLint, img: pointer): void {.cdecl.}
  cglGetCompressedTextureImage: proc (texture: GLuint, level: GLint, bufSize: GLsizei, pixels: pointer): void {.cdecl.}
  cglGetCompressedTextureSubImage: proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, bufSize: GLsizei, pixels: pointer): void {.cdecl.}
  cglGetDebugMessageLog: proc (count: GLuint, bufSize: GLsizei, sources: ptr GLenum, types: ptr GLenum, ids: ptr GLuint, severities: ptr GLenum, lengths: ptr GLsizei, messageLog: cstring): GLuint {.cdecl.}
  cglGetDoublei_v: proc (target: GLenum, index: GLuint, data: ptr GLdouble): void {.cdecl.}
  cglGetDoublev: proc (pname: GLenum, data: ptr GLdouble): void {.cdecl.}
  cglGetError: proc (): GLenum {.cdecl.}
  cglGetFixedv: proc (pname: GLenum, params: ptr GLfixed): void {.cdecl.}
  cglGetFloati_v: proc (target: GLenum, index: GLuint, data: ptr GLfloat): void {.cdecl.}
  cglGetFloatv: proc (pname: GLenum, data: ptr GLfloat): void {.cdecl.}
  cglGetFragDataIndex: proc (program: GLuint, name: cstring): GLint {.cdecl.}
  cglGetFragDataLocation: proc (program: GLuint, name: cstring): GLint {.cdecl.}
  cglGetFramebufferAttachmentParameteriv: proc (target: GLenum, attachment: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetFramebufferParameteriv: proc (target: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetGraphicsResetStatus: proc (): GLenum {.cdecl.}
  cglGetInteger64i_v: proc (target: GLenum, index: GLuint, data: ptr GLint64): void {.cdecl.}
  cglGetInteger64v: proc (pname: GLenum, data: ptr GLint64): void {.cdecl.}
  cglGetIntegeri_v: proc (target: GLenum, index: GLuint, data: ptr GLint): void {.cdecl.}
  cglGetIntegerv: proc (pname: GLenum, data: ptr GLint): void {.cdecl.}
  cglGetInternalformati64v: proc (target: GLenum, internalformat: GLenum, pname: GLenum, bufSize: GLsizei, params: ptr GLint64): void {.cdecl.}
  cglGetInternalformativ: proc (target: GLenum, internalformat: GLenum, pname: GLenum, bufSize: GLsizei, params: ptr GLint): void {.cdecl.}
  cglVertexAttribI4sv: proc (index: GLuint, v: ptr GLshort): void {.cdecl.}
  cglGetLightxv: proc (light: GLenum, pname: GLenum, params: ptr GLfixed): void {.cdecl.}
  cglVertexAttribI4iv: proc (index: GLuint, v: ptr GLint): void {.cdecl.}
  cglVertexAttribI4i: proc (index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint): void {.cdecl.}
  cglVertexAttribI4bv: proc (index: GLuint, v: ptr GLbyte): void {.cdecl.}
  cglGetMaterialxv: proc (face: GLenum, pname: GLenum, params: ptr GLfixed): void {.cdecl.}
  cglGetMultisamplefv: proc (pname: GLenum, index: GLuint, val: ptr GLfloat): void {.cdecl.}
  cglGetNamedBufferParameteri64v: proc (buffer: GLuint, pname: GLenum, params: ptr GLint64): void {.cdecl.}
  cglGetNamedBufferParameteriv: proc (buffer: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetNamedBufferPointerv: proc (buffer: GLuint, pname: GLenum, params: ptr pointer): void {.cdecl.}
  cglGetNamedBufferSubData: proc (buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: pointer): void {.cdecl.}
  cglGetNamedFramebufferAttachmentParameteriv: proc (framebuffer: GLuint, attachment: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetNamedFramebufferParameteriv: proc (framebuffer: GLuint, pname: GLenum, param: ptr GLint): void {.cdecl.}
  cglGetNamedRenderbufferParameteriv: proc (renderbuffer: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetObjectLabel: proc (identifier: GLenum, name: GLuint, bufSize: GLsizei, length: ptr GLsizei, label: cstring): void {.cdecl.}
  cglGetObjectPtrLabel: proc (`ptr`: pointer, bufSize: GLsizei, length: ptr GLsizei, label: cstring): void {.cdecl.}
  cglVertexAttribI3uiv: proc (index: GLuint, v: ptr GLuint): void {.cdecl.}
  cglVertexAttribI3ui: proc (index: GLuint, x: GLuint, y: GLuint, z: GLuint): void {.cdecl.}
  cglGetProgramBinary: proc (program: GLuint, bufSize: GLsizei, length: ptr GLsizei, binaryFormat: ptr GLenum, binary: pointer): void {.cdecl.}
  cglGetProgramInfoLog: proc (program: GLuint, bufSize: GLsizei, length: ptr GLsizei, infoLog: cstring): void {.cdecl.}
  cglGetProgramInterfaceiv: proc (program: GLuint, programInterface: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetProgramPipelineInfoLog: proc (pipeline: GLuint, bufSize: GLsizei, length: ptr GLsizei, infoLog: cstring): void {.cdecl.}
  cglGetProgramPipelineiv: proc (pipeline: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetProgramResourceIndex: proc (program: GLuint, programInterface: GLenum, name: cstring): GLuint {.cdecl.}
  cglGetProgramResourceLocation: proc (program: GLuint, programInterface: GLenum, name: cstring): GLint {.cdecl.}
  cglGetProgramResourceLocationIndex: proc (program: GLuint, programInterface: GLenum, name: cstring): GLint {.cdecl.}
  cglGetProgramResourceName: proc (program: GLuint, programInterface: GLenum, index: GLuint, bufSize: GLsizei, length: ptr GLsizei, name: cstring): void {.cdecl.}
  cglGetProgramResourceiv: proc (program: GLuint, programInterface: GLenum, index: GLuint, propCount: GLsizei, props: ptr GLenum, bufSize: GLsizei, length: ptr GLsizei, params: ptr GLint): void {.cdecl.}
  cglGetProgramStageiv: proc (program: GLuint, shadertype: GLenum, pname: GLenum, values: ptr GLint): void {.cdecl.}
  cglGetProgramiv: proc (program: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetQueryBufferObjecti64v: proc (id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr): void {.cdecl.}
  cglGetQueryBufferObjectiv: proc (id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr): void {.cdecl.}
  cglGetQueryBufferObjectui64v: proc (id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr): void {.cdecl.}
  cglGetQueryBufferObjectuiv: proc (id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr): void {.cdecl.}
  cglGetQueryIndexediv: proc (target: GLenum, index: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetQueryObjecti64v: proc (id: GLuint, pname: GLenum, params: ptr GLint64): void {.cdecl.}
  cglGetQueryObjectiv: proc (id: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetQueryObjectui64v: proc (id: GLuint, pname: GLenum, params: ptr GLuint64): void {.cdecl.}
  cglGetQueryObjectuiv: proc (id: GLuint, pname: GLenum, params: ptr GLuint): void {.cdecl.}
  cglGetQueryiv: proc (target: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetRenderbufferParameteriv: proc (target: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetSamplerParameterIiv: proc (sampler: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetSamplerParameterIuiv: proc (sampler: GLuint, pname: GLenum, params: ptr GLuint): void {.cdecl.}
  cglGetSamplerParameterfv: proc (sampler: GLuint, pname: GLenum, params: ptr GLfloat): void {.cdecl.}
  cglGetSamplerParameteriv: proc (sampler: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetShaderInfoLog: proc (shader: GLuint, bufSize: GLsizei, length: ptr GLsizei, infoLog: cstring): void {.cdecl.}
  cglGetShaderPrecisionFormat: proc (shadertype: GLenum, precisiontype: GLenum, range: ptr GLint, precision: ptr GLint): void {.cdecl.}
  cglGetShaderSource: proc (shader: GLuint, bufSize: GLsizei, length: ptr GLsizei, source: cstring): void {.cdecl.}
  cglGetShaderiv: proc (shader: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetString: proc (name: GLenum): ptr GLubyte {.cdecl.}
  cglGetStringi: proc (name: GLenum, index: GLuint): ptr GLubyte {.cdecl.}
  cglGetSubroutineIndex: proc (program: GLuint, shadertype: GLenum, name: cstring): GLuint {.cdecl.}
  cglGetSubroutineUniformLocation: proc (program: GLuint, shadertype: GLenum, name: cstring): GLint {.cdecl.}
  cglGetSynciv: proc (sync: GLsync, pname: GLenum, bufSize: GLsizei, length: ptr GLsizei, values: ptr GLint): void {.cdecl.}
  cglVertexAttribI3iv: proc (index: GLuint, v: ptr GLint): void {.cdecl.}
  cglGetTexEnvxv: proc (target: GLenum, pname: GLenum, params: ptr GLfixed): void {.cdecl.}
  cglVertexAttribI3i: proc (index: GLuint, x: GLint, y: GLint, z: GLint): void {.cdecl.}
  cglGetTexImage: proc (target: GLenum, level: GLint, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}
  cglGetTexLevelParameterfv: proc (target: GLenum, level: GLint, pname: GLenum, params: ptr GLfloat): void {.cdecl.}
  cglGetTexLevelParameteriv: proc (target: GLenum, level: GLint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetTexParameterIiv: proc (target: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetTexParameterIuiv: proc (target: GLenum, pname: GLenum, params: ptr GLuint): void {.cdecl.}
  cglGetTexParameterfv: proc (target: GLenum, pname: GLenum, params: ptr GLfloat): void {.cdecl.}
  cglGetTexParameteriv: proc (target: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetTexParameterxv: proc (target: GLenum, pname: GLenum, params: ptr GLfixed): void {.cdecl.}
  cglGetTextureImage: proc (texture: GLuint, level: GLint, format: GLenum, `type`: GLenum, bufSize: GLsizei, pixels: pointer): void {.cdecl.}
  cglGetTextureLevelParameterfv: proc (texture: GLuint, level: GLint, pname: GLenum, params: ptr GLfloat): void {.cdecl.}
  cglGetTextureLevelParameteriv: proc (texture: GLuint, level: GLint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetTextureParameterIiv: proc (texture: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetTextureParameterIuiv: proc (texture: GLuint, pname: GLenum, params: ptr GLuint): void {.cdecl.}
  cglGetTextureParameterfv: proc (texture: GLuint, pname: GLenum, params: ptr GLfloat): void {.cdecl.}
  cglGetTextureParameteriv: proc (texture: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetTextureSubImage: proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, `type`: GLenum, bufSize: GLsizei, pixels: pointer): void {.cdecl.}
  cglGetTransformFeedbackVarying: proc (program: GLuint, index: GLuint, bufSize: GLsizei, length: ptr GLsizei, size: ptr GLsizei, `type`: ptr GLenum, name: cstring): void {.cdecl.}
  cglGetTransformFeedbacki64_v: proc (xfb: GLuint, pname: GLenum, index: GLuint, param: ptr GLint64): void {.cdecl.}
  cglGetTransformFeedbackiv: proc (xfb: GLuint, pname: GLenum, param: ptr GLint): void {.cdecl.}
  cglGetUniformBlockIndex: proc (program: GLuint, uniformBlockName: cstring): GLuint {.cdecl.}
  cglGetUniformIndices: proc (program: GLuint, uniformCount: GLsizei, uniformNames: ptr cstring, uniformIndices: ptr GLuint): void {.cdecl.}
  cglGetUniformLocation: proc (program: GLuint, name: cstring): GLint {.cdecl.}
  cglGetUniformSubroutineuiv: proc (shadertype: GLenum, location: GLint, params: ptr GLuint): void {.cdecl.}
  cglGetUniformdv: proc (program: GLuint, location: GLint, params: ptr GLdouble): void {.cdecl.}
  cglGetUniformfv: proc (program: GLuint, location: GLint, params: ptr GLfloat): void {.cdecl.}
  cglGetUniformiv: proc (program: GLuint, location: GLint, params: ptr GLint): void {.cdecl.}
  cglGetUniformuiv: proc (program: GLuint, location: GLint, params: ptr GLuint): void {.cdecl.}
  cglGetVertexArrayIndexed64iv: proc (vaobj: GLuint, index: GLuint, pname: GLenum, param: ptr GLint64): void {.cdecl.}
  cglGetVertexArrayIndexediv: proc (vaobj: GLuint, index: GLuint, pname: GLenum, param: ptr GLint): void {.cdecl.}
  cglGetVertexArrayiv: proc (vaobj: GLuint, pname: GLenum, param: ptr GLint): void {.cdecl.}
  cglGetVertexAttribIiv: proc (index: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetVertexAttribIuiv: proc (index: GLuint, pname: GLenum, params: ptr GLuint): void {.cdecl.}
  cglGetVertexAttribLdv: proc (index: GLuint, pname: GLenum, params: ptr GLdouble): void {.cdecl.}
  cglGetVertexAttribPointerv: proc (index: GLuint, pname: GLenum, pointer: ptr pointer): void {.cdecl.}
  cglGetVertexAttribdv: proc (index: GLuint, pname: GLenum, params: ptr GLdouble): void {.cdecl.}
  cglGetVertexAttribfv: proc (index: GLuint, pname: GLenum, params: ptr GLfloat): void {.cdecl.}
  cglGetVertexAttribiv: proc (index: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglGetnColorTable: proc (target: GLenum, format: GLenum, `type`: GLenum, bufSize: GLsizei, table: pointer): void {.cdecl.}
  cglGetnCompressedTexImage: proc (target: GLenum, lod: GLint, bufSize: GLsizei, pixels: pointer): void {.cdecl.}
  cglGetnConvolutionFilter: proc (target: GLenum, format: GLenum, `type`: GLenum, bufSize: GLsizei, image: pointer): void {.cdecl.}
  cglGetnHistogram: proc (target: GLenum, reset: GLboolean, format: GLenum, `type`: GLenum, bufSize: GLsizei, values: pointer): void {.cdecl.}
  cglGetnMapdv: proc (target: GLenum, query: GLenum, bufSize: GLsizei, v: ptr GLdouble): void {.cdecl.}
  cglGetnMapfv: proc (target: GLenum, query: GLenum, bufSize: GLsizei, v: ptr GLfloat): void {.cdecl.}
  cglGetnMapiv: proc (target: GLenum, query: GLenum, bufSize: GLsizei, v: ptr GLint): void {.cdecl.}
  cglGetnMinmax: proc (target: GLenum, reset: GLboolean, format: GLenum, `type`: GLenum, bufSize: GLsizei, values: pointer): void {.cdecl.}
  cglGetnPixelMapfv: proc (map: GLenum, bufSize: GLsizei, values: ptr GLfloat): void {.cdecl.}
  cglGetnPixelMapuiv: proc (map: GLenum, bufSize: GLsizei, values: ptr GLuint): void {.cdecl.}
  cglGetnPixelMapusv: proc (map: GLenum, bufSize: GLsizei, values: ptr GLushort): void {.cdecl.}
  cglGetnPolygonStipple: proc (bufSize: GLsizei, pattern: ptr GLubyte): void {.cdecl.}
  cglGetnSeparableFilter: proc (target: GLenum, format: GLenum, `type`: GLenum, rowBufSize: GLsizei, row: pointer, columnBufSize: GLsizei, column: pointer, span: pointer): void {.cdecl.}
  cglGetnTexImage: proc (target: GLenum, level: GLint, format: GLenum, `type`: GLenum, bufSize: GLsizei, pixels: pointer): void {.cdecl.}
  cglGetnUniformdv: proc (program: GLuint, location: GLint, bufSize: GLsizei, params: ptr GLdouble): void {.cdecl.}
  cglGetnUniformfv: proc (program: GLuint, location: GLint, bufSize: GLsizei, params: ptr GLfloat): void {.cdecl.}
  cglGetnUniformiv: proc (program: GLuint, location: GLint, bufSize: GLsizei, params: ptr GLint): void {.cdecl.}
  cglGetnUniformuiv: proc (program: GLuint, location: GLint, bufSize: GLsizei, params: ptr GLuint): void {.cdecl.}
  cglHint: proc (target: GLenum, mode: GLenum): void {.cdecl.}
  cglVertexAttribL3dv: proc (index: GLuint, v: ptr GLdouble): void {.cdecl.}
  cglVertexAttribBinding: proc (attribindex: GLuint, bindingindex: GLuint): void {.cdecl.}
  cglVertexAttrib4ubv: proc (index: GLuint, v: ptr GLubyte): void {.cdecl.}
  cglInvalidateBufferData: proc (buffer: GLuint): void {.cdecl.}
  cglInvalidateBufferSubData: proc (buffer: GLuint, offset: GLintptr, length: GLsizeiptr): void {.cdecl.}
  cglInvalidateFramebuffer: proc (target: GLenum, numAttachments: GLsizei, attachments: ptr GLenum): void {.cdecl.}
  cglInvalidateNamedFramebufferData: proc (framebuffer: GLuint, numAttachments: GLsizei, attachments: ptr GLenum): void {.cdecl.}
  cglInvalidateNamedFramebufferSubData: proc (framebuffer: GLuint, numAttachments: GLsizei, attachments: ptr GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}
  cglInvalidateSubFramebuffer: proc (target: GLenum, numAttachments: GLsizei, attachments: ptr GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}
  cglInvalidateTexImage: proc (texture: GLuint, level: GLint): void {.cdecl.}
  cglInvalidateTexSubImage: proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei): void {.cdecl.}
  cglIsBuffer: proc (buffer: GLuint): GLboolean {.cdecl.}
  cglIsEnabled: proc (cap: GLenum): GLboolean {.cdecl.}
  cglIsEnabledi: proc (target: GLenum, index: GLuint): GLboolean {.cdecl.}
  cglIsFramebuffer: proc (framebuffer: GLuint): GLboolean {.cdecl.}
  cglVertexAttribI2uiv: proc (index: GLuint, v: ptr GLuint): void {.cdecl.}
  cglIsProgram: proc (program: GLuint): GLboolean {.cdecl.}
  cglIsProgramPipeline: proc (pipeline: GLuint): GLboolean {.cdecl.}
  cglIsQuery: proc (id: GLuint): GLboolean {.cdecl.}
  cglIsRenderbuffer: proc (renderbuffer: GLuint): GLboolean {.cdecl.}
  cglIsSampler: proc (sampler: GLuint): GLboolean {.cdecl.}
  cglIsShader: proc (shader: GLuint): GLboolean {.cdecl.}
  cglIsSync: proc (sync: GLsync): GLboolean {.cdecl.}
  cglIsTexture: proc (texture: GLuint): GLboolean {.cdecl.}
  cglIsTransformFeedback: proc (id: GLuint): GLboolean {.cdecl.}
  cglIsVertexArray: proc (array: GLuint): GLboolean {.cdecl.}
  cglLightModelx: proc (pname: GLenum, param: GLfixed): void {.cdecl.}
  cglLightModelxv: proc (pname: GLenum, param: ptr GLfixed): void {.cdecl.}
  cglLightx: proc (light: GLenum, pname: GLenum, param: GLfixed): void {.cdecl.}
  cglLightxv: proc (light: GLenum, pname: GLenum, params: ptr GLfixed): void {.cdecl.}
  cglVertexAttribPointer: proc (index: GLuint, size: GLint, `type`: GLenum, normalized: GLboolean, stride: GLsizei, pointer: pointer): void {.cdecl.}
  cglLineWidth: proc (width: GLfloat): void {.cdecl.}
  cglLineWidthx: proc (width: GLfixed): void {.cdecl.}
  cglLinkProgram: proc (program: GLuint): void {.cdecl.}
  cglVertexAttribI2ui: proc (index: GLuint, x: GLuint, y: GLuint): void {.cdecl.}
  cglVertexAttribI2iv: proc (index: GLuint, v: ptr GLint): void {.cdecl.}
  cglLoadMatrixx: proc (m: ptr GLfixed): void {.cdecl.}
  cglVertexAttribL4d: proc (index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble): void {.cdecl.}
  cglVertexAttrib4Niv: proc (index: GLuint, v: ptr GLint): void {.cdecl.}
  cglLogicOp: proc (opcode: GLenum): void {.cdecl.}
  cglMapBuffer: proc (target: GLenum, access: GLenum): pointer {.cdecl.}
  cglMapBufferRange: proc (target: GLenum, offset: GLintptr, length: GLsizeiptr, access: GLbitfield): pointer {.cdecl.}
  cglVertexAttribL2dv: proc (index: GLuint, v: ptr GLdouble): void {.cdecl.}
  cglVertexAttribL2d: proc (index: GLuint, x: GLdouble, y: GLdouble): void {.cdecl.}
  cglMapNamedBuffer: proc (buffer: GLuint, access: GLenum): pointer {.cdecl.}
  cglMapNamedBufferRange: proc (buffer: GLuint, offset: GLintptr, length: GLsizeiptr, access: GLbitfield): pointer {.cdecl.}
  cglVertexAttribP4uiv: proc (index: GLuint, `type`: GLenum, normalized: GLboolean, value: ptr GLuint): void {.cdecl.}
  cglVertexAttribP4ui: proc (index: GLuint, `type`: GLenum, normalized: GLboolean, value: GLuint): void {.cdecl.}
  cglVertexAttribP3uiv: proc (index: GLuint, `type`: GLenum, normalized: GLboolean, value: ptr GLuint): void {.cdecl.}
  cglMaterialx: proc (face: GLenum, pname: GLenum, param: GLfixed): void {.cdecl.}
  cglMaterialxv: proc (face: GLenum, pname: GLenum, param: ptr GLfixed): void {.cdecl.}
  cglMemoryBarrier: proc (barriers: GLbitfield): void {.cdecl.}
  cglMemoryBarrierByRegion: proc (barriers: GLbitfield): void {.cdecl.}
  cglMinSampleShading: proc (value: GLfloat): void {.cdecl.}
  cglVertexAttribI2i: proc (index: GLuint, x: GLint, y: GLint): void {.cdecl.}
  cglMultMatrixx: proc (m: ptr GLfixed): void {.cdecl.}
  cglVertexAttrib4Nbv: proc (index: GLuint, v: ptr GLbyte): void {.cdecl.}
  cglMultiDrawArrays: proc (mode: GLenum, first: ptr GLint, count: ptr GLsizei, drawcount: GLsizei): void {.cdecl.}
  cglMultiDrawArraysIndirect: proc (mode: GLenum, indirect: pointer, drawcount: GLsizei, stride: GLsizei): void {.cdecl.}
  cglMultiDrawArraysIndirectCount: proc (mode: GLenum, indirect: pointer, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei): void {.cdecl.}
  cglMultiDrawElements: proc (mode: GLenum, count: ptr GLsizei, `type`: GLenum, indices: ptr pointer, drawcount: GLsizei): void {.cdecl.}
  cglMultiDrawElementsBaseVertex: proc (mode: GLenum, count: ptr GLsizei, `type`: GLenum, indices: ptr pointer, drawcount: GLsizei, basevertex: ptr GLint): void {.cdecl.}
  cglMultiDrawElementsIndirect: proc (mode: GLenum, `type`: GLenum, indirect: pointer, drawcount: GLsizei, stride: GLsizei): void {.cdecl.}
  cglMultiDrawElementsIndirectCount: proc (mode: GLenum, `type`: GLenum, indirect: pointer, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei): void {.cdecl.}
  cglVertexAttrib4s: proc (index: GLuint, x: GLshort, y: GLshort, z: GLshort, w: GLshort): void {.cdecl.}
  cglVertexAttrib4iv: proc (index: GLuint, v: ptr GLint): void {.cdecl.}
  cglVertexAttrib4fv: proc (index: GLuint, v: ptr GLfloat): void {.cdecl.}
  cglVertexAttrib4f: proc (index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void {.cdecl.}
  cglVertexAttrib4dv: proc (index: GLuint, v: ptr GLdouble): void {.cdecl.}
  cglVertexAttrib4d: proc (index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble): void {.cdecl.}
  cglVertexAttrib4bv: proc (index: GLuint, v: ptr GLbyte): void {.cdecl.}
  cglVertexAttrib4Nusv: proc (index: GLuint, v: ptr GLushort): void {.cdecl.}
  cglVertexAttrib4Nuiv: proc (index: GLuint, v: ptr GLuint): void {.cdecl.}
  cglVertexAttrib4Nubv: proc (index: GLuint, v: ptr GLubyte): void {.cdecl.}
  cglVertexAttrib4Nub: proc (index: GLuint, x: GLubyte, y: GLubyte, z: GLubyte, w: GLubyte): void {.cdecl.}
  cglVertexAttrib4Nsv: proc (index: GLuint, v: ptr GLshort): void {.cdecl.}
  cglMultiTexCoord4x: proc (texture: GLenum, s: GLfixed, t: GLfixed, r: GLfixed, q: GLfixed): void {.cdecl.}
  cglMultiTexCoordP1ui: proc (texture: GLenum, `type`: GLenum, coords: GLuint): void {.cdecl.}
  cglMultiTexCoordP1uiv: proc (texture: GLenum, `type`: GLenum, coords: ptr GLuint): void {.cdecl.}
  cglMultiTexCoordP2ui: proc (texture: GLenum, `type`: GLenum, coords: GLuint): void {.cdecl.}
  cglMultiTexCoordP2uiv: proc (texture: GLenum, `type`: GLenum, coords: ptr GLuint): void {.cdecl.}
  cglMultiTexCoordP3ui: proc (texture: GLenum, `type`: GLenum, coords: GLuint): void {.cdecl.}
  cglMultiTexCoordP3uiv: proc (texture: GLenum, `type`: GLenum, coords: ptr GLuint): void {.cdecl.}
  cglMultiTexCoordP4ui: proc (texture: GLenum, `type`: GLenum, coords: GLuint): void {.cdecl.}
  cglMultiTexCoordP4uiv: proc (texture: GLenum, `type`: GLenum, coords: ptr GLuint): void {.cdecl.}
  cglNamedBufferData: proc (buffer: GLuint, size: GLsizeiptr, data: pointer, usage: GLenum): void {.cdecl.}
  cglNamedBufferStorage: proc (buffer: GLuint, size: GLsizeiptr, data: pointer, flags: GLbitfield): void {.cdecl.}
  cglNamedBufferSubData: proc (buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: pointer): void {.cdecl.}
  cglNamedFramebufferDrawBuffer: proc (framebuffer: GLuint, buf: GLenum): void {.cdecl.}
  cglNamedFramebufferDrawBuffers: proc (framebuffer: GLuint, n: GLsizei, bufs: ptr GLenum): void {.cdecl.}
  cglNamedFramebufferParameteri: proc (framebuffer: GLuint, pname: GLenum, param: GLint): void {.cdecl.}
  cglNamedFramebufferReadBuffer: proc (framebuffer: GLuint, src: GLenum): void {.cdecl.}
  cglNamedFramebufferRenderbuffer: proc (framebuffer: GLuint, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint): void {.cdecl.}
  cglNamedFramebufferTexture: proc (framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint): void {.cdecl.}
  cglNamedFramebufferTextureLayer: proc (framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint): void {.cdecl.}
  cglNamedRenderbufferStorage: proc (renderbuffer: GLuint, internalformat: GLenum, width: GLsizei, height: GLsizei): void {.cdecl.}
  cglNamedRenderbufferStorageMultisample: proc (renderbuffer: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void {.cdecl.}
  cglVertexAttrib2s: proc (index: GLuint, x: GLshort, y: GLshort): void {.cdecl.}
  cglNormal3x: proc (nx: GLfixed, ny: GLfixed, nz: GLfixed): void {.cdecl.}
  cglNormalP3ui: proc (`type`: GLenum, coords: GLuint): void {.cdecl.}
  cglNormalP3uiv: proc (`type`: GLenum, coords: ptr GLuint): void {.cdecl.}
  cglVertexAttrib4usv: proc (index: GLuint, v: ptr GLushort): void {.cdecl.}
  cglObjectLabel: proc (identifier: GLenum, name: GLuint, length: GLsizei, label: cstring): void {.cdecl.}
  cglObjectPtrLabel: proc (`ptr`: pointer, length: GLsizei, label: cstring): void {.cdecl.}
  cglVertexAttribI1uiv: proc (index: GLuint, v: ptr GLuint): void {.cdecl.}
  cglOrthof: proc (l: GLfloat, r: GLfloat, b: GLfloat, t: GLfloat, n: GLfloat, f: GLfloat): void {.cdecl.}
  cglOrthox: proc (l: GLfixed, r: GLfixed, b: GLfixed, t: GLfixed, n: GLfixed, f: GLfixed): void {.cdecl.}
  cglPatchParameterfv: proc (pname: GLenum, values: ptr GLfloat): void {.cdecl.}
  cglPatchParameteri: proc (pname: GLenum, value: GLint): void {.cdecl.}
  cglPauseTransformFeedback: proc (): void {.cdecl.}
  cglVertexAttribI4uiv: proc (index: GLuint, v: ptr GLuint): void {.cdecl.}
  cglVertexAttribI4ui: proc (index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint): void {.cdecl.}
  cglPixelStoref: proc (pname: GLenum, param: GLfloat): void {.cdecl.}
  cglPixelStorei: proc (pname: GLenum, param: GLint): void {.cdecl.}
  cglVertexAttribI4usv: proc (index: GLuint, v: ptr GLushort): void {.cdecl.}
  cglPointParameterf: proc (pname: GLenum, param: GLfloat): void {.cdecl.}
  cglPointParameterfv: proc (pname: GLenum, params: ptr GLfloat): void {.cdecl.}
  cglPointParameteri: proc (pname: GLenum, param: GLint): void {.cdecl.}
  cglPointParameteriv: proc (pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglPointParameterx: proc (pname: GLenum, param: GLfixed): void {.cdecl.}
  cglPointParameterxv: proc (pname: GLenum, params: ptr GLfixed): void {.cdecl.}
  cglPointSize: proc (size: GLfloat): void {.cdecl.}
  cglPointSizex: proc (size: GLfixed): void {.cdecl.}
  cglPolygonMode: proc (face: GLenum, mode: GLenum): void {.cdecl.}
  cglPolygonOffset: proc (factor: GLfloat, units: GLfloat): void {.cdecl.}
  cglPolygonOffsetClamp: proc (factor: GLfloat, units: GLfloat, clamp: GLfloat): void {.cdecl.}
  cglPolygonOffsetx: proc (factor: GLfixed, units: GLfixed): void {.cdecl.}
  cglVertexAttribP3ui: proc (index: GLuint, `type`: GLenum, normalized: GLboolean, value: GLuint): void {.cdecl.}
  cglVertexAttribL3d: proc (index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble): void {.cdecl.}
  cglPopDebugGroup: proc (): void {.cdecl.}
  cglPrimitiveBoundingBox: proc (minX: GLfloat, minY: GLfloat, minZ: GLfloat, minW: GLfloat, maxX: GLfloat, maxY: GLfloat, maxZ: GLfloat, maxW: GLfloat): void {.cdecl.}
  cglPrimitiveRestartIndex: proc (index: GLuint): void {.cdecl.}
  cglProgramBinary: proc (program: GLuint, binaryFormat: GLenum, binary: pointer, length: GLsizei): void {.cdecl.}
  cglProgramParameteri: proc (program: GLuint, pname: GLenum, value: GLint): void {.cdecl.}
  cglProgramUniform1d: proc (program: GLuint, location: GLint, v0: GLdouble): void {.cdecl.}
  cglProgramUniform1dv: proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLdouble): void {.cdecl.}
  cglProgramUniform1f: proc (program: GLuint, location: GLint, v0: GLfloat): void {.cdecl.}
  cglProgramUniform1fv: proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLfloat): void {.cdecl.}
  cglProgramUniform1i: proc (program: GLuint, location: GLint, v0: GLint): void {.cdecl.}
  cglProgramUniform1iv: proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLint): void {.cdecl.}
  cglProgramUniform1ui: proc (program: GLuint, location: GLint, v0: GLuint): void {.cdecl.}
  cglProgramUniform1uiv: proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLuint): void {.cdecl.}
  cglProgramUniform2d: proc (program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble): void {.cdecl.}
  cglProgramUniform2dv: proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLdouble): void {.cdecl.}
  cglProgramUniform2f: proc (program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat): void {.cdecl.}
  cglProgramUniform2fv: proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLfloat): void {.cdecl.}
  cglProgramUniform2i: proc (program: GLuint, location: GLint, v0: GLint, v1: GLint): void {.cdecl.}
  cglProgramUniform2iv: proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLint): void {.cdecl.}
  cglProgramUniform2ui: proc (program: GLuint, location: GLint, v0: GLuint, v1: GLuint): void {.cdecl.}
  cglProgramUniform2uiv: proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLuint): void {.cdecl.}
  cglProgramUniform3d: proc (program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble): void {.cdecl.}
  cglProgramUniform3dv: proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLdouble): void {.cdecl.}
  cglProgramUniform3f: proc (program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat): void {.cdecl.}
  cglProgramUniform3fv: proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLfloat): void {.cdecl.}
  cglProgramUniform3i: proc (program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint): void {.cdecl.}
  cglProgramUniform3iv: proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLint): void {.cdecl.}
  cglProgramUniform3ui: proc (program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint): void {.cdecl.}
  cglProgramUniform3uiv: proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLuint): void {.cdecl.}
  cglProgramUniform4d: proc (program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble, v3: GLdouble): void {.cdecl.}
  cglProgramUniform4dv: proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLdouble): void {.cdecl.}
  cglProgramUniform4f: proc (program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat): void {.cdecl.}
  cglProgramUniform4fv: proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLfloat): void {.cdecl.}
  cglProgramUniform4i: proc (program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint): void {.cdecl.}
  cglProgramUniform4iv: proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLint): void {.cdecl.}
  cglProgramUniform4ui: proc (program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint): void {.cdecl.}
  cglProgramUniform4uiv: proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLuint): void {.cdecl.}
  cglProgramUniformMatrix2dv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglProgramUniformMatrix2fv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglProgramUniformMatrix2x3dv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglProgramUniformMatrix2x3fv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglProgramUniformMatrix2x4dv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglProgramUniformMatrix2x4fv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglProgramUniformMatrix3dv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglProgramUniformMatrix3fv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglProgramUniformMatrix3x2dv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglProgramUniformMatrix3x2fv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglProgramUniformMatrix3x4dv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglProgramUniformMatrix3x4fv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglProgramUniformMatrix4dv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglProgramUniformMatrix4fv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglProgramUniformMatrix4x2dv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglProgramUniformMatrix4x2fv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglProgramUniformMatrix4x3dv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglProgramUniformMatrix4x3fv: proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglProvokingVertex: proc (mode: GLenum): void {.cdecl.}
  cglPushDebugGroup: proc (source: GLenum, id: GLuint, length: GLsizei, message: cstring): void {.cdecl.}
  cglVertexAttribI1ui: proc (index: GLuint, x: GLuint): void {.cdecl.}
  cglQueryCounter: proc (id: GLuint, target: GLenum): void {.cdecl.}
  cglWaitSync: proc (sync: GLsync, flags: GLbitfield, timeout: GLuint64): void {.cdecl.}
  cglViewportIndexedfv: proc (index: GLuint, v: ptr GLfloat): void {.cdecl.}
  cglViewportIndexedf: proc (index: GLuint, x: GLfloat, y: GLfloat, w: GLfloat, h: GLfloat): void {.cdecl.}
  cglReadBuffer: proc (src: GLenum): void {.cdecl.}
  cglReadPixels: proc (x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}
  cglReadnPixels: proc (x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, `type`: GLenum, bufSize: GLsizei, data: pointer): void {.cdecl.}
  cglViewportArrayv: proc (first: GLuint, count: GLsizei, v: ptr GLfloat): void {.cdecl.}
  cglViewport: proc (x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}
  cglReleaseShaderCompiler: proc (): void {.cdecl.}
  cglVertexAttribL4dv: proc (index: GLuint, v: ptr GLdouble): void {.cdecl.}
  cglRenderbufferStorage: proc (target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei): void {.cdecl.}
  cglRenderbufferStorageMultisample: proc (target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void {.cdecl.}
  cglResumeTransformFeedback: proc (): void {.cdecl.}
  cglVertexAttribI1iv: proc (index: GLuint, v: ptr GLint): void {.cdecl.}
  cglRotatex: proc (angle: GLfixed, x: GLfixed, y: GLfixed, z: GLfixed): void {.cdecl.}
  cglSampleCoverage: proc (value: GLfloat, invert: GLboolean): void {.cdecl.}
  cglSampleCoveragex: proc (value: GLclampx, invert: GLboolean): void {.cdecl.}
  cglSampleMaski: proc (maskNumber: GLuint, mask: GLbitfield): void {.cdecl.}
  cglSamplerParameterIiv: proc (sampler: GLuint, pname: GLenum, param: ptr GLint): void {.cdecl.}
  cglSamplerParameterIuiv: proc (sampler: GLuint, pname: GLenum, param: ptr GLuint): void {.cdecl.}
  cglSamplerParameterf: proc (sampler: GLuint, pname: GLenum, param: GLfloat): void {.cdecl.}
  cglSamplerParameterfv: proc (sampler: GLuint, pname: GLenum, param: ptr GLfloat): void {.cdecl.}
  cglSamplerParameteri: proc (sampler: GLuint, pname: GLenum, param: GLint): void {.cdecl.}
  cglSamplerParameteriv: proc (sampler: GLuint, pname: GLenum, param: ptr GLint): void {.cdecl.}
  cglVertexAttribI1i: proc (index: GLuint, x: GLint): void {.cdecl.}
  cglScalex: proc (x: GLfixed, y: GLfixed, z: GLfixed): void {.cdecl.}
  cglScissor: proc (x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}
  cglScissorArrayv: proc (first: GLuint, count: GLsizei, v: ptr GLint): void {.cdecl.}
  cglScissorIndexed: proc (index: GLuint, left: GLint, bottom: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}
  cglScissorIndexedv: proc (index: GLuint, v: ptr GLint): void {.cdecl.}
  cglVertexAttrib3fv: proc (index: GLuint, v: ptr GLfloat): void {.cdecl.}
  cglVertexAttrib3f: proc (index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat): void {.cdecl.}
  cglVertexAttrib3dv: proc (index: GLuint, v: ptr GLdouble): void {.cdecl.}
  cglVertexAttrib3d: proc (index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble): void {.cdecl.}
  cglSecondaryColorP3ui: proc (`type`: GLenum, color: GLuint): void {.cdecl.}
  cglSecondaryColorP3uiv: proc (`type`: GLenum, color: ptr GLuint): void {.cdecl.}
  cglVertexAttrib2sv: proc (index: GLuint, v: ptr GLshort): void {.cdecl.}
  cglVertexAttribP2uiv: proc (index: GLuint, `type`: GLenum, normalized: GLboolean, value: ptr GLuint): void {.cdecl.}
  cglShaderBinary: proc (count: GLsizei, shaders: ptr GLuint, binaryformat: GLenum, binary: pointer, length: GLsizei): void {.cdecl.}
  cglShaderSource: proc (shader: GLuint, count: GLsizei, string: ptr cstring, length: ptr GLint): void {.cdecl.}
  cglShaderStorageBlockBinding: proc (program: GLuint, storageBlockIndex: GLuint, storageBlockBinding: GLuint): void {.cdecl.}
  cglSpecializeShader: proc (shader: GLuint, pEntryPoint: cstring, numSpecializationConstants: GLuint, pConstantIndex: ptr GLuint, pConstantValue: ptr GLuint): void {.cdecl.}
  cglStencilFunc: proc (`func`: GLenum, `ref`: GLint, mask: GLuint): void {.cdecl.}
  cglStencilFuncSeparate: proc (face: GLenum, `func`: GLenum, `ref`: GLint, mask: GLuint): void {.cdecl.}
  cglStencilMask: proc (mask: GLuint): void {.cdecl.}
  cglStencilMaskSeparate: proc (face: GLenum, mask: GLuint): void {.cdecl.}
  cglStencilOp: proc (fail: GLenum, zfail: GLenum, zpass: GLenum): void {.cdecl.}
  cglStencilOpSeparate: proc (face: GLenum, sfail: GLenum, dpfail: GLenum, dppass: GLenum): void {.cdecl.}
  cglTexBuffer: proc (target: GLenum, internalformat: GLenum, buffer: GLuint): void {.cdecl.}
  cglTexBufferRange: proc (target: GLenum, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr): void {.cdecl.}
  cglTexCoordP1ui: proc (`type`: GLenum, coords: GLuint): void {.cdecl.}
  cglTexCoordP1uiv: proc (`type`: GLenum, coords: ptr GLuint): void {.cdecl.}
  cglTexCoordP2ui: proc (`type`: GLenum, coords: GLuint): void {.cdecl.}
  cglTexCoordP2uiv: proc (`type`: GLenum, coords: ptr GLuint): void {.cdecl.}
  cglTexCoordP3ui: proc (`type`: GLenum, coords: GLuint): void {.cdecl.}
  cglTexCoordP3uiv: proc (`type`: GLenum, coords: ptr GLuint): void {.cdecl.}
  cglTexCoordP4ui: proc (`type`: GLenum, coords: GLuint): void {.cdecl.}
  cglTexCoordP4uiv: proc (`type`: GLenum, coords: ptr GLuint): void {.cdecl.}
  cglVertexAttribP2ui: proc (index: GLuint, `type`: GLenum, normalized: GLboolean, value: GLuint): void {.cdecl.}
  cglVertexAttribP1uiv: proc (index: GLuint, `type`: GLenum, normalized: GLboolean, value: ptr GLuint): void {.cdecl.}
  cglVertexAttribP1ui: proc (index: GLuint, `type`: GLenum, normalized: GLboolean, value: GLuint): void {.cdecl.}
  cglTexEnvx: proc (target: GLenum, pname: GLenum, param: GLfixed): void {.cdecl.}
  cglTexEnvxv: proc (target: GLenum, pname: GLenum, params: ptr GLfixed): void {.cdecl.}
  cglVertexAttribLPointer: proc (index: GLuint, size: GLint, `type`: GLenum, stride: GLsizei, pointer: pointer): void {.cdecl.}
  cglVertexAttribLFormat: proc (attribindex: GLuint, size: GLint, `type`: GLenum, relativeoffset: GLuint): void {.cdecl.}
  cglTexImage1D: proc (target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, border: GLint, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}
  cglTexImage2D: proc (target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}
  cglTexImage2DMultisample: proc (target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean): void {.cdecl.}
  cglTexImage3D: proc (target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}
  cglTexImage3DMultisample: proc (target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean): void {.cdecl.}
  cglTexParameterIiv: proc (target: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglTexParameterIuiv: proc (target: GLenum, pname: GLenum, params: ptr GLuint): void {.cdecl.}
  cglTexParameterf: proc (target: GLenum, pname: GLenum, param: GLfloat): void {.cdecl.}
  cglTexParameterfv: proc (target: GLenum, pname: GLenum, params: ptr GLfloat): void {.cdecl.}
  cglTexParameteri: proc (target: GLenum, pname: GLenum, param: GLint): void {.cdecl.}
  cglTexParameteriv: proc (target: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglTexParameterx: proc (target: GLenum, pname: GLenum, param: GLfixed): void {.cdecl.}
  cglTexParameterxv: proc (target: GLenum, pname: GLenum, params: ptr GLfixed): void {.cdecl.}
  cglTexStorage1D: proc (target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei): void {.cdecl.}
  cglTexStorage2D: proc (target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void {.cdecl.}
  cglTexStorage2DMultisample: proc (target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean): void {.cdecl.}
  cglTexStorage3D: proc (target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei): void {.cdecl.}
  cglTexStorage3DMultisample: proc (target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean): void {.cdecl.}
  cglTexSubImage1D: proc (target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}
  cglTexSubImage2D: proc (target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}
  cglTexSubImage3D: proc (target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}
  cglTextureBarrier: proc (): void {.cdecl.}
  cglTextureBuffer: proc (texture: GLuint, internalformat: GLenum, buffer: GLuint): void {.cdecl.}
  cglTextureBufferRange: proc (texture: GLuint, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr): void {.cdecl.}
  cglTextureParameterIiv: proc (texture: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}
  cglTextureParameterIuiv: proc (texture: GLuint, pname: GLenum, params: ptr GLuint): void {.cdecl.}
  cglTextureParameterf: proc (texture: GLuint, pname: GLenum, param: GLfloat): void {.cdecl.}
  cglTextureParameterfv: proc (texture: GLuint, pname: GLenum, param: ptr GLfloat): void {.cdecl.}
  cglTextureParameteri: proc (texture: GLuint, pname: GLenum, param: GLint): void {.cdecl.}
  cglTextureParameteriv: proc (texture: GLuint, pname: GLenum, param: ptr GLint): void {.cdecl.}
  cglTextureStorage1D: proc (texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei): void {.cdecl.}
  cglTextureStorage2D: proc (texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void {.cdecl.}
  cglTextureStorage2DMultisample: proc (texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean): void {.cdecl.}
  cglTextureStorage3D: proc (texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei): void {.cdecl.}
  cglTextureStorage3DMultisample: proc (texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean): void {.cdecl.}
  cglTextureSubImage1D: proc (texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}
  cglTextureSubImage2D: proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}
  cglTextureSubImage3D: proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}
  cglTextureView: proc (texture: GLuint, target: GLenum, origtexture: GLuint, internalformat: GLenum, minlevel: GLuint, numlevels: GLuint, minlayer: GLuint, numlayers: GLuint): void {.cdecl.}
  cglTransformFeedbackBufferBase: proc (xfb: GLuint, index: GLuint, buffer: GLuint): void {.cdecl.}
  cglTransformFeedbackBufferRange: proc (xfb: GLuint, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr): void {.cdecl.}
  cglTransformFeedbackVaryings: proc (program: GLuint, count: GLsizei, varyings: ptr cstring, bufferMode: GLenum): void {.cdecl.}
  cglVertexAttribFormat: proc (attribindex: GLuint, size: GLint, `type`: GLenum, normalized: GLboolean, relativeoffset: GLuint): void {.cdecl.}
  cglTranslatex: proc (x: GLfixed, y: GLfixed, z: GLfixed): void {.cdecl.}
  cglUniform1d: proc (location: GLint, x: GLdouble): void {.cdecl.}
  cglUniform1dv: proc (location: GLint, count: GLsizei, value: ptr GLdouble): void {.cdecl.}
  cglUniform1f: proc (location: GLint, v0: GLfloat): void {.cdecl.}
  cglUniform1fv: proc (location: GLint, count: GLsizei, value: ptr GLfloat): void {.cdecl.}
  cglUniform1i: proc (location: GLint, v0: GLint): void {.cdecl.}
  cglUniform1iv: proc (location: GLint, count: GLsizei, value: ptr GLint): void {.cdecl.}
  cglUniform1ui: proc (location: GLint, v0: GLuint): void {.cdecl.}
  cglUniform1uiv: proc (location: GLint, count: GLsizei, value: ptr GLuint): void {.cdecl.}
  cglUniform2d: proc (location: GLint, x: GLdouble, y: GLdouble): void {.cdecl.}
  cglUniform2dv: proc (location: GLint, count: GLsizei, value: ptr GLdouble): void {.cdecl.}
  cglUniform2f: proc (location: GLint, v0: GLfloat, v1: GLfloat): void {.cdecl.}
  cglUniform2fv: proc (location: GLint, count: GLsizei, value: ptr GLfloat): void {.cdecl.}
  cglUniform2i: proc (location: GLint, v0: GLint, v1: GLint): void {.cdecl.}
  cglUniform2iv: proc (location: GLint, count: GLsizei, value: ptr GLint): void {.cdecl.}
  cglUniform2ui: proc (location: GLint, v0: GLuint, v1: GLuint): void {.cdecl.}
  cglUniform2uiv: proc (location: GLint, count: GLsizei, value: ptr GLuint): void {.cdecl.}
  cglUniform3d: proc (location: GLint, x: GLdouble, y: GLdouble, z: GLdouble): void {.cdecl.}
  cglUniform3dv: proc (location: GLint, count: GLsizei, value: ptr GLdouble): void {.cdecl.}
  cglUniform3f: proc (location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat): void {.cdecl.}
  cglUniform3fv: proc (location: GLint, count: GLsizei, value: ptr GLfloat): void {.cdecl.}
  cglUniform3i: proc (location: GLint, v0: GLint, v1: GLint, v2: GLint): void {.cdecl.}
  cglUniform3iv: proc (location: GLint, count: GLsizei, value: ptr GLint): void {.cdecl.}
  cglUniform3ui: proc (location: GLint, v0: GLuint, v1: GLuint, v2: GLuint): void {.cdecl.}
  cglUniform3uiv: proc (location: GLint, count: GLsizei, value: ptr GLuint): void {.cdecl.}
  cglUniform4d: proc (location: GLint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble): void {.cdecl.}
  cglUniform4dv: proc (location: GLint, count: GLsizei, value: ptr GLdouble): void {.cdecl.}
  cglUniform4f: proc (location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat): void {.cdecl.}
  cglUniform4fv: proc (location: GLint, count: GLsizei, value: ptr GLfloat): void {.cdecl.}
  cglUniform4i: proc (location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint): void {.cdecl.}
  cglUniform4iv: proc (location: GLint, count: GLsizei, value: ptr GLint): void {.cdecl.}
  cglUniform4ui: proc (location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint): void {.cdecl.}
  cglUniform4uiv: proc (location: GLint, count: GLsizei, value: ptr GLuint): void {.cdecl.}
  cglUniformBlockBinding: proc (program: GLuint, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint): void {.cdecl.}
  cglUniformMatrix2dv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglUniformMatrix2fv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglUniformMatrix2x3dv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglUniformMatrix2x3fv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglUniformMatrix2x4dv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglUniformMatrix2x4fv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglUniformMatrix3dv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglUniformMatrix3fv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglUniformMatrix3x2dv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglUniformMatrix3x2fv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglUniformMatrix3x4dv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglUniformMatrix3x4fv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglUniformMatrix4dv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglUniformMatrix4fv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglUniformMatrix4x2dv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglUniformMatrix4x2fv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglUniformMatrix4x3dv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}
  cglUniformMatrix4x3fv: proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}
  cglUniformSubroutinesuiv: proc (shadertype: GLenum, count: GLsizei, indices: ptr GLuint): void {.cdecl.}
  cglUnmapBuffer: proc (target: GLenum): GLboolean {.cdecl.}
  cglUnmapNamedBuffer: proc (buffer: GLuint): GLboolean {.cdecl.}
  cglUseProgram: proc (program: GLuint): void {.cdecl.}
  cglUseProgramStages: proc (pipeline: GLuint, stages: GLbitfield, program: GLuint): void {.cdecl.}
  cglValidateProgram: proc (program: GLuint): void {.cdecl.}
  cglValidateProgramPipeline: proc (pipeline: GLuint): void {.cdecl.}
  cglVertexAttrib4uiv: proc (index: GLuint, v: ptr GLuint): void {.cdecl.}
  cglVertexP4uiv: proc (`type`: GLenum, value: ptr GLuint): void {.cdecl.}
  cglVertexP4ui: proc (`type`: GLenum, value: GLuint): void {.cdecl.}
  cglVertexP3uiv: proc (`type`: GLenum, value: ptr GLuint): void {.cdecl.}
  cglVertexP3ui: proc (`type`: GLenum, value: GLuint): void {.cdecl.}
  cglVertexP2uiv: proc (`type`: GLenum, value: ptr GLuint): void {.cdecl.}
  cglVertexP2ui: proc (`type`: GLenum, value: GLuint): void {.cdecl.}
  cglVertexBindingDivisor: proc (bindingindex: GLuint, divisor: GLuint): void {.cdecl.}
  cglVertexArrayAttribBinding: proc (vaobj: GLuint, attribindex: GLuint, bindingindex: GLuint): void {.cdecl.}
  cglVertexArrayAttribFormat: proc (vaobj: GLuint, attribindex: GLuint, size: GLint, `type`: GLenum, normalized: GLboolean, relativeoffset: GLuint): void {.cdecl.}
  cglVertexArrayAttribIFormat: proc (vaobj: GLuint, attribindex: GLuint, size: GLint, `type`: GLenum, relativeoffset: GLuint): void {.cdecl.}
  cglVertexArrayAttribLFormat: proc (vaobj: GLuint, attribindex: GLuint, size: GLint, `type`: GLenum, relativeoffset: GLuint): void {.cdecl.}
  cglVertexArrayBindingDivisor: proc (vaobj: GLuint, bindingindex: GLuint, divisor: GLuint): void {.cdecl.}
  cglVertexArrayElementBuffer: proc (vaobj: GLuint, buffer: GLuint): void {.cdecl.}
  cglVertexArrayVertexBuffer: proc (vaobj: GLuint, bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei): void {.cdecl.}
  cglVertexArrayVertexBuffers: proc (vaobj: GLuint, first: GLuint, count: GLsizei, buffers: ptr GLuint, offsets: ptr GLintptr, strides: ptr GLsizei): void {.cdecl.}
  cglVertexAttrib1d: proc (index: GLuint, x: GLdouble): void {.cdecl.}
  cglVertexAttrib1dv: proc (index: GLuint, v: ptr GLdouble): void {.cdecl.}
  cglVertexAttrib1f: proc (index: GLuint, x: GLfloat): void {.cdecl.}
  cglVertexAttrib1fv: proc (index: GLuint, v: ptr GLfloat): void {.cdecl.}
  cglVertexAttrib1s: proc (index: GLuint, x: GLshort): void {.cdecl.}
  cglVertexAttrib1sv: proc (index: GLuint, v: ptr GLshort): void {.cdecl.}
  cglVertexAttrib2d: proc (index: GLuint, x: GLdouble, y: GLdouble): void {.cdecl.}
  cglGetProcAddress: GLPROCLOADERPROC
  glNimDebugPreProc*: proc(name: string): void
  glNimDebugPostProc*: proc(name: string): void

proc glGetProcAddress(name: cstring): pointer =
  ## Gets a pointer to the procedure
  ## If `release` is not defined it will check that the address has been found.
  cglGetProcAddress(name)

proc load1_0() =
  cglCullFace = cast[proc (mode: GLenum): void {.cdecl.}](glGetProcAddress("glCullFace"))
  cglFrontFace = cast[proc (mode: GLenum): void {.cdecl.}](glGetProcAddress("glFrontFace"))
  cglHint = cast[proc (target: GLenum, mode: GLenum): void {.cdecl.}](glGetProcAddress("glHint"))
  cglLineWidth = cast[proc (width: GLfloat): void {.cdecl.}](glGetProcAddress("glLineWidth"))
  cglPointSize = cast[proc (size: GLfloat): void {.cdecl.}](glGetProcAddress("glPointSize"))
  cglPolygonMode = cast[proc (face: GLenum, mode: GLenum): void {.cdecl.}](glGetProcAddress("glPolygonMode"))
  cglScissor = cast[proc (x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}](glGetProcAddress("glScissor"))
  cglTexParameterf = cast[proc (target: GLenum, pname: GLenum, param: GLfloat): void {.cdecl.}](glGetProcAddress("glTexParameterf"))
  cglTexParameterfv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glTexParameterfv"))
  cglTexParameteri = cast[proc (target: GLenum, pname: GLenum, param: GLint): void {.cdecl.}](glGetProcAddress("glTexParameteri"))
  cglTexParameteriv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glTexParameteriv"))
  cglTexImage1D = cast[proc (target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, border: GLint, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}](glGetProcAddress("glTexImage1D"))
  cglTexImage2D = cast[proc (target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}](glGetProcAddress("glTexImage2D"))
  cglDrawBuffer = cast[proc (buf: GLenum): void {.cdecl.}](glGetProcAddress("glDrawBuffer"))
  cglClear = cast[proc (mask: GLbitfield): void {.cdecl.}](glGetProcAddress("glClear"))
  cglClearColor = cast[proc (red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat): void {.cdecl.}](glGetProcAddress("glClearColor"))
  cglClearStencil = cast[proc (s: GLint): void {.cdecl.}](glGetProcAddress("glClearStencil"))
  cglClearDepth = cast[proc (depth: GLdouble): void {.cdecl.}](glGetProcAddress("glClearDepth"))
  cglStencilMask = cast[proc (mask: GLuint): void {.cdecl.}](glGetProcAddress("glStencilMask"))
  cglColorMask = cast[proc (red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean): void {.cdecl.}](glGetProcAddress("glColorMask"))
  cglDepthMask = cast[proc (flag: GLboolean): void {.cdecl.}](glGetProcAddress("glDepthMask"))
  cglDisable = cast[proc (cap: GLenum): void {.cdecl.}](glGetProcAddress("glDisable"))
  cglEnable = cast[proc (cap: GLenum): void {.cdecl.}](glGetProcAddress("glEnable"))
  cglFinish = cast[proc (): void {.cdecl.}](glGetProcAddress("glFinish"))
  cglFlush = cast[proc (): void {.cdecl.}](glGetProcAddress("glFlush"))
  cglBlendFunc = cast[proc (sfactor: GLenum, dfactor: GLenum): void {.cdecl.}](glGetProcAddress("glBlendFunc"))
  cglLogicOp = cast[proc (opcode: GLenum): void {.cdecl.}](glGetProcAddress("glLogicOp"))
  cglStencilFunc = cast[proc (`func`: GLenum, `ref`: GLint, mask: GLuint): void {.cdecl.}](glGetProcAddress("glStencilFunc"))
  cglStencilOp = cast[proc (fail: GLenum, zfail: GLenum, zpass: GLenum): void {.cdecl.}](glGetProcAddress("glStencilOp"))
  cglDepthFunc = cast[proc (`func`: GLenum): void {.cdecl.}](glGetProcAddress("glDepthFunc"))
  cglPixelStoref = cast[proc (pname: GLenum, param: GLfloat): void {.cdecl.}](glGetProcAddress("glPixelStoref"))
  cglPixelStorei = cast[proc (pname: GLenum, param: GLint): void {.cdecl.}](glGetProcAddress("glPixelStorei"))
  cglReadBuffer = cast[proc (src: GLenum): void {.cdecl.}](glGetProcAddress("glReadBuffer"))
  cglReadPixels = cast[proc (x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}](glGetProcAddress("glReadPixels"))
  cglGetBooleanv = cast[proc (pname: GLenum, data: ptr GLboolean): void {.cdecl.}](glGetProcAddress("glGetBooleanv"))
  cglGetDoublev = cast[proc (pname: GLenum, data: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glGetDoublev"))
  cglGetError = cast[proc (): GLenum {.cdecl.}](glGetProcAddress("glGetError"))
  cglGetFloatv = cast[proc (pname: GLenum, data: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glGetFloatv"))
  cglGetIntegerv = cast[proc (pname: GLenum, data: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetIntegerv"))
  cglGetString = cast[proc (name: GLenum): ptr GLubyte {.cdecl.}](glGetProcAddress("glGetString"))
  cglGetTexImage = cast[proc (target: GLenum, level: GLint, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}](glGetProcAddress("glGetTexImage"))
  cglGetTexParameterfv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glGetTexParameterfv"))
  cglGetTexParameteriv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetTexParameteriv"))
  cglGetTexLevelParameterfv = cast[proc (target: GLenum, level: GLint, pname: GLenum, params: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glGetTexLevelParameterfv"))
  cglGetTexLevelParameteriv = cast[proc (target: GLenum, level: GLint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetTexLevelParameteriv"))
  cglIsEnabled = cast[proc (cap: GLenum): GLboolean {.cdecl.}](glGetProcAddress("glIsEnabled"))
  cglDepthRange = cast[proc (n: GLdouble, f: GLdouble): void {.cdecl.}](glGetProcAddress("glDepthRange"))
  cglViewport = cast[proc (x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}](glGetProcAddress("glViewport"))
  cglClearDepthf = cast[proc (d: GLfloat): void {.cdecl.}](glGetProcAddress("glClearDepthf"))
  cglClipPlanef = cast[proc (p: GLenum, eqn: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glClipPlanef"))
  cglDepthRangef = cast[proc (n: GLfloat, f: GLfloat): void {.cdecl.}](glGetProcAddress("glDepthRangef"))
  cglFrustumf = cast[proc (l: GLfloat, r: GLfloat, b: GLfloat, t: GLfloat, n: GLfloat, f: GLfloat): void {.cdecl.}](glGetProcAddress("glFrustumf"))
  cglGetClipPlanef = cast[proc (plane: GLenum, equation: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glGetClipPlanef"))
  cglOrthof = cast[proc (l: GLfloat, r: GLfloat, b: GLfloat, t: GLfloat, n: GLfloat, f: GLfloat): void {.cdecl.}](glGetProcAddress("glOrthof"))
  cglPointParameterf = cast[proc (pname: GLenum, param: GLfloat): void {.cdecl.}](glGetProcAddress("glPointParameterf"))
  cglPointParameterfv = cast[proc (pname: GLenum, params: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glPointParameterfv"))
  cglPolygonOffset = cast[proc (factor: GLfloat, units: GLfloat): void {.cdecl.}](glGetProcAddress("glPolygonOffset"))
  cglActiveTexture = cast[proc (texture: GLenum): void {.cdecl.}](glGetProcAddress("glActiveTexture"))
  cglAlphaFuncx = cast[proc (`func`: GLenum, `ref`: GLfixed): void {.cdecl.}](glGetProcAddress("glAlphaFuncx"))
  cglBindBuffer = cast[proc (target: GLenum, buffer: GLuint): void {.cdecl.}](glGetProcAddress("glBindBuffer"))
  cglBindTexture = cast[proc (target: GLenum, texture: GLuint): void {.cdecl.}](glGetProcAddress("glBindTexture"))
  cglBufferData = cast[proc (target: GLenum, size: GLsizeiptr, data: pointer, usage: GLenum): void {.cdecl.}](glGetProcAddress("glBufferData"))
  cglBufferSubData = cast[proc (target: GLenum, offset: GLintptr, size: GLsizeiptr, data: pointer): void {.cdecl.}](glGetProcAddress("glBufferSubData"))
  cglClearColorx = cast[proc (red: GLfixed, green: GLfixed, blue: GLfixed, alpha: GLfixed): void {.cdecl.}](glGetProcAddress("glClearColorx"))
  cglClearDepthx = cast[proc (depth: GLfixed): void {.cdecl.}](glGetProcAddress("glClearDepthx"))
  cglClipPlanex = cast[proc (plane: GLenum, equation: ptr GLfixed): void {.cdecl.}](glGetProcAddress("glClipPlanex"))
  cglColor4x = cast[proc (red: GLfixed, green: GLfixed, blue: GLfixed, alpha: GLfixed): void {.cdecl.}](glGetProcAddress("glColor4x"))
  cglCompressedTexImage2D = cast[proc (target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, imageSize: GLsizei, data: pointer): void {.cdecl.}](glGetProcAddress("glCompressedTexImage2D"))
  cglCompressedTexSubImage2D = cast[proc (target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void {.cdecl.}](glGetProcAddress("glCompressedTexSubImage2D"))
  cglCopyTexImage2D = cast[proc (target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint): void {.cdecl.}](glGetProcAddress("glCopyTexImage2D"))
  cglCopyTexSubImage2D = cast[proc (target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}](glGetProcAddress("glCopyTexSubImage2D"))
  cglDeleteBuffers = cast[proc (n: GLsizei, buffers: ptr GLuint): void {.cdecl.}](glGetProcAddress("glDeleteBuffers"))
  cglDeleteTextures = cast[proc (n: GLsizei, textures: ptr GLuint): void {.cdecl.}](glGetProcAddress("glDeleteTextures"))
  cglDepthRangex = cast[proc (n: GLfixed, f: GLfixed): void {.cdecl.}](glGetProcAddress("glDepthRangex"))
  cglDrawArrays = cast[proc (mode: GLenum, first: GLint, count: GLsizei): void {.cdecl.}](glGetProcAddress("glDrawArrays"))
  cglDrawElements = cast[proc (mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer): void {.cdecl.}](glGetProcAddress("glDrawElements"))
  cglFogx = cast[proc (pname: GLenum, param: GLfixed): void {.cdecl.}](glGetProcAddress("glFogx"))
  cglFogxv = cast[proc (pname: GLenum, param: ptr GLfixed): void {.cdecl.}](glGetProcAddress("glFogxv"))
  cglFrustumx = cast[proc (l: GLfixed, r: GLfixed, b: GLfixed, t: GLfixed, n: GLfixed, f: GLfixed): void {.cdecl.}](glGetProcAddress("glFrustumx"))
  cglGetBufferParameteriv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetBufferParameteriv"))
  cglGetClipPlanex = cast[proc (plane: GLenum, equation: ptr GLfixed): void {.cdecl.}](glGetProcAddress("glGetClipPlanex"))
  cglGenBuffers = cast[proc (n: GLsizei, buffers: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGenBuffers"))
  cglGenTextures = cast[proc (n: GLsizei, textures: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGenTextures"))
  cglGetFixedv = cast[proc (pname: GLenum, params: ptr GLfixed): void {.cdecl.}](glGetProcAddress("glGetFixedv"))
  cglGetLightxv = cast[proc (light: GLenum, pname: GLenum, params: ptr GLfixed): void {.cdecl.}](glGetProcAddress("glGetLightxv"))
  cglGetMaterialxv = cast[proc (face: GLenum, pname: GLenum, params: ptr GLfixed): void {.cdecl.}](glGetProcAddress("glGetMaterialxv"))
  cglGetTexEnvxv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLfixed): void {.cdecl.}](glGetProcAddress("glGetTexEnvxv"))
  cglGetTexParameterxv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLfixed): void {.cdecl.}](glGetProcAddress("glGetTexParameterxv"))
  cglIsBuffer = cast[proc (buffer: GLuint): GLboolean {.cdecl.}](glGetProcAddress("glIsBuffer"))
  cglIsTexture = cast[proc (texture: GLuint): GLboolean {.cdecl.}](glGetProcAddress("glIsTexture"))
  cglLightModelx = cast[proc (pname: GLenum, param: GLfixed): void {.cdecl.}](glGetProcAddress("glLightModelx"))
  cglLightModelxv = cast[proc (pname: GLenum, param: ptr GLfixed): void {.cdecl.}](glGetProcAddress("glLightModelxv"))
  cglLightx = cast[proc (light: GLenum, pname: GLenum, param: GLfixed): void {.cdecl.}](glGetProcAddress("glLightx"))
  cglLightxv = cast[proc (light: GLenum, pname: GLenum, params: ptr GLfixed): void {.cdecl.}](glGetProcAddress("glLightxv"))
  cglLineWidthx = cast[proc (width: GLfixed): void {.cdecl.}](glGetProcAddress("glLineWidthx"))
  cglLoadMatrixx = cast[proc (m: ptr GLfixed): void {.cdecl.}](glGetProcAddress("glLoadMatrixx"))
  cglMaterialx = cast[proc (face: GLenum, pname: GLenum, param: GLfixed): void {.cdecl.}](glGetProcAddress("glMaterialx"))
  cglMaterialxv = cast[proc (face: GLenum, pname: GLenum, param: ptr GLfixed): void {.cdecl.}](glGetProcAddress("glMaterialxv"))
  cglMultMatrixx = cast[proc (m: ptr GLfixed): void {.cdecl.}](glGetProcAddress("glMultMatrixx"))
  cglMultiTexCoord4x = cast[proc (texture: GLenum, s: GLfixed, t: GLfixed, r: GLfixed, q: GLfixed): void {.cdecl.}](glGetProcAddress("glMultiTexCoord4x"))
  cglNormal3x = cast[proc (nx: GLfixed, ny: GLfixed, nz: GLfixed): void {.cdecl.}](glGetProcAddress("glNormal3x"))
  cglOrthox = cast[proc (l: GLfixed, r: GLfixed, b: GLfixed, t: GLfixed, n: GLfixed, f: GLfixed): void {.cdecl.}](glGetProcAddress("glOrthox"))
  cglPointParameterx = cast[proc (pname: GLenum, param: GLfixed): void {.cdecl.}](glGetProcAddress("glPointParameterx"))
  cglPointParameterxv = cast[proc (pname: GLenum, params: ptr GLfixed): void {.cdecl.}](glGetProcAddress("glPointParameterxv"))
  cglPointSizex = cast[proc (size: GLfixed): void {.cdecl.}](glGetProcAddress("glPointSizex"))
  cglPolygonOffsetx = cast[proc (factor: GLfixed, units: GLfixed): void {.cdecl.}](glGetProcAddress("glPolygonOffsetx"))
  cglRotatex = cast[proc (angle: GLfixed, x: GLfixed, y: GLfixed, z: GLfixed): void {.cdecl.}](glGetProcAddress("glRotatex"))
  cglSampleCoverage = cast[proc (value: GLfloat, invert: GLboolean): void {.cdecl.}](glGetProcAddress("glSampleCoverage"))
  cglSampleCoveragex = cast[proc (value: GLclampx, invert: GLboolean): void {.cdecl.}](glGetProcAddress("glSampleCoveragex"))
  cglScalex = cast[proc (x: GLfixed, y: GLfixed, z: GLfixed): void {.cdecl.}](glGetProcAddress("glScalex"))
  cglTexEnvx = cast[proc (target: GLenum, pname: GLenum, param: GLfixed): void {.cdecl.}](glGetProcAddress("glTexEnvx"))
  cglTexEnvxv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLfixed): void {.cdecl.}](glGetProcAddress("glTexEnvxv"))
  cglTexParameterx = cast[proc (target: GLenum, pname: GLenum, param: GLfixed): void {.cdecl.}](glGetProcAddress("glTexParameterx"))
  cglTexParameterxv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLfixed): void {.cdecl.}](glGetProcAddress("glTexParameterxv"))
  cglTexSubImage2D = cast[proc (target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}](glGetProcAddress("glTexSubImage2D"))
  cglTranslatex = cast[proc (x: GLfixed, y: GLfixed, z: GLfixed): void {.cdecl.}](glGetProcAddress("glTranslatex"))

proc load1_1() =
  cglCopyTexImage1D = cast[proc (target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, border: GLint): void {.cdecl.}](glGetProcAddress("glCopyTexImage1D"))
  cglCopyTexSubImage1D = cast[proc (target: GLenum, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei): void {.cdecl.}](glGetProcAddress("glCopyTexSubImage1D"))
  cglTexSubImage1D = cast[proc (target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}](glGetProcAddress("glTexSubImage1D"))

proc load1_2() =
  cglDrawRangeElements = cast[proc (mode: GLenum, start: GLuint, `end`: GLuint, count: GLsizei, `type`: GLenum, indices: pointer): void {.cdecl.}](glGetProcAddress("glDrawRangeElements"))
  cglTexImage3D = cast[proc (target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}](glGetProcAddress("glTexImage3D"))
  cglTexSubImage3D = cast[proc (target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}](glGetProcAddress("glTexSubImage3D"))
  cglCopyTexSubImage3D = cast[proc (target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}](glGetProcAddress("glCopyTexSubImage3D"))

proc load1_3() =
  cglCompressedTexImage3D = cast[proc (target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, data: pointer): void {.cdecl.}](glGetProcAddress("glCompressedTexImage3D"))
  cglCompressedTexImage1D = cast[proc (target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, border: GLint, imageSize: GLsizei, data: pointer): void {.cdecl.}](glGetProcAddress("glCompressedTexImage1D"))
  cglCompressedTexSubImage3D = cast[proc (target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void {.cdecl.}](glGetProcAddress("glCompressedTexSubImage3D"))
  cglCompressedTexSubImage1D = cast[proc (target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void {.cdecl.}](glGetProcAddress("glCompressedTexSubImage1D"))
  cglGetCompressedTexImage = cast[proc (target: GLenum, level: GLint, img: pointer): void {.cdecl.}](glGetProcAddress("glGetCompressedTexImage"))

proc load1_4() =
  cglBlendFuncSeparate = cast[proc (sfactorRGB: GLenum, dfactorRGB: GLenum, sfactorAlpha: GLenum, dfactorAlpha: GLenum): void {.cdecl.}](glGetProcAddress("glBlendFuncSeparate"))
  cglMultiDrawArrays = cast[proc (mode: GLenum, first: ptr GLint, count: ptr GLsizei, drawcount: GLsizei): void {.cdecl.}](glGetProcAddress("glMultiDrawArrays"))
  cglMultiDrawElements = cast[proc (mode: GLenum, count: ptr GLsizei, `type`: GLenum, indices: ptr pointer, drawcount: GLsizei): void {.cdecl.}](glGetProcAddress("glMultiDrawElements"))
  cglPointParameteri = cast[proc (pname: GLenum, param: GLint): void {.cdecl.}](glGetProcAddress("glPointParameteri"))
  cglPointParameteriv = cast[proc (pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glPointParameteriv"))
  cglBlendColor = cast[proc (red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat): void {.cdecl.}](glGetProcAddress("glBlendColor"))
  cglBlendEquation = cast[proc (mode: GLenum): void {.cdecl.}](glGetProcAddress("glBlendEquation"))

proc load1_5() =
  cglGenQueries = cast[proc (n: GLsizei, ids: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGenQueries"))
  cglDeleteQueries = cast[proc (n: GLsizei, ids: ptr GLuint): void {.cdecl.}](glGetProcAddress("glDeleteQueries"))
  cglIsQuery = cast[proc (id: GLuint): GLboolean {.cdecl.}](glGetProcAddress("glIsQuery"))
  cglBeginQuery = cast[proc (target: GLenum, id: GLuint): void {.cdecl.}](glGetProcAddress("glBeginQuery"))
  cglEndQuery = cast[proc (target: GLenum): void {.cdecl.}](glGetProcAddress("glEndQuery"))
  cglGetQueryiv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetQueryiv"))
  cglGetQueryObjectiv = cast[proc (id: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetQueryObjectiv"))
  cglGetQueryObjectuiv = cast[proc (id: GLuint, pname: GLenum, params: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGetQueryObjectuiv"))
  cglGetBufferSubData = cast[proc (target: GLenum, offset: GLintptr, size: GLsizeiptr, data: pointer): void {.cdecl.}](glGetProcAddress("glGetBufferSubData"))
  cglMapBuffer = cast[proc (target: GLenum, access: GLenum): pointer {.cdecl.}](glGetProcAddress("glMapBuffer"))
  cglUnmapBuffer = cast[proc (target: GLenum): GLboolean {.cdecl.}](glGetProcAddress("glUnmapBuffer"))
  cglGetBufferPointerv = cast[proc (target: GLenum, pname: GLenum, params: ptr pointer): void {.cdecl.}](glGetProcAddress("glGetBufferPointerv"))

proc load2_0() =
  cglBlendEquationSeparate = cast[proc (modeRGB: GLenum, modeAlpha: GLenum): void {.cdecl.}](glGetProcAddress("glBlendEquationSeparate"))
  cglDrawBuffers = cast[proc (n: GLsizei, bufs: ptr GLenum): void {.cdecl.}](glGetProcAddress("glDrawBuffers"))
  cglStencilOpSeparate = cast[proc (face: GLenum, sfail: GLenum, dpfail: GLenum, dppass: GLenum): void {.cdecl.}](glGetProcAddress("glStencilOpSeparate"))
  cglStencilFuncSeparate = cast[proc (face: GLenum, `func`: GLenum, `ref`: GLint, mask: GLuint): void {.cdecl.}](glGetProcAddress("glStencilFuncSeparate"))
  cglStencilMaskSeparate = cast[proc (face: GLenum, mask: GLuint): void {.cdecl.}](glGetProcAddress("glStencilMaskSeparate"))
  cglAttachShader = cast[proc (program: GLuint, shader: GLuint): void {.cdecl.}](glGetProcAddress("glAttachShader"))
  cglBindAttribLocation = cast[proc (program: GLuint, index: GLuint, name: cstring): void {.cdecl.}](glGetProcAddress("glBindAttribLocation"))
  cglCompileShader = cast[proc (shader: GLuint): void {.cdecl.}](glGetProcAddress("glCompileShader"))
  cglCreateProgram = cast[proc (): GLuint {.cdecl.}](glGetProcAddress("glCreateProgram"))
  cglCreateShader = cast[proc (`type`: GLenum): GLuint {.cdecl.}](glGetProcAddress("glCreateShader"))
  cglDeleteProgram = cast[proc (program: GLuint): void {.cdecl.}](glGetProcAddress("glDeleteProgram"))
  cglDeleteShader = cast[proc (shader: GLuint): void {.cdecl.}](glGetProcAddress("glDeleteShader"))
  cglDetachShader = cast[proc (program: GLuint, shader: GLuint): void {.cdecl.}](glGetProcAddress("glDetachShader"))
  cglDisableVertexAttribArray = cast[proc (index: GLuint): void {.cdecl.}](glGetProcAddress("glDisableVertexAttribArray"))
  cglEnableVertexAttribArray = cast[proc (index: GLuint): void {.cdecl.}](glGetProcAddress("glEnableVertexAttribArray"))
  cglGetActiveAttrib = cast[proc (program: GLuint, index: GLuint, bufSize: GLsizei, length: ptr GLsizei, size: ptr GLint, `type`: ptr GLenum, name: cstring): void {.cdecl.}](glGetProcAddress("glGetActiveAttrib"))
  cglGetActiveUniform = cast[proc (program: GLuint, index: GLuint, bufSize: GLsizei, length: ptr GLsizei, size: ptr GLint, `type`: ptr GLenum, name: cstring): void {.cdecl.}](glGetProcAddress("glGetActiveUniform"))
  cglGetAttachedShaders = cast[proc (program: GLuint, maxCount: GLsizei, count: ptr GLsizei, shaders: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGetAttachedShaders"))
  cglGetAttribLocation = cast[proc (program: GLuint, name: cstring): GLint {.cdecl.}](glGetProcAddress("glGetAttribLocation"))
  cglGetProgramiv = cast[proc (program: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetProgramiv"))
  cglGetProgramInfoLog = cast[proc (program: GLuint, bufSize: GLsizei, length: ptr GLsizei, infoLog: cstring): void {.cdecl.}](glGetProcAddress("glGetProgramInfoLog"))
  cglGetShaderiv = cast[proc (shader: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetShaderiv"))
  cglGetShaderInfoLog = cast[proc (shader: GLuint, bufSize: GLsizei, length: ptr GLsizei, infoLog: cstring): void {.cdecl.}](glGetProcAddress("glGetShaderInfoLog"))
  cglGetShaderSource = cast[proc (shader: GLuint, bufSize: GLsizei, length: ptr GLsizei, source: cstring): void {.cdecl.}](glGetProcAddress("glGetShaderSource"))
  cglGetUniformLocation = cast[proc (program: GLuint, name: cstring): GLint {.cdecl.}](glGetProcAddress("glGetUniformLocation"))
  cglGetUniformfv = cast[proc (program: GLuint, location: GLint, params: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glGetUniformfv"))
  cglGetUniformiv = cast[proc (program: GLuint, location: GLint, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetUniformiv"))
  cglGetVertexAttribdv = cast[proc (index: GLuint, pname: GLenum, params: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glGetVertexAttribdv"))
  cglGetVertexAttribfv = cast[proc (index: GLuint, pname: GLenum, params: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glGetVertexAttribfv"))
  cglGetVertexAttribiv = cast[proc (index: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetVertexAttribiv"))
  cglGetVertexAttribPointerv = cast[proc (index: GLuint, pname: GLenum, pointer: ptr pointer): void {.cdecl.}](glGetProcAddress("glGetVertexAttribPointerv"))
  cglIsProgram = cast[proc (program: GLuint): GLboolean {.cdecl.}](glGetProcAddress("glIsProgram"))
  cglIsShader = cast[proc (shader: GLuint): GLboolean {.cdecl.}](glGetProcAddress("glIsShader"))
  cglLinkProgram = cast[proc (program: GLuint): void {.cdecl.}](glGetProcAddress("glLinkProgram"))
  cglShaderSource = cast[proc (shader: GLuint, count: GLsizei, string: ptr cstring, length: ptr GLint): void {.cdecl.}](glGetProcAddress("glShaderSource"))
  cglUseProgram = cast[proc (program: GLuint): void {.cdecl.}](glGetProcAddress("glUseProgram"))
  cglUniform1f = cast[proc (location: GLint, v0: GLfloat): void {.cdecl.}](glGetProcAddress("glUniform1f"))
  cglUniform2f = cast[proc (location: GLint, v0: GLfloat, v1: GLfloat): void {.cdecl.}](glGetProcAddress("glUniform2f"))
  cglUniform3f = cast[proc (location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat): void {.cdecl.}](glGetProcAddress("glUniform3f"))
  cglUniform4f = cast[proc (location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat): void {.cdecl.}](glGetProcAddress("glUniform4f"))
  cglUniform1i = cast[proc (location: GLint, v0: GLint): void {.cdecl.}](glGetProcAddress("glUniform1i"))
  cglUniform2i = cast[proc (location: GLint, v0: GLint, v1: GLint): void {.cdecl.}](glGetProcAddress("glUniform2i"))
  cglUniform3i = cast[proc (location: GLint, v0: GLint, v1: GLint, v2: GLint): void {.cdecl.}](glGetProcAddress("glUniform3i"))
  cglUniform4i = cast[proc (location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint): void {.cdecl.}](glGetProcAddress("glUniform4i"))
  cglUniform1fv = cast[proc (location: GLint, count: GLsizei, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glUniform1fv"))
  cglUniform2fv = cast[proc (location: GLint, count: GLsizei, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glUniform2fv"))
  cglUniform3fv = cast[proc (location: GLint, count: GLsizei, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glUniform3fv"))
  cglUniform4fv = cast[proc (location: GLint, count: GLsizei, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glUniform4fv"))
  cglUniform1iv = cast[proc (location: GLint, count: GLsizei, value: ptr GLint): void {.cdecl.}](glGetProcAddress("glUniform1iv"))
  cglUniform2iv = cast[proc (location: GLint, count: GLsizei, value: ptr GLint): void {.cdecl.}](glGetProcAddress("glUniform2iv"))
  cglUniform3iv = cast[proc (location: GLint, count: GLsizei, value: ptr GLint): void {.cdecl.}](glGetProcAddress("glUniform3iv"))
  cglUniform4iv = cast[proc (location: GLint, count: GLsizei, value: ptr GLint): void {.cdecl.}](glGetProcAddress("glUniform4iv"))
  cglUniformMatrix2fv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glUniformMatrix2fv"))
  cglUniformMatrix3fv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glUniformMatrix3fv"))
  cglUniformMatrix4fv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glUniformMatrix4fv"))
  cglValidateProgram = cast[proc (program: GLuint): void {.cdecl.}](glGetProcAddress("glValidateProgram"))
  cglVertexAttrib1d = cast[proc (index: GLuint, x: GLdouble): void {.cdecl.}](glGetProcAddress("glVertexAttrib1d"))
  cglVertexAttrib1dv = cast[proc (index: GLuint, v: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glVertexAttrib1dv"))
  cglVertexAttrib1f = cast[proc (index: GLuint, x: GLfloat): void {.cdecl.}](glGetProcAddress("glVertexAttrib1f"))
  cglVertexAttrib1fv = cast[proc (index: GLuint, v: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glVertexAttrib1fv"))
  cglVertexAttrib1s = cast[proc (index: GLuint, x: GLshort): void {.cdecl.}](glGetProcAddress("glVertexAttrib1s"))
  cglVertexAttrib1sv = cast[proc (index: GLuint, v: ptr GLshort): void {.cdecl.}](glGetProcAddress("glVertexAttrib1sv"))
  cglVertexAttrib2d = cast[proc (index: GLuint, x: GLdouble, y: GLdouble): void {.cdecl.}](glGetProcAddress("glVertexAttrib2d"))
  cglVertexAttrib2dv = cast[proc (index: GLuint, v: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glVertexAttrib2dv"))
  cglVertexAttrib2f = cast[proc (index: GLuint, x: GLfloat, y: GLfloat): void {.cdecl.}](glGetProcAddress("glVertexAttrib2f"))
  cglVertexAttrib2fv = cast[proc (index: GLuint, v: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glVertexAttrib2fv"))
  cglVertexAttrib2s = cast[proc (index: GLuint, x: GLshort, y: GLshort): void {.cdecl.}](glGetProcAddress("glVertexAttrib2s"))
  cglVertexAttrib2sv = cast[proc (index: GLuint, v: ptr GLshort): void {.cdecl.}](glGetProcAddress("glVertexAttrib2sv"))
  cglVertexAttrib3d = cast[proc (index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble): void {.cdecl.}](glGetProcAddress("glVertexAttrib3d"))
  cglVertexAttrib3dv = cast[proc (index: GLuint, v: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glVertexAttrib3dv"))
  cglVertexAttrib3f = cast[proc (index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat): void {.cdecl.}](glGetProcAddress("glVertexAttrib3f"))
  cglVertexAttrib3fv = cast[proc (index: GLuint, v: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glVertexAttrib3fv"))
  cglVertexAttrib3s = cast[proc (index: GLuint, x: GLshort, y: GLshort, z: GLshort): void {.cdecl.}](glGetProcAddress("glVertexAttrib3s"))
  cglVertexAttrib3sv = cast[proc (index: GLuint, v: ptr GLshort): void {.cdecl.}](glGetProcAddress("glVertexAttrib3sv"))
  cglVertexAttrib4Nbv = cast[proc (index: GLuint, v: ptr GLbyte): void {.cdecl.}](glGetProcAddress("glVertexAttrib4Nbv"))
  cglVertexAttrib4Niv = cast[proc (index: GLuint, v: ptr GLint): void {.cdecl.}](glGetProcAddress("glVertexAttrib4Niv"))
  cglVertexAttrib4Nsv = cast[proc (index: GLuint, v: ptr GLshort): void {.cdecl.}](glGetProcAddress("glVertexAttrib4Nsv"))
  cglVertexAttrib4Nub = cast[proc (index: GLuint, x: GLubyte, y: GLubyte, z: GLubyte, w: GLubyte): void {.cdecl.}](glGetProcAddress("glVertexAttrib4Nub"))
  cglVertexAttrib4Nubv = cast[proc (index: GLuint, v: ptr GLubyte): void {.cdecl.}](glGetProcAddress("glVertexAttrib4Nubv"))
  cglVertexAttrib4Nuiv = cast[proc (index: GLuint, v: ptr GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttrib4Nuiv"))
  cglVertexAttrib4Nusv = cast[proc (index: GLuint, v: ptr GLushort): void {.cdecl.}](glGetProcAddress("glVertexAttrib4Nusv"))
  cglVertexAttrib4bv = cast[proc (index: GLuint, v: ptr GLbyte): void {.cdecl.}](glGetProcAddress("glVertexAttrib4bv"))
  cglVertexAttrib4d = cast[proc (index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble): void {.cdecl.}](glGetProcAddress("glVertexAttrib4d"))
  cglVertexAttrib4dv = cast[proc (index: GLuint, v: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glVertexAttrib4dv"))
  cglVertexAttrib4f = cast[proc (index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void {.cdecl.}](glGetProcAddress("glVertexAttrib4f"))
  cglVertexAttrib4fv = cast[proc (index: GLuint, v: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glVertexAttrib4fv"))
  cglVertexAttrib4iv = cast[proc (index: GLuint, v: ptr GLint): void {.cdecl.}](glGetProcAddress("glVertexAttrib4iv"))
  cglVertexAttrib4s = cast[proc (index: GLuint, x: GLshort, y: GLshort, z: GLshort, w: GLshort): void {.cdecl.}](glGetProcAddress("glVertexAttrib4s"))
  cglVertexAttrib4sv = cast[proc (index: GLuint, v: ptr GLshort): void {.cdecl.}](glGetProcAddress("glVertexAttrib4sv"))
  cglVertexAttrib4ubv = cast[proc (index: GLuint, v: ptr GLubyte): void {.cdecl.}](glGetProcAddress("glVertexAttrib4ubv"))
  cglVertexAttrib4uiv = cast[proc (index: GLuint, v: ptr GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttrib4uiv"))
  cglVertexAttrib4usv = cast[proc (index: GLuint, v: ptr GLushort): void {.cdecl.}](glGetProcAddress("glVertexAttrib4usv"))
  cglVertexAttribPointer = cast[proc (index: GLuint, size: GLint, `type`: GLenum, normalized: GLboolean, stride: GLsizei, pointer: pointer): void {.cdecl.}](glGetProcAddress("glVertexAttribPointer"))
  cglBindFramebuffer = cast[proc (target: GLenum, framebuffer: GLuint): void {.cdecl.}](glGetProcAddress("glBindFramebuffer"))
  cglBindRenderbuffer = cast[proc (target: GLenum, renderbuffer: GLuint): void {.cdecl.}](glGetProcAddress("glBindRenderbuffer"))
  cglCheckFramebufferStatus = cast[proc (target: GLenum): GLenum {.cdecl.}](glGetProcAddress("glCheckFramebufferStatus"))
  cglDeleteFramebuffers = cast[proc (n: GLsizei, framebuffers: ptr GLuint): void {.cdecl.}](glGetProcAddress("glDeleteFramebuffers"))
  cglDeleteRenderbuffers = cast[proc (n: GLsizei, renderbuffers: ptr GLuint): void {.cdecl.}](glGetProcAddress("glDeleteRenderbuffers"))
  cglFramebufferRenderbuffer = cast[proc (target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint): void {.cdecl.}](glGetProcAddress("glFramebufferRenderbuffer"))
  cglFramebufferTexture2D = cast[proc (target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint): void {.cdecl.}](glGetProcAddress("glFramebufferTexture2D"))
  cglGenerateMipmap = cast[proc (target: GLenum): void {.cdecl.}](glGetProcAddress("glGenerateMipmap"))
  cglGenFramebuffers = cast[proc (n: GLsizei, framebuffers: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGenFramebuffers"))
  cglGenRenderbuffers = cast[proc (n: GLsizei, renderbuffers: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGenRenderbuffers"))
  cglGetFramebufferAttachmentParameteriv = cast[proc (target: GLenum, attachment: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetFramebufferAttachmentParameteriv"))
  cglGetRenderbufferParameteriv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetRenderbufferParameteriv"))
  cglGetShaderPrecisionFormat = cast[proc (shadertype: GLenum, precisiontype: GLenum, range: ptr GLint, precision: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetShaderPrecisionFormat"))
  cglIsFramebuffer = cast[proc (framebuffer: GLuint): GLboolean {.cdecl.}](glGetProcAddress("glIsFramebuffer"))
  cglIsRenderbuffer = cast[proc (renderbuffer: GLuint): GLboolean {.cdecl.}](glGetProcAddress("glIsRenderbuffer"))
  cglReleaseShaderCompiler = cast[proc (): void {.cdecl.}](glGetProcAddress("glReleaseShaderCompiler"))
  cglRenderbufferStorage = cast[proc (target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei): void {.cdecl.}](glGetProcAddress("glRenderbufferStorage"))
  cglShaderBinary = cast[proc (count: GLsizei, shaders: ptr GLuint, binaryformat: GLenum, binary: pointer, length: GLsizei): void {.cdecl.}](glGetProcAddress("glShaderBinary"))
  cglGetGraphicsResetStatus = cast[proc (): GLenum {.cdecl.}](glGetProcAddress("glGetGraphicsResetStatus"))
  cglGetnUniformfv = cast[proc (program: GLuint, location: GLint, bufSize: GLsizei, params: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glGetnUniformfv"))
  cglGetnUniformiv = cast[proc (program: GLuint, location: GLint, bufSize: GLsizei, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetnUniformiv"))
  cglProgramBinary = cast[proc (program: GLuint, binaryFormat: GLenum, binary: pointer, length: GLsizei): void {.cdecl.}](glGetProcAddress("glProgramBinary"))
  cglReadnPixels = cast[proc (x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, `type`: GLenum, bufSize: GLsizei, data: pointer): void {.cdecl.}](glGetProcAddress("glReadnPixels"))
  cglTexStorage2D = cast[proc (target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void {.cdecl.}](glGetProcAddress("glTexStorage2D"))

proc load2_1() =
  cglUniformMatrix2x3fv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glUniformMatrix2x3fv"))
  cglUniformMatrix3x2fv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glUniformMatrix3x2fv"))
  cglUniformMatrix2x4fv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glUniformMatrix2x4fv"))
  cglUniformMatrix4x2fv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glUniformMatrix4x2fv"))
  cglUniformMatrix3x4fv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glUniformMatrix3x4fv"))
  cglUniformMatrix4x3fv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glUniformMatrix4x3fv"))

proc load3_0() =
  cglColorMaski = cast[proc (index: GLuint, r: GLboolean, g: GLboolean, b: GLboolean, a: GLboolean): void {.cdecl.}](glGetProcAddress("glColorMaski"))
  cglGetBooleani_v = cast[proc (target: GLenum, index: GLuint, data: ptr GLboolean): void {.cdecl.}](glGetProcAddress("glGetBooleani_v"))
  cglGetIntegeri_v = cast[proc (target: GLenum, index: GLuint, data: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetIntegeri_v"))
  cglEnablei = cast[proc (target: GLenum, index: GLuint): void {.cdecl.}](glGetProcAddress("glEnablei"))
  cglDisablei = cast[proc (target: GLenum, index: GLuint): void {.cdecl.}](glGetProcAddress("glDisablei"))
  cglIsEnabledi = cast[proc (target: GLenum, index: GLuint): GLboolean {.cdecl.}](glGetProcAddress("glIsEnabledi"))
  cglBeginTransformFeedback = cast[proc (primitiveMode: GLenum): void {.cdecl.}](glGetProcAddress("glBeginTransformFeedback"))
  cglEndTransformFeedback = cast[proc (): void {.cdecl.}](glGetProcAddress("glEndTransformFeedback"))
  cglBindBufferRange = cast[proc (target: GLenum, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr): void {.cdecl.}](glGetProcAddress("glBindBufferRange"))
  cglBindBufferBase = cast[proc (target: GLenum, index: GLuint, buffer: GLuint): void {.cdecl.}](glGetProcAddress("glBindBufferBase"))
  cglTransformFeedbackVaryings = cast[proc (program: GLuint, count: GLsizei, varyings: ptr cstring, bufferMode: GLenum): void {.cdecl.}](glGetProcAddress("glTransformFeedbackVaryings"))
  cglGetTransformFeedbackVarying = cast[proc (program: GLuint, index: GLuint, bufSize: GLsizei, length: ptr GLsizei, size: ptr GLsizei, `type`: ptr GLenum, name: cstring): void {.cdecl.}](glGetProcAddress("glGetTransformFeedbackVarying"))
  cglClampColor = cast[proc (target: GLenum, clamp: GLenum): void {.cdecl.}](glGetProcAddress("glClampColor"))
  cglBeginConditionalRender = cast[proc (id: GLuint, mode: GLenum): void {.cdecl.}](glGetProcAddress("glBeginConditionalRender"))
  cglEndConditionalRender = cast[proc (): void {.cdecl.}](glGetProcAddress("glEndConditionalRender"))
  cglVertexAttribIPointer = cast[proc (index: GLuint, size: GLint, `type`: GLenum, stride: GLsizei, pointer: pointer): void {.cdecl.}](glGetProcAddress("glVertexAttribIPointer"))
  cglGetVertexAttribIiv = cast[proc (index: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetVertexAttribIiv"))
  cglGetVertexAttribIuiv = cast[proc (index: GLuint, pname: GLenum, params: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGetVertexAttribIuiv"))
  cglVertexAttribI1i = cast[proc (index: GLuint, x: GLint): void {.cdecl.}](glGetProcAddress("glVertexAttribI1i"))
  cglVertexAttribI2i = cast[proc (index: GLuint, x: GLint, y: GLint): void {.cdecl.}](glGetProcAddress("glVertexAttribI2i"))
  cglVertexAttribI3i = cast[proc (index: GLuint, x: GLint, y: GLint, z: GLint): void {.cdecl.}](glGetProcAddress("glVertexAttribI3i"))
  cglVertexAttribI4i = cast[proc (index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint): void {.cdecl.}](glGetProcAddress("glVertexAttribI4i"))
  cglVertexAttribI1ui = cast[proc (index: GLuint, x: GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribI1ui"))
  cglVertexAttribI2ui = cast[proc (index: GLuint, x: GLuint, y: GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribI2ui"))
  cglVertexAttribI3ui = cast[proc (index: GLuint, x: GLuint, y: GLuint, z: GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribI3ui"))
  cglVertexAttribI4ui = cast[proc (index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribI4ui"))
  cglVertexAttribI1iv = cast[proc (index: GLuint, v: ptr GLint): void {.cdecl.}](glGetProcAddress("glVertexAttribI1iv"))
  cglVertexAttribI2iv = cast[proc (index: GLuint, v: ptr GLint): void {.cdecl.}](glGetProcAddress("glVertexAttribI2iv"))
  cglVertexAttribI3iv = cast[proc (index: GLuint, v: ptr GLint): void {.cdecl.}](glGetProcAddress("glVertexAttribI3iv"))
  cglVertexAttribI4iv = cast[proc (index: GLuint, v: ptr GLint): void {.cdecl.}](glGetProcAddress("glVertexAttribI4iv"))
  cglVertexAttribI1uiv = cast[proc (index: GLuint, v: ptr GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribI1uiv"))
  cglVertexAttribI2uiv = cast[proc (index: GLuint, v: ptr GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribI2uiv"))
  cglVertexAttribI3uiv = cast[proc (index: GLuint, v: ptr GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribI3uiv"))
  cglVertexAttribI4uiv = cast[proc (index: GLuint, v: ptr GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribI4uiv"))
  cglVertexAttribI4bv = cast[proc (index: GLuint, v: ptr GLbyte): void {.cdecl.}](glGetProcAddress("glVertexAttribI4bv"))
  cglVertexAttribI4sv = cast[proc (index: GLuint, v: ptr GLshort): void {.cdecl.}](glGetProcAddress("glVertexAttribI4sv"))
  cglVertexAttribI4ubv = cast[proc (index: GLuint, v: ptr GLubyte): void {.cdecl.}](glGetProcAddress("glVertexAttribI4ubv"))
  cglVertexAttribI4usv = cast[proc (index: GLuint, v: ptr GLushort): void {.cdecl.}](glGetProcAddress("glVertexAttribI4usv"))
  cglGetUniformuiv = cast[proc (program: GLuint, location: GLint, params: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGetUniformuiv"))
  cglBindFragDataLocation = cast[proc (program: GLuint, color: GLuint, name: cstring): void {.cdecl.}](glGetProcAddress("glBindFragDataLocation"))
  cglGetFragDataLocation = cast[proc (program: GLuint, name: cstring): GLint {.cdecl.}](glGetProcAddress("glGetFragDataLocation"))
  cglUniform1ui = cast[proc (location: GLint, v0: GLuint): void {.cdecl.}](glGetProcAddress("glUniform1ui"))
  cglUniform2ui = cast[proc (location: GLint, v0: GLuint, v1: GLuint): void {.cdecl.}](glGetProcAddress("glUniform2ui"))
  cglUniform3ui = cast[proc (location: GLint, v0: GLuint, v1: GLuint, v2: GLuint): void {.cdecl.}](glGetProcAddress("glUniform3ui"))
  cglUniform4ui = cast[proc (location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint): void {.cdecl.}](glGetProcAddress("glUniform4ui"))
  cglUniform1uiv = cast[proc (location: GLint, count: GLsizei, value: ptr GLuint): void {.cdecl.}](glGetProcAddress("glUniform1uiv"))
  cglUniform2uiv = cast[proc (location: GLint, count: GLsizei, value: ptr GLuint): void {.cdecl.}](glGetProcAddress("glUniform2uiv"))
  cglUniform3uiv = cast[proc (location: GLint, count: GLsizei, value: ptr GLuint): void {.cdecl.}](glGetProcAddress("glUniform3uiv"))
  cglUniform4uiv = cast[proc (location: GLint, count: GLsizei, value: ptr GLuint): void {.cdecl.}](glGetProcAddress("glUniform4uiv"))
  cglTexParameterIiv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glTexParameterIiv"))
  cglTexParameterIuiv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLuint): void {.cdecl.}](glGetProcAddress("glTexParameterIuiv"))
  cglGetTexParameterIiv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetTexParameterIiv"))
  cglGetTexParameterIuiv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGetTexParameterIuiv"))
  cglClearBufferiv = cast[proc (buffer: GLenum, drawbuffer: GLint, value: ptr GLint): void {.cdecl.}](glGetProcAddress("glClearBufferiv"))
  cglClearBufferuiv = cast[proc (buffer: GLenum, drawbuffer: GLint, value: ptr GLuint): void {.cdecl.}](glGetProcAddress("glClearBufferuiv"))
  cglClearBufferfv = cast[proc (buffer: GLenum, drawbuffer: GLint, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glClearBufferfv"))
  cglClearBufferfi = cast[proc (buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint): void {.cdecl.}](glGetProcAddress("glClearBufferfi"))
  cglGetStringi = cast[proc (name: GLenum, index: GLuint): ptr GLubyte {.cdecl.}](glGetProcAddress("glGetStringi"))
  cglFramebufferTexture1D = cast[proc (target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint): void {.cdecl.}](glGetProcAddress("glFramebufferTexture1D"))
  cglFramebufferTexture3D = cast[proc (target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint, zoffset: GLint): void {.cdecl.}](glGetProcAddress("glFramebufferTexture3D"))
  cglBlitFramebuffer = cast[proc (srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum): void {.cdecl.}](glGetProcAddress("glBlitFramebuffer"))
  cglRenderbufferStorageMultisample = cast[proc (target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void {.cdecl.}](glGetProcAddress("glRenderbufferStorageMultisample"))
  cglFramebufferTextureLayer = cast[proc (target: GLenum, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint): void {.cdecl.}](glGetProcAddress("glFramebufferTextureLayer"))
  cglMapBufferRange = cast[proc (target: GLenum, offset: GLintptr, length: GLsizeiptr, access: GLbitfield): pointer {.cdecl.}](glGetProcAddress("glMapBufferRange"))
  cglFlushMappedBufferRange = cast[proc (target: GLenum, offset: GLintptr, length: GLsizeiptr): void {.cdecl.}](glGetProcAddress("glFlushMappedBufferRange"))
  cglBindVertexArray = cast[proc (array: GLuint): void {.cdecl.}](glGetProcAddress("glBindVertexArray"))
  cglDeleteVertexArrays = cast[proc (n: GLsizei, arrays: ptr GLuint): void {.cdecl.}](glGetProcAddress("glDeleteVertexArrays"))
  cglGenVertexArrays = cast[proc (n: GLsizei, arrays: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGenVertexArrays"))
  cglIsVertexArray = cast[proc (array: GLuint): GLboolean {.cdecl.}](glGetProcAddress("glIsVertexArray"))
  cglCopyBufferSubData = cast[proc (readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr): void {.cdecl.}](glGetProcAddress("glCopyBufferSubData"))
  cglGetUniformIndices = cast[proc (program: GLuint, uniformCount: GLsizei, uniformNames: ptr cstring, uniformIndices: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGetUniformIndices"))
  cglGetActiveUniformsiv = cast[proc (program: GLuint, uniformCount: GLsizei, uniformIndices: ptr GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetActiveUniformsiv"))
  cglGetUniformBlockIndex = cast[proc (program: GLuint, uniformBlockName: cstring): GLuint {.cdecl.}](glGetProcAddress("glGetUniformBlockIndex"))
  cglGetActiveUniformBlockiv = cast[proc (program: GLuint, uniformBlockIndex: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetActiveUniformBlockiv"))
  cglGetActiveUniformBlockName = cast[proc (program: GLuint, uniformBlockIndex: GLuint, bufSize: GLsizei, length: ptr GLsizei, uniformBlockName: cstring): void {.cdecl.}](glGetProcAddress("glGetActiveUniformBlockName"))
  cglUniformBlockBinding = cast[proc (program: GLuint, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint): void {.cdecl.}](glGetProcAddress("glUniformBlockBinding"))
  cglDrawArraysInstanced = cast[proc (mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei): void {.cdecl.}](glGetProcAddress("glDrawArraysInstanced"))
  cglDrawElementsInstanced = cast[proc (mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer, instancecount: GLsizei): void {.cdecl.}](glGetProcAddress("glDrawElementsInstanced"))
  cglFenceSync = cast[proc (condition: GLenum, flags: GLbitfield): GLsync {.cdecl.}](glGetProcAddress("glFenceSync"))
  cglIsSync = cast[proc (sync: GLsync): GLboolean {.cdecl.}](glGetProcAddress("glIsSync"))
  cglDeleteSync = cast[proc (sync: GLsync): void {.cdecl.}](glGetProcAddress("glDeleteSync"))
  cglClientWaitSync = cast[proc (sync: GLsync, flags: GLbitfield, timeout: GLuint64): GLenum {.cdecl.}](glGetProcAddress("glClientWaitSync"))
  cglWaitSync = cast[proc (sync: GLsync, flags: GLbitfield, timeout: GLuint64): void {.cdecl.}](glGetProcAddress("glWaitSync"))
  cglGetInteger64v = cast[proc (pname: GLenum, data: ptr GLint64): void {.cdecl.}](glGetProcAddress("glGetInteger64v"))
  cglGetSynciv = cast[proc (sync: GLsync, pname: GLenum, bufSize: GLsizei, length: ptr GLsizei, values: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetSynciv"))
  cglGetInteger64i_v = cast[proc (target: GLenum, index: GLuint, data: ptr GLint64): void {.cdecl.}](glGetProcAddress("glGetInteger64i_v"))
  cglGetBufferParameteri64v = cast[proc (target: GLenum, pname: GLenum, params: ptr GLint64): void {.cdecl.}](glGetProcAddress("glGetBufferParameteri64v"))
  cglGenSamplers = cast[proc (count: GLsizei, samplers: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGenSamplers"))
  cglDeleteSamplers = cast[proc (count: GLsizei, samplers: ptr GLuint): void {.cdecl.}](glGetProcAddress("glDeleteSamplers"))
  cglIsSampler = cast[proc (sampler: GLuint): GLboolean {.cdecl.}](glGetProcAddress("glIsSampler"))
  cglBindSampler = cast[proc (unit: GLuint, sampler: GLuint): void {.cdecl.}](glGetProcAddress("glBindSampler"))
  cglSamplerParameteri = cast[proc (sampler: GLuint, pname: GLenum, param: GLint): void {.cdecl.}](glGetProcAddress("glSamplerParameteri"))
  cglSamplerParameteriv = cast[proc (sampler: GLuint, pname: GLenum, param: ptr GLint): void {.cdecl.}](glGetProcAddress("glSamplerParameteriv"))
  cglSamplerParameterf = cast[proc (sampler: GLuint, pname: GLenum, param: GLfloat): void {.cdecl.}](glGetProcAddress("glSamplerParameterf"))
  cglSamplerParameterfv = cast[proc (sampler: GLuint, pname: GLenum, param: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glSamplerParameterfv"))
  cglGetSamplerParameteriv = cast[proc (sampler: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetSamplerParameteriv"))
  cglGetSamplerParameterfv = cast[proc (sampler: GLuint, pname: GLenum, params: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glGetSamplerParameterfv"))
  cglVertexAttribDivisor = cast[proc (index: GLuint, divisor: GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribDivisor"))
  cglBindTransformFeedback = cast[proc (target: GLenum, id: GLuint): void {.cdecl.}](glGetProcAddress("glBindTransformFeedback"))
  cglDeleteTransformFeedbacks = cast[proc (n: GLsizei, ids: ptr GLuint): void {.cdecl.}](glGetProcAddress("glDeleteTransformFeedbacks"))
  cglGenTransformFeedbacks = cast[proc (n: GLsizei, ids: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGenTransformFeedbacks"))
  cglIsTransformFeedback = cast[proc (id: GLuint): GLboolean {.cdecl.}](glGetProcAddress("glIsTransformFeedback"))
  cglPauseTransformFeedback = cast[proc (): void {.cdecl.}](glGetProcAddress("glPauseTransformFeedback"))
  cglResumeTransformFeedback = cast[proc (): void {.cdecl.}](glGetProcAddress("glResumeTransformFeedback"))
  cglGetProgramBinary = cast[proc (program: GLuint, bufSize: GLsizei, length: ptr GLsizei, binaryFormat: ptr GLenum, binary: pointer): void {.cdecl.}](glGetProcAddress("glGetProgramBinary"))
  cglProgramParameteri = cast[proc (program: GLuint, pname: GLenum, value: GLint): void {.cdecl.}](glGetProcAddress("glProgramParameteri"))
  cglInvalidateFramebuffer = cast[proc (target: GLenum, numAttachments: GLsizei, attachments: ptr GLenum): void {.cdecl.}](glGetProcAddress("glInvalidateFramebuffer"))
  cglInvalidateSubFramebuffer = cast[proc (target: GLenum, numAttachments: GLsizei, attachments: ptr GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}](glGetProcAddress("glInvalidateSubFramebuffer"))
  cglTexStorage3D = cast[proc (target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei): void {.cdecl.}](glGetProcAddress("glTexStorage3D"))
  cglGetInternalformativ = cast[proc (target: GLenum, internalformat: GLenum, pname: GLenum, bufSize: GLsizei, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetInternalformativ"))

proc load3_1() =
  cglTexBuffer = cast[proc (target: GLenum, internalformat: GLenum, buffer: GLuint): void {.cdecl.}](glGetProcAddress("glTexBuffer"))
  cglPrimitiveRestartIndex = cast[proc (index: GLuint): void {.cdecl.}](glGetProcAddress("glPrimitiveRestartIndex"))
  cglGetActiveUniformName = cast[proc (program: GLuint, uniformIndex: GLuint, bufSize: GLsizei, length: ptr GLsizei, uniformName: cstring): void {.cdecl.}](glGetProcAddress("glGetActiveUniformName"))
  cglDispatchCompute = cast[proc (num_groups_x: GLuint, num_groups_y: GLuint, num_groups_z: GLuint): void {.cdecl.}](glGetProcAddress("glDispatchCompute"))
  cglDispatchComputeIndirect = cast[proc (indirect: GLintptr): void {.cdecl.}](glGetProcAddress("glDispatchComputeIndirect"))
  cglDrawArraysIndirect = cast[proc (mode: GLenum, indirect: pointer): void {.cdecl.}](glGetProcAddress("glDrawArraysIndirect"))
  cglDrawElementsIndirect = cast[proc (mode: GLenum, `type`: GLenum, indirect: pointer): void {.cdecl.}](glGetProcAddress("glDrawElementsIndirect"))
  cglFramebufferParameteri = cast[proc (target: GLenum, pname: GLenum, param: GLint): void {.cdecl.}](glGetProcAddress("glFramebufferParameteri"))
  cglGetFramebufferParameteriv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetFramebufferParameteriv"))
  cglGetProgramInterfaceiv = cast[proc (program: GLuint, programInterface: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetProgramInterfaceiv"))
  cglGetProgramResourceIndex = cast[proc (program: GLuint, programInterface: GLenum, name: cstring): GLuint {.cdecl.}](glGetProcAddress("glGetProgramResourceIndex"))
  cglGetProgramResourceName = cast[proc (program: GLuint, programInterface: GLenum, index: GLuint, bufSize: GLsizei, length: ptr GLsizei, name: cstring): void {.cdecl.}](glGetProcAddress("glGetProgramResourceName"))
  cglGetProgramResourceiv = cast[proc (program: GLuint, programInterface: GLenum, index: GLuint, propCount: GLsizei, props: ptr GLenum, bufSize: GLsizei, length: ptr GLsizei, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetProgramResourceiv"))
  cglGetProgramResourceLocation = cast[proc (program: GLuint, programInterface: GLenum, name: cstring): GLint {.cdecl.}](glGetProcAddress("glGetProgramResourceLocation"))
  cglUseProgramStages = cast[proc (pipeline: GLuint, stages: GLbitfield, program: GLuint): void {.cdecl.}](glGetProcAddress("glUseProgramStages"))
  cglActiveShaderProgram = cast[proc (pipeline: GLuint, program: GLuint): void {.cdecl.}](glGetProcAddress("glActiveShaderProgram"))
  cglCreateShaderProgramv = cast[proc (`type`: GLenum, count: GLsizei, strings: ptr cstring): GLuint {.cdecl.}](glGetProcAddress("glCreateShaderProgramv"))
  cglBindProgramPipeline = cast[proc (pipeline: GLuint): void {.cdecl.}](glGetProcAddress("glBindProgramPipeline"))
  cglDeleteProgramPipelines = cast[proc (n: GLsizei, pipelines: ptr GLuint): void {.cdecl.}](glGetProcAddress("glDeleteProgramPipelines"))
  cglGenProgramPipelines = cast[proc (n: GLsizei, pipelines: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGenProgramPipelines"))
  cglIsProgramPipeline = cast[proc (pipeline: GLuint): GLboolean {.cdecl.}](glGetProcAddress("glIsProgramPipeline"))
  cglGetProgramPipelineiv = cast[proc (pipeline: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetProgramPipelineiv"))
  cglProgramUniform1i = cast[proc (program: GLuint, location: GLint, v0: GLint): void {.cdecl.}](glGetProcAddress("glProgramUniform1i"))
  cglProgramUniform2i = cast[proc (program: GLuint, location: GLint, v0: GLint, v1: GLint): void {.cdecl.}](glGetProcAddress("glProgramUniform2i"))
  cglProgramUniform3i = cast[proc (program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint): void {.cdecl.}](glGetProcAddress("glProgramUniform3i"))
  cglProgramUniform4i = cast[proc (program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint): void {.cdecl.}](glGetProcAddress("glProgramUniform4i"))
  cglProgramUniform1ui = cast[proc (program: GLuint, location: GLint, v0: GLuint): void {.cdecl.}](glGetProcAddress("glProgramUniform1ui"))
  cglProgramUniform2ui = cast[proc (program: GLuint, location: GLint, v0: GLuint, v1: GLuint): void {.cdecl.}](glGetProcAddress("glProgramUniform2ui"))
  cglProgramUniform3ui = cast[proc (program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint): void {.cdecl.}](glGetProcAddress("glProgramUniform3ui"))
  cglProgramUniform4ui = cast[proc (program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint): void {.cdecl.}](glGetProcAddress("glProgramUniform4ui"))
  cglProgramUniform1f = cast[proc (program: GLuint, location: GLint, v0: GLfloat): void {.cdecl.}](glGetProcAddress("glProgramUniform1f"))
  cglProgramUniform2f = cast[proc (program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat): void {.cdecl.}](glGetProcAddress("glProgramUniform2f"))
  cglProgramUniform3f = cast[proc (program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat): void {.cdecl.}](glGetProcAddress("glProgramUniform3f"))
  cglProgramUniform4f = cast[proc (program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat): void {.cdecl.}](glGetProcAddress("glProgramUniform4f"))
  cglProgramUniform1iv = cast[proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLint): void {.cdecl.}](glGetProcAddress("glProgramUniform1iv"))
  cglProgramUniform2iv = cast[proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLint): void {.cdecl.}](glGetProcAddress("glProgramUniform2iv"))
  cglProgramUniform3iv = cast[proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLint): void {.cdecl.}](glGetProcAddress("glProgramUniform3iv"))
  cglProgramUniform4iv = cast[proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLint): void {.cdecl.}](glGetProcAddress("glProgramUniform4iv"))
  cglProgramUniform1uiv = cast[proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLuint): void {.cdecl.}](glGetProcAddress("glProgramUniform1uiv"))
  cglProgramUniform2uiv = cast[proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLuint): void {.cdecl.}](glGetProcAddress("glProgramUniform2uiv"))
  cglProgramUniform3uiv = cast[proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLuint): void {.cdecl.}](glGetProcAddress("glProgramUniform3uiv"))
  cglProgramUniform4uiv = cast[proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLuint): void {.cdecl.}](glGetProcAddress("glProgramUniform4uiv"))
  cglProgramUniform1fv = cast[proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glProgramUniform1fv"))
  cglProgramUniform2fv = cast[proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glProgramUniform2fv"))
  cglProgramUniform3fv = cast[proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glProgramUniform3fv"))
  cglProgramUniform4fv = cast[proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glProgramUniform4fv"))
  cglProgramUniformMatrix2fv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix2fv"))
  cglProgramUniformMatrix3fv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix3fv"))
  cglProgramUniformMatrix4fv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix4fv"))
  cglProgramUniformMatrix2x3fv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix2x3fv"))
  cglProgramUniformMatrix3x2fv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix3x2fv"))
  cglProgramUniformMatrix2x4fv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix2x4fv"))
  cglProgramUniformMatrix4x2fv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix4x2fv"))
  cglProgramUniformMatrix3x4fv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix3x4fv"))
  cglProgramUniformMatrix4x3fv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix4x3fv"))
  cglValidateProgramPipeline = cast[proc (pipeline: GLuint): void {.cdecl.}](glGetProcAddress("glValidateProgramPipeline"))
  cglGetProgramPipelineInfoLog = cast[proc (pipeline: GLuint, bufSize: GLsizei, length: ptr GLsizei, infoLog: cstring): void {.cdecl.}](glGetProcAddress("glGetProgramPipelineInfoLog"))
  cglBindImageTexture = cast[proc (unit: GLuint, texture: GLuint, level: GLint, layered: GLboolean, layer: GLint, access: GLenum, format: GLenum): void {.cdecl.}](glGetProcAddress("glBindImageTexture"))
  cglMemoryBarrier = cast[proc (barriers: GLbitfield): void {.cdecl.}](glGetProcAddress("glMemoryBarrier"))
  cglMemoryBarrierByRegion = cast[proc (barriers: GLbitfield): void {.cdecl.}](glGetProcAddress("glMemoryBarrierByRegion"))
  cglTexStorage2DMultisample = cast[proc (target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean): void {.cdecl.}](glGetProcAddress("glTexStorage2DMultisample"))
  cglGetMultisamplefv = cast[proc (pname: GLenum, index: GLuint, val: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glGetMultisamplefv"))
  cglSampleMaski = cast[proc (maskNumber: GLuint, mask: GLbitfield): void {.cdecl.}](glGetProcAddress("glSampleMaski"))
  cglBindVertexBuffer = cast[proc (bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei): void {.cdecl.}](glGetProcAddress("glBindVertexBuffer"))
  cglVertexAttribFormat = cast[proc (attribindex: GLuint, size: GLint, `type`: GLenum, normalized: GLboolean, relativeoffset: GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribFormat"))
  cglVertexAttribIFormat = cast[proc (attribindex: GLuint, size: GLint, `type`: GLenum, relativeoffset: GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribIFormat"))
  cglVertexAttribBinding = cast[proc (attribindex: GLuint, bindingindex: GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribBinding"))
  cglVertexBindingDivisor = cast[proc (bindingindex: GLuint, divisor: GLuint): void {.cdecl.}](glGetProcAddress("glVertexBindingDivisor"))

proc load3_2() =
  cglDrawElementsBaseVertex = cast[proc (mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer, basevertex: GLint): void {.cdecl.}](glGetProcAddress("glDrawElementsBaseVertex"))
  cglDrawRangeElementsBaseVertex = cast[proc (mode: GLenum, start: GLuint, `end`: GLuint, count: GLsizei, `type`: GLenum, indices: pointer, basevertex: GLint): void {.cdecl.}](glGetProcAddress("glDrawRangeElementsBaseVertex"))
  cglDrawElementsInstancedBaseVertex = cast[proc (mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer, instancecount: GLsizei, basevertex: GLint): void {.cdecl.}](glGetProcAddress("glDrawElementsInstancedBaseVertex"))
  cglMultiDrawElementsBaseVertex = cast[proc (mode: GLenum, count: ptr GLsizei, `type`: GLenum, indices: ptr pointer, drawcount: GLsizei, basevertex: ptr GLint): void {.cdecl.}](glGetProcAddress("glMultiDrawElementsBaseVertex"))
  cglProvokingVertex = cast[proc (mode: GLenum): void {.cdecl.}](glGetProcAddress("glProvokingVertex"))
  cglFramebufferTexture = cast[proc (target: GLenum, attachment: GLenum, texture: GLuint, level: GLint): void {.cdecl.}](glGetProcAddress("glFramebufferTexture"))
  cglTexImage2DMultisample = cast[proc (target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean): void {.cdecl.}](glGetProcAddress("glTexImage2DMultisample"))
  cglTexImage3DMultisample = cast[proc (target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean): void {.cdecl.}](glGetProcAddress("glTexImage3DMultisample"))
  cglBlendBarrier = cast[proc (): void {.cdecl.}](glGetProcAddress("glBlendBarrier"))
  cglCopyImageSubData = cast[proc (srcName: GLuint, srcTarget: GLenum, srcLevel: GLint, srcX: GLint, srcY: GLint, srcZ: GLint, dstName: GLuint, dstTarget: GLenum, dstLevel: GLint, dstX: GLint, dstY: GLint, dstZ: GLint, srcWidth: GLsizei, srcHeight: GLsizei, srcDepth: GLsizei): void {.cdecl.}](glGetProcAddress("glCopyImageSubData"))
  cglDebugMessageControl = cast[proc (source: GLenum, `type`: GLenum, severity: GLenum, count: GLsizei, ids: ptr GLuint, enabled: GLboolean): void {.cdecl.}](glGetProcAddress("glDebugMessageControl"))
  cglDebugMessageInsert = cast[proc (source: GLenum, `type`: GLenum, id: GLuint, severity: GLenum, length: GLsizei, buf: cstring): void {.cdecl.}](glGetProcAddress("glDebugMessageInsert"))
  cglDebugMessageCallback = cast[proc (callback: GLDEBUGPROC, userParam: pointer): void {.cdecl.}](glGetProcAddress("glDebugMessageCallback"))
  cglGetDebugMessageLog = cast[proc (count: GLuint, bufSize: GLsizei, sources: ptr GLenum, types: ptr GLenum, ids: ptr GLuint, severities: ptr GLenum, lengths: ptr GLsizei, messageLog: cstring): GLuint {.cdecl.}](glGetProcAddress("glGetDebugMessageLog"))
  cglPushDebugGroup = cast[proc (source: GLenum, id: GLuint, length: GLsizei, message: cstring): void {.cdecl.}](glGetProcAddress("glPushDebugGroup"))
  cglPopDebugGroup = cast[proc (): void {.cdecl.}](glGetProcAddress("glPopDebugGroup"))
  cglObjectLabel = cast[proc (identifier: GLenum, name: GLuint, length: GLsizei, label: cstring): void {.cdecl.}](glGetProcAddress("glObjectLabel"))
  cglGetObjectLabel = cast[proc (identifier: GLenum, name: GLuint, bufSize: GLsizei, length: ptr GLsizei, label: cstring): void {.cdecl.}](glGetProcAddress("glGetObjectLabel"))
  cglObjectPtrLabel = cast[proc (`ptr`: pointer, length: GLsizei, label: cstring): void {.cdecl.}](glGetProcAddress("glObjectPtrLabel"))
  cglGetObjectPtrLabel = cast[proc (`ptr`: pointer, bufSize: GLsizei, length: ptr GLsizei, label: cstring): void {.cdecl.}](glGetProcAddress("glGetObjectPtrLabel"))
  cglBlendEquationi = cast[proc (buf: GLuint, mode: GLenum): void {.cdecl.}](glGetProcAddress("glBlendEquationi"))
  cglBlendEquationSeparatei = cast[proc (buf: GLuint, modeRGB: GLenum, modeAlpha: GLenum): void {.cdecl.}](glGetProcAddress("glBlendEquationSeparatei"))
  cglBlendFunci = cast[proc (buf: GLuint, src: GLenum, dst: GLenum): void {.cdecl.}](glGetProcAddress("glBlendFunci"))
  cglBlendFuncSeparatei = cast[proc (buf: GLuint, srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum): void {.cdecl.}](glGetProcAddress("glBlendFuncSeparatei"))
  cglPrimitiveBoundingBox = cast[proc (minX: GLfloat, minY: GLfloat, minZ: GLfloat, minW: GLfloat, maxX: GLfloat, maxY: GLfloat, maxZ: GLfloat, maxW: GLfloat): void {.cdecl.}](glGetProcAddress("glPrimitiveBoundingBox"))
  cglGetnUniformuiv = cast[proc (program: GLuint, location: GLint, bufSize: GLsizei, params: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGetnUniformuiv"))
  cglMinSampleShading = cast[proc (value: GLfloat): void {.cdecl.}](glGetProcAddress("glMinSampleShading"))
  cglPatchParameteri = cast[proc (pname: GLenum, value: GLint): void {.cdecl.}](glGetProcAddress("glPatchParameteri"))
  cglSamplerParameterIiv = cast[proc (sampler: GLuint, pname: GLenum, param: ptr GLint): void {.cdecl.}](glGetProcAddress("glSamplerParameterIiv"))
  cglSamplerParameterIuiv = cast[proc (sampler: GLuint, pname: GLenum, param: ptr GLuint): void {.cdecl.}](glGetProcAddress("glSamplerParameterIuiv"))
  cglGetSamplerParameterIiv = cast[proc (sampler: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetSamplerParameterIiv"))
  cglGetSamplerParameterIuiv = cast[proc (sampler: GLuint, pname: GLenum, params: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGetSamplerParameterIuiv"))
  cglTexBufferRange = cast[proc (target: GLenum, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr): void {.cdecl.}](glGetProcAddress("glTexBufferRange"))
  cglTexStorage3DMultisample = cast[proc (target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean): void {.cdecl.}](glGetProcAddress("glTexStorage3DMultisample"))

proc load3_3() =
  cglBindFragDataLocationIndexed = cast[proc (program: GLuint, colorNumber: GLuint, index: GLuint, name: cstring): void {.cdecl.}](glGetProcAddress("glBindFragDataLocationIndexed"))
  cglGetFragDataIndex = cast[proc (program: GLuint, name: cstring): GLint {.cdecl.}](glGetProcAddress("glGetFragDataIndex"))
  cglQueryCounter = cast[proc (id: GLuint, target: GLenum): void {.cdecl.}](glGetProcAddress("glQueryCounter"))
  cglGetQueryObjecti64v = cast[proc (id: GLuint, pname: GLenum, params: ptr GLint64): void {.cdecl.}](glGetProcAddress("glGetQueryObjecti64v"))
  cglGetQueryObjectui64v = cast[proc (id: GLuint, pname: GLenum, params: ptr GLuint64): void {.cdecl.}](glGetProcAddress("glGetQueryObjectui64v"))
  cglVertexAttribP1ui = cast[proc (index: GLuint, `type`: GLenum, normalized: GLboolean, value: GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribP1ui"))
  cglVertexAttribP1uiv = cast[proc (index: GLuint, `type`: GLenum, normalized: GLboolean, value: ptr GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribP1uiv"))
  cglVertexAttribP2ui = cast[proc (index: GLuint, `type`: GLenum, normalized: GLboolean, value: GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribP2ui"))
  cglVertexAttribP2uiv = cast[proc (index: GLuint, `type`: GLenum, normalized: GLboolean, value: ptr GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribP2uiv"))
  cglVertexAttribP3ui = cast[proc (index: GLuint, `type`: GLenum, normalized: GLboolean, value: GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribP3ui"))
  cglVertexAttribP3uiv = cast[proc (index: GLuint, `type`: GLenum, normalized: GLboolean, value: ptr GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribP3uiv"))
  cglVertexAttribP4ui = cast[proc (index: GLuint, `type`: GLenum, normalized: GLboolean, value: GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribP4ui"))
  cglVertexAttribP4uiv = cast[proc (index: GLuint, `type`: GLenum, normalized: GLboolean, value: ptr GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribP4uiv"))
  cglVertexP2ui = cast[proc (`type`: GLenum, value: GLuint): void {.cdecl.}](glGetProcAddress("glVertexP2ui"))
  cglVertexP2uiv = cast[proc (`type`: GLenum, value: ptr GLuint): void {.cdecl.}](glGetProcAddress("glVertexP2uiv"))
  cglVertexP3ui = cast[proc (`type`: GLenum, value: GLuint): void {.cdecl.}](glGetProcAddress("glVertexP3ui"))
  cglVertexP3uiv = cast[proc (`type`: GLenum, value: ptr GLuint): void {.cdecl.}](glGetProcAddress("glVertexP3uiv"))
  cglVertexP4ui = cast[proc (`type`: GLenum, value: GLuint): void {.cdecl.}](glGetProcAddress("glVertexP4ui"))
  cglVertexP4uiv = cast[proc (`type`: GLenum, value: ptr GLuint): void {.cdecl.}](glGetProcAddress("glVertexP4uiv"))
  cglTexCoordP1ui = cast[proc (`type`: GLenum, coords: GLuint): void {.cdecl.}](glGetProcAddress("glTexCoordP1ui"))
  cglTexCoordP1uiv = cast[proc (`type`: GLenum, coords: ptr GLuint): void {.cdecl.}](glGetProcAddress("glTexCoordP1uiv"))
  cglTexCoordP2ui = cast[proc (`type`: GLenum, coords: GLuint): void {.cdecl.}](glGetProcAddress("glTexCoordP2ui"))
  cglTexCoordP2uiv = cast[proc (`type`: GLenum, coords: ptr GLuint): void {.cdecl.}](glGetProcAddress("glTexCoordP2uiv"))
  cglTexCoordP3ui = cast[proc (`type`: GLenum, coords: GLuint): void {.cdecl.}](glGetProcAddress("glTexCoordP3ui"))
  cglTexCoordP3uiv = cast[proc (`type`: GLenum, coords: ptr GLuint): void {.cdecl.}](glGetProcAddress("glTexCoordP3uiv"))
  cglTexCoordP4ui = cast[proc (`type`: GLenum, coords: GLuint): void {.cdecl.}](glGetProcAddress("glTexCoordP4ui"))
  cglTexCoordP4uiv = cast[proc (`type`: GLenum, coords: ptr GLuint): void {.cdecl.}](glGetProcAddress("glTexCoordP4uiv"))
  cglMultiTexCoordP1ui = cast[proc (texture: GLenum, `type`: GLenum, coords: GLuint): void {.cdecl.}](glGetProcAddress("glMultiTexCoordP1ui"))
  cglMultiTexCoordP1uiv = cast[proc (texture: GLenum, `type`: GLenum, coords: ptr GLuint): void {.cdecl.}](glGetProcAddress("glMultiTexCoordP1uiv"))
  cglMultiTexCoordP2ui = cast[proc (texture: GLenum, `type`: GLenum, coords: GLuint): void {.cdecl.}](glGetProcAddress("glMultiTexCoordP2ui"))
  cglMultiTexCoordP2uiv = cast[proc (texture: GLenum, `type`: GLenum, coords: ptr GLuint): void {.cdecl.}](glGetProcAddress("glMultiTexCoordP2uiv"))
  cglMultiTexCoordP3ui = cast[proc (texture: GLenum, `type`: GLenum, coords: GLuint): void {.cdecl.}](glGetProcAddress("glMultiTexCoordP3ui"))
  cglMultiTexCoordP3uiv = cast[proc (texture: GLenum, `type`: GLenum, coords: ptr GLuint): void {.cdecl.}](glGetProcAddress("glMultiTexCoordP3uiv"))
  cglMultiTexCoordP4ui = cast[proc (texture: GLenum, `type`: GLenum, coords: GLuint): void {.cdecl.}](glGetProcAddress("glMultiTexCoordP4ui"))
  cglMultiTexCoordP4uiv = cast[proc (texture: GLenum, `type`: GLenum, coords: ptr GLuint): void {.cdecl.}](glGetProcAddress("glMultiTexCoordP4uiv"))
  cglNormalP3ui = cast[proc (`type`: GLenum, coords: GLuint): void {.cdecl.}](glGetProcAddress("glNormalP3ui"))
  cglNormalP3uiv = cast[proc (`type`: GLenum, coords: ptr GLuint): void {.cdecl.}](glGetProcAddress("glNormalP3uiv"))
  cglColorP3ui = cast[proc (`type`: GLenum, color: GLuint): void {.cdecl.}](glGetProcAddress("glColorP3ui"))
  cglColorP3uiv = cast[proc (`type`: GLenum, color: ptr GLuint): void {.cdecl.}](glGetProcAddress("glColorP3uiv"))
  cglColorP4ui = cast[proc (`type`: GLenum, color: GLuint): void {.cdecl.}](glGetProcAddress("glColorP4ui"))
  cglColorP4uiv = cast[proc (`type`: GLenum, color: ptr GLuint): void {.cdecl.}](glGetProcAddress("glColorP4uiv"))
  cglSecondaryColorP3ui = cast[proc (`type`: GLenum, color: GLuint): void {.cdecl.}](glGetProcAddress("glSecondaryColorP3ui"))
  cglSecondaryColorP3uiv = cast[proc (`type`: GLenum, color: ptr GLuint): void {.cdecl.}](glGetProcAddress("glSecondaryColorP3uiv"))

proc load4_0() =
  cglUniform1d = cast[proc (location: GLint, x: GLdouble): void {.cdecl.}](glGetProcAddress("glUniform1d"))
  cglUniform2d = cast[proc (location: GLint, x: GLdouble, y: GLdouble): void {.cdecl.}](glGetProcAddress("glUniform2d"))
  cglUniform3d = cast[proc (location: GLint, x: GLdouble, y: GLdouble, z: GLdouble): void {.cdecl.}](glGetProcAddress("glUniform3d"))
  cglUniform4d = cast[proc (location: GLint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble): void {.cdecl.}](glGetProcAddress("glUniform4d"))
  cglUniform1dv = cast[proc (location: GLint, count: GLsizei, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glUniform1dv"))
  cglUniform2dv = cast[proc (location: GLint, count: GLsizei, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glUniform2dv"))
  cglUniform3dv = cast[proc (location: GLint, count: GLsizei, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glUniform3dv"))
  cglUniform4dv = cast[proc (location: GLint, count: GLsizei, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glUniform4dv"))
  cglUniformMatrix2dv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glUniformMatrix2dv"))
  cglUniformMatrix3dv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glUniformMatrix3dv"))
  cglUniformMatrix4dv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glUniformMatrix4dv"))
  cglUniformMatrix2x3dv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glUniformMatrix2x3dv"))
  cglUniformMatrix2x4dv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glUniformMatrix2x4dv"))
  cglUniformMatrix3x2dv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glUniformMatrix3x2dv"))
  cglUniformMatrix3x4dv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glUniformMatrix3x4dv"))
  cglUniformMatrix4x2dv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glUniformMatrix4x2dv"))
  cglUniformMatrix4x3dv = cast[proc (location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glUniformMatrix4x3dv"))
  cglGetUniformdv = cast[proc (program: GLuint, location: GLint, params: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glGetUniformdv"))
  cglGetSubroutineUniformLocation = cast[proc (program: GLuint, shadertype: GLenum, name: cstring): GLint {.cdecl.}](glGetProcAddress("glGetSubroutineUniformLocation"))
  cglGetSubroutineIndex = cast[proc (program: GLuint, shadertype: GLenum, name: cstring): GLuint {.cdecl.}](glGetProcAddress("glGetSubroutineIndex"))
  cglGetActiveSubroutineUniformiv = cast[proc (program: GLuint, shadertype: GLenum, index: GLuint, pname: GLenum, values: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetActiveSubroutineUniformiv"))
  cglGetActiveSubroutineUniformName = cast[proc (program: GLuint, shadertype: GLenum, index: GLuint, bufsize: GLsizei, length: ptr GLsizei, name: cstring): void {.cdecl.}](glGetProcAddress("glGetActiveSubroutineUniformName"))
  cglGetActiveSubroutineName = cast[proc (program: GLuint, shadertype: GLenum, index: GLuint, bufsize: GLsizei, length: ptr GLsizei, name: cstring): void {.cdecl.}](glGetProcAddress("glGetActiveSubroutineName"))
  cglUniformSubroutinesuiv = cast[proc (shadertype: GLenum, count: GLsizei, indices: ptr GLuint): void {.cdecl.}](glGetProcAddress("glUniformSubroutinesuiv"))
  cglGetUniformSubroutineuiv = cast[proc (shadertype: GLenum, location: GLint, params: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGetUniformSubroutineuiv"))
  cglGetProgramStageiv = cast[proc (program: GLuint, shadertype: GLenum, pname: GLenum, values: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetProgramStageiv"))
  cglPatchParameterfv = cast[proc (pname: GLenum, values: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glPatchParameterfv"))
  cglDrawTransformFeedback = cast[proc (mode: GLenum, id: GLuint): void {.cdecl.}](glGetProcAddress("glDrawTransformFeedback"))
  cglDrawTransformFeedbackStream = cast[proc (mode: GLenum, id: GLuint, stream: GLuint): void {.cdecl.}](glGetProcAddress("glDrawTransformFeedbackStream"))
  cglBeginQueryIndexed = cast[proc (target: GLenum, index: GLuint, id: GLuint): void {.cdecl.}](glGetProcAddress("glBeginQueryIndexed"))
  cglEndQueryIndexed = cast[proc (target: GLenum, index: GLuint): void {.cdecl.}](glGetProcAddress("glEndQueryIndexed"))
  cglGetQueryIndexediv = cast[proc (target: GLenum, index: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetQueryIndexediv"))

proc load4_1() =
  cglProgramUniform1d = cast[proc (program: GLuint, location: GLint, v0: GLdouble): void {.cdecl.}](glGetProcAddress("glProgramUniform1d"))
  cglProgramUniform1dv = cast[proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glProgramUniform1dv"))
  cglProgramUniform2d = cast[proc (program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble): void {.cdecl.}](glGetProcAddress("glProgramUniform2d"))
  cglProgramUniform2dv = cast[proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glProgramUniform2dv"))
  cglProgramUniform3d = cast[proc (program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble): void {.cdecl.}](glGetProcAddress("glProgramUniform3d"))
  cglProgramUniform3dv = cast[proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glProgramUniform3dv"))
  cglProgramUniform4d = cast[proc (program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble, v3: GLdouble): void {.cdecl.}](glGetProcAddress("glProgramUniform4d"))
  cglProgramUniform4dv = cast[proc (program: GLuint, location: GLint, count: GLsizei, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glProgramUniform4dv"))
  cglProgramUniformMatrix2dv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix2dv"))
  cglProgramUniformMatrix3dv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix3dv"))
  cglProgramUniformMatrix4dv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix4dv"))
  cglProgramUniformMatrix2x3dv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix2x3dv"))
  cglProgramUniformMatrix3x2dv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix3x2dv"))
  cglProgramUniformMatrix2x4dv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix2x4dv"))
  cglProgramUniformMatrix4x2dv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix4x2dv"))
  cglProgramUniformMatrix3x4dv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix3x4dv"))
  cglProgramUniformMatrix4x3dv = cast[proc (program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glProgramUniformMatrix4x3dv"))
  cglVertexAttribL1d = cast[proc (index: GLuint, x: GLdouble): void {.cdecl.}](glGetProcAddress("glVertexAttribL1d"))
  cglVertexAttribL2d = cast[proc (index: GLuint, x: GLdouble, y: GLdouble): void {.cdecl.}](glGetProcAddress("glVertexAttribL2d"))
  cglVertexAttribL3d = cast[proc (index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble): void {.cdecl.}](glGetProcAddress("glVertexAttribL3d"))
  cglVertexAttribL4d = cast[proc (index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble): void {.cdecl.}](glGetProcAddress("glVertexAttribL4d"))
  cglVertexAttribL1dv = cast[proc (index: GLuint, v: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glVertexAttribL1dv"))
  cglVertexAttribL2dv = cast[proc (index: GLuint, v: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glVertexAttribL2dv"))
  cglVertexAttribL3dv = cast[proc (index: GLuint, v: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glVertexAttribL3dv"))
  cglVertexAttribL4dv = cast[proc (index: GLuint, v: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glVertexAttribL4dv"))
  cglVertexAttribLPointer = cast[proc (index: GLuint, size: GLint, `type`: GLenum, stride: GLsizei, pointer: pointer): void {.cdecl.}](glGetProcAddress("glVertexAttribLPointer"))
  cglGetVertexAttribLdv = cast[proc (index: GLuint, pname: GLenum, params: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glGetVertexAttribLdv"))
  cglViewportArrayv = cast[proc (first: GLuint, count: GLsizei, v: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glViewportArrayv"))
  cglViewportIndexedf = cast[proc (index: GLuint, x: GLfloat, y: GLfloat, w: GLfloat, h: GLfloat): void {.cdecl.}](glGetProcAddress("glViewportIndexedf"))
  cglViewportIndexedfv = cast[proc (index: GLuint, v: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glViewportIndexedfv"))
  cglScissorArrayv = cast[proc (first: GLuint, count: GLsizei, v: ptr GLint): void {.cdecl.}](glGetProcAddress("glScissorArrayv"))
  cglScissorIndexed = cast[proc (index: GLuint, left: GLint, bottom: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}](glGetProcAddress("glScissorIndexed"))
  cglScissorIndexedv = cast[proc (index: GLuint, v: ptr GLint): void {.cdecl.}](glGetProcAddress("glScissorIndexedv"))
  cglDepthRangeArrayv = cast[proc (first: GLuint, count: GLsizei, v: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glDepthRangeArrayv"))
  cglDepthRangeIndexed = cast[proc (index: GLuint, n: GLdouble, f: GLdouble): void {.cdecl.}](glGetProcAddress("glDepthRangeIndexed"))
  cglGetFloati_v = cast[proc (target: GLenum, index: GLuint, data: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glGetFloati_v"))
  cglGetDoublei_v = cast[proc (target: GLenum, index: GLuint, data: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glGetDoublei_v"))

proc load4_2() =
  cglDrawArraysInstancedBaseInstance = cast[proc (mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei, baseinstance: GLuint): void {.cdecl.}](glGetProcAddress("glDrawArraysInstancedBaseInstance"))
  cglDrawElementsInstancedBaseInstance = cast[proc (mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer, instancecount: GLsizei, baseinstance: GLuint): void {.cdecl.}](glGetProcAddress("glDrawElementsInstancedBaseInstance"))
  cglDrawElementsInstancedBaseVertexBaseInstance = cast[proc (mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer, instancecount: GLsizei, basevertex: GLint, baseinstance: GLuint): void {.cdecl.}](glGetProcAddress("glDrawElementsInstancedBaseVertexBaseInstance"))
  cglGetActiveAtomicCounterBufferiv = cast[proc (program: GLuint, bufferIndex: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetActiveAtomicCounterBufferiv"))
  cglTexStorage1D = cast[proc (target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei): void {.cdecl.}](glGetProcAddress("glTexStorage1D"))
  cglDrawTransformFeedbackInstanced = cast[proc (mode: GLenum, id: GLuint, instancecount: GLsizei): void {.cdecl.}](glGetProcAddress("glDrawTransformFeedbackInstanced"))
  cglDrawTransformFeedbackStreamInstanced = cast[proc (mode: GLenum, id: GLuint, stream: GLuint, instancecount: GLsizei): void {.cdecl.}](glGetProcAddress("glDrawTransformFeedbackStreamInstanced"))

proc load4_3() =
  cglClearBufferData = cast[proc (target: GLenum, internalformat: GLenum, format: GLenum, `type`: GLenum, data: pointer): void {.cdecl.}](glGetProcAddress("glClearBufferData"))
  cglClearBufferSubData = cast[proc (target: GLenum, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, `type`: GLenum, data: pointer): void {.cdecl.}](glGetProcAddress("glClearBufferSubData"))
  cglGetInternalformati64v = cast[proc (target: GLenum, internalformat: GLenum, pname: GLenum, bufSize: GLsizei, params: ptr GLint64): void {.cdecl.}](glGetProcAddress("glGetInternalformati64v"))
  cglInvalidateTexSubImage = cast[proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei): void {.cdecl.}](glGetProcAddress("glInvalidateTexSubImage"))
  cglInvalidateTexImage = cast[proc (texture: GLuint, level: GLint): void {.cdecl.}](glGetProcAddress("glInvalidateTexImage"))
  cglInvalidateBufferSubData = cast[proc (buffer: GLuint, offset: GLintptr, length: GLsizeiptr): void {.cdecl.}](glGetProcAddress("glInvalidateBufferSubData"))
  cglInvalidateBufferData = cast[proc (buffer: GLuint): void {.cdecl.}](glGetProcAddress("glInvalidateBufferData"))
  cglMultiDrawArraysIndirect = cast[proc (mode: GLenum, indirect: pointer, drawcount: GLsizei, stride: GLsizei): void {.cdecl.}](glGetProcAddress("glMultiDrawArraysIndirect"))
  cglMultiDrawElementsIndirect = cast[proc (mode: GLenum, `type`: GLenum, indirect: pointer, drawcount: GLsizei, stride: GLsizei): void {.cdecl.}](glGetProcAddress("glMultiDrawElementsIndirect"))
  cglGetProgramResourceLocationIndex = cast[proc (program: GLuint, programInterface: GLenum, name: cstring): GLint {.cdecl.}](glGetProcAddress("glGetProgramResourceLocationIndex"))
  cglShaderStorageBlockBinding = cast[proc (program: GLuint, storageBlockIndex: GLuint, storageBlockBinding: GLuint): void {.cdecl.}](glGetProcAddress("glShaderStorageBlockBinding"))
  cglTextureView = cast[proc (texture: GLuint, target: GLenum, origtexture: GLuint, internalformat: GLenum, minlevel: GLuint, numlevels: GLuint, minlayer: GLuint, numlayers: GLuint): void {.cdecl.}](glGetProcAddress("glTextureView"))
  cglVertexAttribLFormat = cast[proc (attribindex: GLuint, size: GLint, `type`: GLenum, relativeoffset: GLuint): void {.cdecl.}](glGetProcAddress("glVertexAttribLFormat"))

proc load4_4() =
  cglBufferStorage = cast[proc (target: GLenum, size: GLsizeiptr, data: pointer, flags: GLbitfield): void {.cdecl.}](glGetProcAddress("glBufferStorage"))
  cglClearTexImage = cast[proc (texture: GLuint, level: GLint, format: GLenum, `type`: GLenum, data: pointer): void {.cdecl.}](glGetProcAddress("glClearTexImage"))
  cglClearTexSubImage = cast[proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, `type`: GLenum, data: pointer): void {.cdecl.}](glGetProcAddress("glClearTexSubImage"))
  cglBindBuffersBase = cast[proc (target: GLenum, first: GLuint, count: GLsizei, buffers: ptr GLuint): void {.cdecl.}](glGetProcAddress("glBindBuffersBase"))
  cglBindBuffersRange = cast[proc (target: GLenum, first: GLuint, count: GLsizei, buffers: ptr GLuint, offsets: ptr GLintptr, sizes: ptr GLsizeiptr): void {.cdecl.}](glGetProcAddress("glBindBuffersRange"))
  cglBindTextures = cast[proc (first: GLuint, count: GLsizei, textures: ptr GLuint): void {.cdecl.}](glGetProcAddress("glBindTextures"))
  cglBindSamplers = cast[proc (first: GLuint, count: GLsizei, samplers: ptr GLuint): void {.cdecl.}](glGetProcAddress("glBindSamplers"))
  cglBindImageTextures = cast[proc (first: GLuint, count: GLsizei, textures: ptr GLuint): void {.cdecl.}](glGetProcAddress("glBindImageTextures"))
  cglBindVertexBuffers = cast[proc (first: GLuint, count: GLsizei, buffers: ptr GLuint, offsets: ptr GLintptr, strides: ptr GLsizei): void {.cdecl.}](glGetProcAddress("glBindVertexBuffers"))

proc load4_5() =
  cglClipControl = cast[proc (origin: GLenum, depth: GLenum): void {.cdecl.}](glGetProcAddress("glClipControl"))
  cglCreateTransformFeedbacks = cast[proc (n: GLsizei, ids: ptr GLuint): void {.cdecl.}](glGetProcAddress("glCreateTransformFeedbacks"))
  cglTransformFeedbackBufferBase = cast[proc (xfb: GLuint, index: GLuint, buffer: GLuint): void {.cdecl.}](glGetProcAddress("glTransformFeedbackBufferBase"))
  cglTransformFeedbackBufferRange = cast[proc (xfb: GLuint, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr): void {.cdecl.}](glGetProcAddress("glTransformFeedbackBufferRange"))
  cglGetTransformFeedbackiv = cast[proc (xfb: GLuint, pname: GLenum, param: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetTransformFeedbackiv"))
  cglGetTransformFeedbacki64_v = cast[proc (xfb: GLuint, pname: GLenum, index: GLuint, param: ptr GLint64): void {.cdecl.}](glGetProcAddress("glGetTransformFeedbacki64_v"))
  cglCreateBuffers = cast[proc (n: GLsizei, buffers: ptr GLuint): void {.cdecl.}](glGetProcAddress("glCreateBuffers"))
  cglNamedBufferStorage = cast[proc (buffer: GLuint, size: GLsizeiptr, data: pointer, flags: GLbitfield): void {.cdecl.}](glGetProcAddress("glNamedBufferStorage"))
  cglNamedBufferData = cast[proc (buffer: GLuint, size: GLsizeiptr, data: pointer, usage: GLenum): void {.cdecl.}](glGetProcAddress("glNamedBufferData"))
  cglNamedBufferSubData = cast[proc (buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: pointer): void {.cdecl.}](glGetProcAddress("glNamedBufferSubData"))
  cglCopyNamedBufferSubData = cast[proc (readBuffer: GLuint, writeBuffer: GLuint, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr): void {.cdecl.}](glGetProcAddress("glCopyNamedBufferSubData"))
  cglClearNamedBufferData = cast[proc (buffer: GLuint, internalformat: GLenum, format: GLenum, `type`: GLenum, data: pointer): void {.cdecl.}](glGetProcAddress("glClearNamedBufferData"))
  cglClearNamedBufferSubData = cast[proc (buffer: GLuint, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, `type`: GLenum, data: pointer): void {.cdecl.}](glGetProcAddress("glClearNamedBufferSubData"))
  cglMapNamedBuffer = cast[proc (buffer: GLuint, access: GLenum): pointer {.cdecl.}](glGetProcAddress("glMapNamedBuffer"))
  cglMapNamedBufferRange = cast[proc (buffer: GLuint, offset: GLintptr, length: GLsizeiptr, access: GLbitfield): pointer {.cdecl.}](glGetProcAddress("glMapNamedBufferRange"))
  cglUnmapNamedBuffer = cast[proc (buffer: GLuint): GLboolean {.cdecl.}](glGetProcAddress("glUnmapNamedBuffer"))
  cglFlushMappedNamedBufferRange = cast[proc (buffer: GLuint, offset: GLintptr, length: GLsizeiptr): void {.cdecl.}](glGetProcAddress("glFlushMappedNamedBufferRange"))
  cglGetNamedBufferParameteriv = cast[proc (buffer: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetNamedBufferParameteriv"))
  cglGetNamedBufferParameteri64v = cast[proc (buffer: GLuint, pname: GLenum, params: ptr GLint64): void {.cdecl.}](glGetProcAddress("glGetNamedBufferParameteri64v"))
  cglGetNamedBufferPointerv = cast[proc (buffer: GLuint, pname: GLenum, params: ptr pointer): void {.cdecl.}](glGetProcAddress("glGetNamedBufferPointerv"))
  cglGetNamedBufferSubData = cast[proc (buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: pointer): void {.cdecl.}](glGetProcAddress("glGetNamedBufferSubData"))
  cglCreateFramebuffers = cast[proc (n: GLsizei, framebuffers: ptr GLuint): void {.cdecl.}](glGetProcAddress("glCreateFramebuffers"))
  cglNamedFramebufferRenderbuffer = cast[proc (framebuffer: GLuint, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint): void {.cdecl.}](glGetProcAddress("glNamedFramebufferRenderbuffer"))
  cglNamedFramebufferParameteri = cast[proc (framebuffer: GLuint, pname: GLenum, param: GLint): void {.cdecl.}](glGetProcAddress("glNamedFramebufferParameteri"))
  cglNamedFramebufferTexture = cast[proc (framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint): void {.cdecl.}](glGetProcAddress("glNamedFramebufferTexture"))
  cglNamedFramebufferTextureLayer = cast[proc (framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint): void {.cdecl.}](glGetProcAddress("glNamedFramebufferTextureLayer"))
  cglNamedFramebufferDrawBuffer = cast[proc (framebuffer: GLuint, buf: GLenum): void {.cdecl.}](glGetProcAddress("glNamedFramebufferDrawBuffer"))
  cglNamedFramebufferDrawBuffers = cast[proc (framebuffer: GLuint, n: GLsizei, bufs: ptr GLenum): void {.cdecl.}](glGetProcAddress("glNamedFramebufferDrawBuffers"))
  cglNamedFramebufferReadBuffer = cast[proc (framebuffer: GLuint, src: GLenum): void {.cdecl.}](glGetProcAddress("glNamedFramebufferReadBuffer"))
  cglInvalidateNamedFramebufferData = cast[proc (framebuffer: GLuint, numAttachments: GLsizei, attachments: ptr GLenum): void {.cdecl.}](glGetProcAddress("glInvalidateNamedFramebufferData"))
  cglInvalidateNamedFramebufferSubData = cast[proc (framebuffer: GLuint, numAttachments: GLsizei, attachments: ptr GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}](glGetProcAddress("glInvalidateNamedFramebufferSubData"))
  cglClearNamedFramebufferiv = cast[proc (framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: ptr GLint): void {.cdecl.}](glGetProcAddress("glClearNamedFramebufferiv"))
  cglClearNamedFramebufferuiv = cast[proc (framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: ptr GLuint): void {.cdecl.}](glGetProcAddress("glClearNamedFramebufferuiv"))
  cglClearNamedFramebufferfv = cast[proc (framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glClearNamedFramebufferfv"))
  cglClearNamedFramebufferfi = cast[proc (framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint): void {.cdecl.}](glGetProcAddress("glClearNamedFramebufferfi"))
  cglBlitNamedFramebuffer = cast[proc (readFramebuffer: GLuint, drawFramebuffer: GLuint, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum): void {.cdecl.}](glGetProcAddress("glBlitNamedFramebuffer"))
  cglCheckNamedFramebufferStatus = cast[proc (framebuffer: GLuint, target: GLenum): GLenum {.cdecl.}](glGetProcAddress("glCheckNamedFramebufferStatus"))
  cglGetNamedFramebufferParameteriv = cast[proc (framebuffer: GLuint, pname: GLenum, param: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetNamedFramebufferParameteriv"))
  cglGetNamedFramebufferAttachmentParameteriv = cast[proc (framebuffer: GLuint, attachment: GLenum, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetNamedFramebufferAttachmentParameteriv"))
  cglCreateRenderbuffers = cast[proc (n: GLsizei, renderbuffers: ptr GLuint): void {.cdecl.}](glGetProcAddress("glCreateRenderbuffers"))
  cglNamedRenderbufferStorage = cast[proc (renderbuffer: GLuint, internalformat: GLenum, width: GLsizei, height: GLsizei): void {.cdecl.}](glGetProcAddress("glNamedRenderbufferStorage"))
  cglNamedRenderbufferStorageMultisample = cast[proc (renderbuffer: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void {.cdecl.}](glGetProcAddress("glNamedRenderbufferStorageMultisample"))
  cglGetNamedRenderbufferParameteriv = cast[proc (renderbuffer: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetNamedRenderbufferParameteriv"))
  cglCreateTextures = cast[proc (target: GLenum, n: GLsizei, textures: ptr GLuint): void {.cdecl.}](glGetProcAddress("glCreateTextures"))
  cglTextureBuffer = cast[proc (texture: GLuint, internalformat: GLenum, buffer: GLuint): void {.cdecl.}](glGetProcAddress("glTextureBuffer"))
  cglTextureBufferRange = cast[proc (texture: GLuint, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr): void {.cdecl.}](glGetProcAddress("glTextureBufferRange"))
  cglTextureStorage1D = cast[proc (texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei): void {.cdecl.}](glGetProcAddress("glTextureStorage1D"))
  cglTextureStorage2D = cast[proc (texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void {.cdecl.}](glGetProcAddress("glTextureStorage2D"))
  cglTextureStorage3D = cast[proc (texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei): void {.cdecl.}](glGetProcAddress("glTextureStorage3D"))
  cglTextureStorage2DMultisample = cast[proc (texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean): void {.cdecl.}](glGetProcAddress("glTextureStorage2DMultisample"))
  cglTextureStorage3DMultisample = cast[proc (texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean): void {.cdecl.}](glGetProcAddress("glTextureStorage3DMultisample"))
  cglTextureSubImage1D = cast[proc (texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}](glGetProcAddress("glTextureSubImage1D"))
  cglTextureSubImage2D = cast[proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}](glGetProcAddress("glTextureSubImage2D"))
  cglTextureSubImage3D = cast[proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void {.cdecl.}](glGetProcAddress("glTextureSubImage3D"))
  cglCompressedTextureSubImage1D = cast[proc (texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void {.cdecl.}](glGetProcAddress("glCompressedTextureSubImage1D"))
  cglCompressedTextureSubImage2D = cast[proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void {.cdecl.}](glGetProcAddress("glCompressedTextureSubImage2D"))
  cglCompressedTextureSubImage3D = cast[proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void {.cdecl.}](glGetProcAddress("glCompressedTextureSubImage3D"))
  cglCopyTextureSubImage1D = cast[proc (texture: GLuint, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei): void {.cdecl.}](glGetProcAddress("glCopyTextureSubImage1D"))
  cglCopyTextureSubImage2D = cast[proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}](glGetProcAddress("glCopyTextureSubImage2D"))
  cglCopyTextureSubImage3D = cast[proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {.cdecl.}](glGetProcAddress("glCopyTextureSubImage3D"))
  cglTextureParameterf = cast[proc (texture: GLuint, pname: GLenum, param: GLfloat): void {.cdecl.}](glGetProcAddress("glTextureParameterf"))
  cglTextureParameterfv = cast[proc (texture: GLuint, pname: GLenum, param: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glTextureParameterfv"))
  cglTextureParameteri = cast[proc (texture: GLuint, pname: GLenum, param: GLint): void {.cdecl.}](glGetProcAddress("glTextureParameteri"))
  cglTextureParameterIiv = cast[proc (texture: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glTextureParameterIiv"))
  cglTextureParameterIuiv = cast[proc (texture: GLuint, pname: GLenum, params: ptr GLuint): void {.cdecl.}](glGetProcAddress("glTextureParameterIuiv"))
  cglTextureParameteriv = cast[proc (texture: GLuint, pname: GLenum, param: ptr GLint): void {.cdecl.}](glGetProcAddress("glTextureParameteriv"))
  cglGenerateTextureMipmap = cast[proc (texture: GLuint): void {.cdecl.}](glGetProcAddress("glGenerateTextureMipmap"))
  cglBindTextureUnit = cast[proc (unit: GLuint, texture: GLuint): void {.cdecl.}](glGetProcAddress("glBindTextureUnit"))
  cglGetTextureImage = cast[proc (texture: GLuint, level: GLint, format: GLenum, `type`: GLenum, bufSize: GLsizei, pixels: pointer): void {.cdecl.}](glGetProcAddress("glGetTextureImage"))
  cglGetCompressedTextureImage = cast[proc (texture: GLuint, level: GLint, bufSize: GLsizei, pixels: pointer): void {.cdecl.}](glGetProcAddress("glGetCompressedTextureImage"))
  cglGetTextureLevelParameterfv = cast[proc (texture: GLuint, level: GLint, pname: GLenum, params: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glGetTextureLevelParameterfv"))
  cglGetTextureLevelParameteriv = cast[proc (texture: GLuint, level: GLint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetTextureLevelParameteriv"))
  cglGetTextureParameterfv = cast[proc (texture: GLuint, pname: GLenum, params: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glGetTextureParameterfv"))
  cglGetTextureParameterIiv = cast[proc (texture: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetTextureParameterIiv"))
  cglGetTextureParameterIuiv = cast[proc (texture: GLuint, pname: GLenum, params: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGetTextureParameterIuiv"))
  cglGetTextureParameteriv = cast[proc (texture: GLuint, pname: GLenum, params: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetTextureParameteriv"))
  cglCreateVertexArrays = cast[proc (n: GLsizei, arrays: ptr GLuint): void {.cdecl.}](glGetProcAddress("glCreateVertexArrays"))
  cglDisableVertexArrayAttrib = cast[proc (vaobj: GLuint, index: GLuint): void {.cdecl.}](glGetProcAddress("glDisableVertexArrayAttrib"))
  cglEnableVertexArrayAttrib = cast[proc (vaobj: GLuint, index: GLuint): void {.cdecl.}](glGetProcAddress("glEnableVertexArrayAttrib"))
  cglVertexArrayElementBuffer = cast[proc (vaobj: GLuint, buffer: GLuint): void {.cdecl.}](glGetProcAddress("glVertexArrayElementBuffer"))
  cglVertexArrayVertexBuffer = cast[proc (vaobj: GLuint, bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei): void {.cdecl.}](glGetProcAddress("glVertexArrayVertexBuffer"))
  cglVertexArrayVertexBuffers = cast[proc (vaobj: GLuint, first: GLuint, count: GLsizei, buffers: ptr GLuint, offsets: ptr GLintptr, strides: ptr GLsizei): void {.cdecl.}](glGetProcAddress("glVertexArrayVertexBuffers"))
  cglVertexArrayAttribBinding = cast[proc (vaobj: GLuint, attribindex: GLuint, bindingindex: GLuint): void {.cdecl.}](glGetProcAddress("glVertexArrayAttribBinding"))
  cglVertexArrayAttribFormat = cast[proc (vaobj: GLuint, attribindex: GLuint, size: GLint, `type`: GLenum, normalized: GLboolean, relativeoffset: GLuint): void {.cdecl.}](glGetProcAddress("glVertexArrayAttribFormat"))
  cglVertexArrayAttribIFormat = cast[proc (vaobj: GLuint, attribindex: GLuint, size: GLint, `type`: GLenum, relativeoffset: GLuint): void {.cdecl.}](glGetProcAddress("glVertexArrayAttribIFormat"))
  cglVertexArrayAttribLFormat = cast[proc (vaobj: GLuint, attribindex: GLuint, size: GLint, `type`: GLenum, relativeoffset: GLuint): void {.cdecl.}](glGetProcAddress("glVertexArrayAttribLFormat"))
  cglVertexArrayBindingDivisor = cast[proc (vaobj: GLuint, bindingindex: GLuint, divisor: GLuint): void {.cdecl.}](glGetProcAddress("glVertexArrayBindingDivisor"))
  cglGetVertexArrayiv = cast[proc (vaobj: GLuint, pname: GLenum, param: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetVertexArrayiv"))
  cglGetVertexArrayIndexediv = cast[proc (vaobj: GLuint, index: GLuint, pname: GLenum, param: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetVertexArrayIndexediv"))
  cglGetVertexArrayIndexed64iv = cast[proc (vaobj: GLuint, index: GLuint, pname: GLenum, param: ptr GLint64): void {.cdecl.}](glGetProcAddress("glGetVertexArrayIndexed64iv"))
  cglCreateSamplers = cast[proc (n: GLsizei, samplers: ptr GLuint): void {.cdecl.}](glGetProcAddress("glCreateSamplers"))
  cglCreateProgramPipelines = cast[proc (n: GLsizei, pipelines: ptr GLuint): void {.cdecl.}](glGetProcAddress("glCreateProgramPipelines"))
  cglCreateQueries = cast[proc (target: GLenum, n: GLsizei, ids: ptr GLuint): void {.cdecl.}](glGetProcAddress("glCreateQueries"))
  cglGetQueryBufferObjecti64v = cast[proc (id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr): void {.cdecl.}](glGetProcAddress("glGetQueryBufferObjecti64v"))
  cglGetQueryBufferObjectiv = cast[proc (id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr): void {.cdecl.}](glGetProcAddress("glGetQueryBufferObjectiv"))
  cglGetQueryBufferObjectui64v = cast[proc (id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr): void {.cdecl.}](glGetProcAddress("glGetQueryBufferObjectui64v"))
  cglGetQueryBufferObjectuiv = cast[proc (id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr): void {.cdecl.}](glGetProcAddress("glGetQueryBufferObjectuiv"))
  cglGetTextureSubImage = cast[proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, `type`: GLenum, bufSize: GLsizei, pixels: pointer): void {.cdecl.}](glGetProcAddress("glGetTextureSubImage"))
  cglGetCompressedTextureSubImage = cast[proc (texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, bufSize: GLsizei, pixels: pointer): void {.cdecl.}](glGetProcAddress("glGetCompressedTextureSubImage"))
  cglGetnCompressedTexImage = cast[proc (target: GLenum, lod: GLint, bufSize: GLsizei, pixels: pointer): void {.cdecl.}](glGetProcAddress("glGetnCompressedTexImage"))
  cglGetnTexImage = cast[proc (target: GLenum, level: GLint, format: GLenum, `type`: GLenum, bufSize: GLsizei, pixels: pointer): void {.cdecl.}](glGetProcAddress("glGetnTexImage"))
  cglGetnUniformdv = cast[proc (program: GLuint, location: GLint, bufSize: GLsizei, params: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glGetnUniformdv"))
  cglGetnMapdv = cast[proc (target: GLenum, query: GLenum, bufSize: GLsizei, v: ptr GLdouble): void {.cdecl.}](glGetProcAddress("glGetnMapdv"))
  cglGetnMapfv = cast[proc (target: GLenum, query: GLenum, bufSize: GLsizei, v: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glGetnMapfv"))
  cglGetnMapiv = cast[proc (target: GLenum, query: GLenum, bufSize: GLsizei, v: ptr GLint): void {.cdecl.}](glGetProcAddress("glGetnMapiv"))
  cglGetnPixelMapfv = cast[proc (map: GLenum, bufSize: GLsizei, values: ptr GLfloat): void {.cdecl.}](glGetProcAddress("glGetnPixelMapfv"))
  cglGetnPixelMapuiv = cast[proc (map: GLenum, bufSize: GLsizei, values: ptr GLuint): void {.cdecl.}](glGetProcAddress("glGetnPixelMapuiv"))
  cglGetnPixelMapusv = cast[proc (map: GLenum, bufSize: GLsizei, values: ptr GLushort): void {.cdecl.}](glGetProcAddress("glGetnPixelMapusv"))
  cglGetnPolygonStipple = cast[proc (bufSize: GLsizei, pattern: ptr GLubyte): void {.cdecl.}](glGetProcAddress("glGetnPolygonStipple"))
  cglGetnColorTable = cast[proc (target: GLenum, format: GLenum, `type`: GLenum, bufSize: GLsizei, table: pointer): void {.cdecl.}](glGetProcAddress("glGetnColorTable"))
  cglGetnConvolutionFilter = cast[proc (target: GLenum, format: GLenum, `type`: GLenum, bufSize: GLsizei, image: pointer): void {.cdecl.}](glGetProcAddress("glGetnConvolutionFilter"))
  cglGetnSeparableFilter = cast[proc (target: GLenum, format: GLenum, `type`: GLenum, rowBufSize: GLsizei, row: pointer, columnBufSize: GLsizei, column: pointer, span: pointer): void {.cdecl.}](glGetProcAddress("glGetnSeparableFilter"))
  cglGetnHistogram = cast[proc (target: GLenum, reset: GLboolean, format: GLenum, `type`: GLenum, bufSize: GLsizei, values: pointer): void {.cdecl.}](glGetProcAddress("glGetnHistogram"))
  cglGetnMinmax = cast[proc (target: GLenum, reset: GLboolean, format: GLenum, `type`: GLenum, bufSize: GLsizei, values: pointer): void {.cdecl.}](glGetProcAddress("glGetnMinmax"))
  cglTextureBarrier = cast[proc (): void {.cdecl.}](glGetProcAddress("glTextureBarrier"))

proc load4_6() =
  cglSpecializeShader = cast[proc (shader: GLuint, pEntryPoint: cstring, numSpecializationConstants: GLuint, pConstantIndex: ptr GLuint, pConstantValue: ptr GLuint): void {.cdecl.}](glGetProcAddress("glSpecializeShader"))
  cglMultiDrawArraysIndirectCount = cast[proc (mode: GLenum, indirect: pointer, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei): void {.cdecl.}](glGetProcAddress("glMultiDrawArraysIndirectCount"))
  cglMultiDrawElementsIndirectCount = cast[proc (mode: GLenum, `type`: GLenum, indirect: pointer, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei): void {.cdecl.}](glGetProcAddress("glMultiDrawElementsIndirectCount"))
  cglPolygonOffsetClamp = cast[proc (factor: GLfloat, units: GLfloat, clamp: GLfloat): void {.cdecl.}](glGetProcAddress("glPolygonOffsetClamp"))

template glCallTemplate(cgl: any, name: string): untyped =
  when defined(opengl_debug):
    if glNimDebugPreProc != nil:
      glNimDebugPreProc(name)
  cgl
  when defined(opengl_debug):
    if glNimDebugPostProc != nil:
      glNimDebugPostProc(name)

template glTypedCallTemplate(cgl: any, name: string): untyped =
  when defined(opengl_debug):
    if glNimDebugPreProc != nil:
      glNimDebugPreProc(name)
  result = cgl
  when defined(opengl_debug):
    if glNimDebugPostProc != nil:
      glNimDebugPostProc(name)

# Wrapper to add documentation and future manual modifications
proc glActiveShaderProgram*(pipeline: GLuint, program: GLuint): void =
  ## Set the active program object for a program pipeline object
  ## Specifies the program pipeline object to set the active program object for.
  glCallTemplate(cglActiveShaderProgram(pipeline, program), "glActiveShaderProgram")
proc glActiveTexture*(texture: GLenum): void =
  ## Select active texture unit
  ## Specifies which texture unit to make active. The number
  ## of texture units is implementation dependent, but must be at least
  ## two. texturemust be one of
  ## GL_TEXTUREi,
  ## where
  ## i ranges from 0 to the larger of (GL_MAX_TEXTURE_COORDS- 1)
  ## and (GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS- 1).
  ## The initial value is GL_TEXTURE0.
  glCallTemplate(cglActiveTexture(texture), "glActiveTexture")
proc glVertexAttribIFormat*(attribindex: GLuint, size: GLint, `type`: GLenum, relativeoffset: GLuint): void =
  ## Specify the organization of vertex arrays
  ## Specifies the name of the vertex array object for
  glCallTemplate(cglVertexAttribIFormat(attribindex, size, `type`, relativeoffset), "glVertexAttribIFormat")
proc glAlphaFuncx*(`func`: GLenum, `ref`: GLfixed): void =
  ## Specify the alpha test function
  ## Specifies the alpha comparison function.
  ## Symbolic constants
  ## GL_NEVER,
  ## GL_LESS,
  ## GL_EQUAL,
  ## GL_LEQUAL,
  ## GL_GREATER,
  ## GL_NOTEQUAL,
  ## GL_GEQUAL, and
  ## GL_ALWAYSare accepted. The initial value is GL_ALWAYS.
  glCallTemplate(cglAlphaFuncx(`func`, `ref`), "glAlphaFuncx")
proc glAttachShader*(program: GLuint, shader: GLuint): void =
  ## Attaches a shader object to a program object
  ## Specifies the program object to which a shader
  glCallTemplate(cglAttachShader(program, shader), "glAttachShader")
proc glBeginConditionalRender*(id: GLuint, mode: GLenum): void =
  ## Start conditional rendering
  ## Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded.
  glCallTemplate(cglBeginConditionalRender(id, mode), "glBeginConditionalRender")
proc glBeginQuery*(target: GLenum, id: GLuint): void =
  ## Delimit the boundaries of a query object
  ## Specifies the target type of query object established between
  ## glBeginQueryand the subsequent glEndQuery.
  ## The symbolic constant must be GL_SAMPLES_PASSED.
  glCallTemplate(cglBeginQuery(target, id), "glBeginQuery")
proc glBeginQueryIndexed*(target: GLenum, index: GLuint, id: GLuint): void =
  ## Delimit the boundaries of a query object on an indexed target
  ## Specifies the target type of query object established between
  ## glBeginQueryIndexedand the subsequent  glEndQueryIndexed.
  ## The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED,
  ## GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or
  ## GL_TIME_ELAPSED.
  glCallTemplate(cglBeginQueryIndexed(target, index, id), "glBeginQueryIndexed")
proc glBeginTransformFeedback*(primitiveMode: GLenum): void =
  ## Start transform feedback operation
  ## Specify the output type of the primitives that will be recorded into the
  ## buffer objects that are bound for transform feedback.
  glCallTemplate(cglBeginTransformFeedback(primitiveMode), "glBeginTransformFeedback")
proc glBindAttribLocation*(program: GLuint, index: GLuint, name: cstring): void =
  ## Associates a generic vertex attribute index with a named attribute variable
  ## Specifies the handle of the program object in
  glCallTemplate(cglBindAttribLocation(program, index, name), "glBindAttribLocation")
proc glBindBuffer*(target: GLenum, buffer: GLuint): void =
  ## Bind a named buffer object
  ## Specifies the target to which the buffer object is bound.
  ## The symbolic constant must be
  ## GL_ARRAY_BUFFER,
  ## GL_ELEMENT_ARRAY_BUFFER,
  ## GL_PIXEL_PACK_BUFFER, or
  ## GL_PIXEL_UNPACK_BUFFER.
  glCallTemplate(cglBindBuffer(target, buffer), "glBindBuffer")
proc glBindBufferBase*(target: GLenum, index: GLuint, buffer: GLuint): void =
  ## Bind a buffer object to an indexed buffer target
  ## Specify the target of the bind operation. targetmust be
  ## one of GL_ATOMIC_COUNTER_BUFFER,
  ## GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFERor
  ## GL_SHADER_STORAGE_BUFFER.
  glCallTemplate(cglBindBufferBase(target, index, buffer), "glBindBufferBase")
proc glBindBufferRange*(target: GLenum, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr): void =
  ## Bind a range within a buffer object to an indexed buffer target
  ## Specify the target of the bind operation. targetmust be
  ## one of GL_ATOMIC_COUNTER_BUFFER,
  ## GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER,
  ## or GL_SHADER_STORAGE_BUFFER.
  glCallTemplate(cglBindBufferRange(target, index, buffer, offset, size), "glBindBufferRange")
proc glBindBuffersBase*(target: GLenum, first: GLuint, count: GLsizei, buffers: ptr GLuint): void =
  ## Bind one or more buffer objects to a sequence of indexed buffer targets
  ## Specify the target of the bind operation. targetmust be
  ## one of GL_ATOMIC_COUNTER_BUFFER,
  ## GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFERor
  ## GL_SHADER_STORAGE_BUFFER.
  glCallTemplate(cglBindBuffersBase(target, first, count, buffers), "glBindBuffersBase")
proc glBindBuffersRange*(target: GLenum, first: GLuint, count: GLsizei, buffers: ptr GLuint, offsets: ptr GLintptr, sizes: ptr GLsizeiptr): void =
  ## Bind ranges of one or more buffer objects to a sequence of indexed buffer targets
  ## Specify the target of the bind operation. targetmust be
  ## one of GL_ATOMIC_COUNTER_BUFFER,
  ## GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFERor
  ## GL_SHADER_STORAGE_BUFFER.
  glCallTemplate(cglBindBuffersRange(target, first, count, buffers, offsets, sizes), "glBindBuffersRange")
proc glBindFragDataLocation*(program: GLuint, color: GLuint, name: cstring): void =
  ## Bind a user-defined varying out variable to a fragment shader color number
  ## The name of the program containing varying out variable whose binding to modify
  glCallTemplate(cglBindFragDataLocation(program, color, name), "glBindFragDataLocation")
proc glBindFragDataLocationIndexed*(program: GLuint, colorNumber: GLuint, index: GLuint, name: cstring): void =
  ## Bind a user-defined varying out variable to a fragment shader color number and index
  ## The name of the program containing varying out variable whose binding to modify
  glCallTemplate(cglBindFragDataLocationIndexed(program, colorNumber, index, name), "glBindFragDataLocationIndexed")
proc glBindFramebuffer*(target: GLenum, framebuffer: GLuint): void =
  ## Bind a framebuffer to a framebuffer target
  ## Specifies the framebuffer target of the binding operation.
  glCallTemplate(cglBindFramebuffer(target, framebuffer), "glBindFramebuffer")
proc glBindImageTexture*(unit: GLuint, texture: GLuint, level: GLint, layered: GLboolean, layer: GLint, access: GLenum, format: GLenum): void =
  ## Bind a level of a texture to an image unit
  ## Specifies the index of the image unit to which to bind the texture
  glCallTemplate(cglBindImageTexture(unit, texture, level, layered, layer, access, format), "glBindImageTexture")
proc glBindImageTextures*(first: GLuint, count: GLsizei, textures: ptr GLuint): void =
  ## Bind one or more named texture images to a sequence of consecutive image units
  ## Specifies the first image unit to which a texture is to be bound.
  glCallTemplate(cglBindImageTextures(first, count, textures), "glBindImageTextures")
proc glBindProgramPipeline*(pipeline: GLuint): void =
  ## Bind a program pipeline to the current context
  ## Specifies the name of the pipeline object to bind to the context.
  glCallTemplate(cglBindProgramPipeline(pipeline), "glBindProgramPipeline")
proc glBindRenderbuffer*(target: GLenum, renderbuffer: GLuint): void =
  ## Bind a renderbuffer to a renderbuffer target
  ## Specifies the renderbuffer target of the binding operation. targetmust be GL_RENDERBUFFER.
  glCallTemplate(cglBindRenderbuffer(target, renderbuffer), "glBindRenderbuffer")
proc glBindSampler*(unit: GLuint, sampler: GLuint): void =
  ## Bind a named sampler to a texturing target
  ## Specifies the index of the texture unit to which the sampler is bound.
  glCallTemplate(cglBindSampler(unit, sampler), "glBindSampler")
proc glBindSamplers*(first: GLuint, count: GLsizei, samplers: ptr GLuint): void =
  ## Bind one or more named sampler objects to a sequence of consecutive sampler units
  ## Specifies the first sampler unit to which a sampler object is to be bound.
  glCallTemplate(cglBindSamplers(first, count, samplers), "glBindSamplers")
proc glBindTexture*(target: GLenum, texture: GLuint): void =
  ## Bind a named texture to a texturing target
  ## Specifies the target to which the texture is bound.
  ## Must be either
  ## GL_TEXTURE_1D,
  ## GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, or
  ## GL_TEXTURE_CUBE_MAP.
  glCallTemplate(cglBindTexture(target, texture), "glBindTexture")
proc glBindTextureUnit*(unit: GLuint, texture: GLuint): void =
  ## Bind an existing texture object to the specified texture unit
  ## Specifies the texture unit, to which the texture object should be bound to.
  glCallTemplate(cglBindTextureUnit(unit, texture), "glBindTextureUnit")
proc glBindTextures*(first: GLuint, count: GLsizei, textures: ptr GLuint): void =
  ## Bind one or more named textures to a sequence of consecutive texture units
  ## Specifies the first texture unit to which a texture is to be bound.
  glCallTemplate(cglBindTextures(first, count, textures), "glBindTextures")
proc glBindTransformFeedback*(target: GLenum, id: GLuint): void =
  ## Bind a transform feedback object
  ## Specifies the target to which to bind the transform feedback object id. targetmust be GL_TRANSFORM_FEEDBACK.
  glCallTemplate(cglBindTransformFeedback(target, id), "glBindTransformFeedback")
proc glBindVertexArray*(array: GLuint): void =
  ## Bind a vertex array object
  ## Specifies the name of the vertex array to bind.
  glCallTemplate(cglBindVertexArray(array), "glBindVertexArray")
proc glBindVertexBuffer*(bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei): void =
  ## Bind a buffer to a vertex buffer bind point
  ## Specifies the name of the vertex array object to be used by
  glCallTemplate(cglBindVertexBuffer(bindingindex, buffer, offset, stride), "glBindVertexBuffer")
proc glBindVertexBuffers*(first: GLuint, count: GLsizei, buffers: ptr GLuint, offsets: ptr GLintptr, strides: ptr GLsizei): void =
  ## Attach multiple buffer objects to a vertex array object
  ## Specifies the name of the vertex array object for
  ## glVertexArrayVertexBuffers.
  glCallTemplate(cglBindVertexBuffers(first, count, buffers, offsets, strides), "glBindVertexBuffers")
proc glBlendBarrier*(): void =
  ## Specifies a boundary between advanced blending passes
  ## glBlendBarrierspecifies a boundary between passes when using advanced blend equations.
  ## Any command that causes the value of a sample to be modified using the
  ## framebuffer is considered to touch the sample, including clears, blended
  ## or unblended primitives, and BlitFramebuffer copies. Defined results are guaranteed only if each sample
  ## is touched no more than once in any single rendering pass.
  glCallTemplate(cglBlendBarrier(), "glBlendBarrier")
proc glBlendColor*(red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat): void =
  ## Set the blend color
  glCallTemplate(cglBlendColor(red, green, blue, alpha), "glBlendColor")
proc glBlendEquation*(mode: GLenum): void =
  ## Specify the equation used for both the RGB blend equation and the Alpha blend equation
  ## specifies how source and destination colors are combined.
  ## It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT,
  ## GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
  glCallTemplate(cglBlendEquation(mode), "glBlendEquation")
proc glBlendEquationSeparate*(modeRGB: GLenum, modeAlpha: GLenum): void =
  ## Set the RGB blend equation and the alpha blend equation separately
  ## specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined.
  ## It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT,
  ## GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
  glCallTemplate(cglBlendEquationSeparate(modeRGB, modeAlpha), "glBlendEquationSeparate")
proc glBlendEquationSeparatei*(buf: GLuint, modeRGB: GLenum, modeAlpha: GLenum): void =
  ## Set the RGB blend equation and the alpha blend equation separately
  ## specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined.
  ## It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT,
  ## GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
  glCallTemplate(cglBlendEquationSeparatei(buf, modeRGB, modeAlpha), "glBlendEquationSeparatei")
proc glBlendEquationi*(buf: GLuint, mode: GLenum): void =
  ## Specify the equation used for both the RGB blend equation and the Alpha blend equation
  ## specifies how source and destination colors are combined.
  ## It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT,
  ## GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
  glCallTemplate(cglBlendEquationi(buf, mode), "glBlendEquationi")
proc glBlendFunc*(sfactor: GLenum, dfactor: GLenum): void =
  ## Specify pixel arithmetic
  ## Specifies how the red, green, blue,
  ## and alpha source blending factors are computed.
  ## The following symbolic constants are accepted:
  ## GL_ZERO,
  ## GL_ONE,
  ## GL_SRC_COLOR,
  ## GL_ONE_MINUS_SRC_COLOR,
  ## GL_DST_COLOR,
  ## GL_ONE_MINUS_DST_COLOR,
  ## GL_SRC_ALPHA,
  ## GL_ONE_MINUS_SRC_ALPHA,
  ## GL_DST_ALPHA,
  ## GL_ONE_MINUS_DST_ALPHA,
  ## GL_CONSTANT_COLOR,
  ## GL_ONE_MINUS_CONSTANT_COLOR,
  ## GL_CONSTANT_ALPHA,
  ## GL_ONE_MINUS_CONSTANT_ALPHA, and
  ## GL_SRC_ALPHA_SATURATE.
  ## The initial value is GL_ONE.
  glCallTemplate(cglBlendFunc(sfactor, dfactor), "glBlendFunc")
proc glBlendFuncSeparate*(sfactorRGB: GLenum, dfactorRGB: GLenum, sfactorAlpha: GLenum, dfactorAlpha: GLenum): void =
  ## Specify pixel arithmetic for RGB and alpha components separately
  ## Specifies how the red, green, and blue blending factors are computed.
  ## The following symbolic constants are accepted:
  ## GL_ZERO,
  ## GL_ONE,
  ## GL_SRC_COLOR,
  ## GL_ONE_MINUS_SRC_COLOR,
  ## GL_DST_COLOR,
  ## GL_ONE_MINUS_DST_COLOR,
  ## GL_SRC_ALPHA,
  ## GL_ONE_MINUS_SRC_ALPHA,
  ## GL_DST_ALPHA,
  ## GL_ONE_MINUS_DST_ALPHA,
  ## GL_CONSTANT_COLOR,
  ## GL_ONE_MINUS_CONSTANT_COLOR,
  ## GL_CONSTANT_ALPHA,
  ## GL_ONE_MINUS_CONSTANT_ALPHA, and
  ## GL_SRC_ALPHA_SATURATE.
  ## The initial value is GL_ONE.
  glCallTemplate(cglBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha), "glBlendFuncSeparate")
proc glBlendFuncSeparatei*(buf: GLuint, srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum): void =
  ## Specify pixel arithmetic for RGB and alpha components separately
  ## Specifies how the red, green, and blue blending factors are computed.
  ## The following symbolic constants are accepted:
  ## GL_ZERO,
  ## GL_ONE,
  ## GL_SRC_COLOR,
  ## GL_ONE_MINUS_SRC_COLOR,
  ## GL_DST_COLOR,
  ## GL_ONE_MINUS_DST_COLOR,
  ## GL_SRC_ALPHA,
  ## GL_ONE_MINUS_SRC_ALPHA,
  ## GL_DST_ALPHA,
  ## GL_ONE_MINUS_DST_ALPHA,
  ## GL_CONSTANT_COLOR,
  ## GL_ONE_MINUS_CONSTANT_COLOR,
  ## GL_CONSTANT_ALPHA,
  ## GL_ONE_MINUS_CONSTANT_ALPHA, and
  ## GL_SRC_ALPHA_SATURATE.
  ## The initial value is GL_ONE.
  glCallTemplate(cglBlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha), "glBlendFuncSeparatei")
proc glBlendFunci*(buf: GLuint, src: GLenum, dst: GLenum): void =
  ## Specify pixel arithmetic
  ## Specifies how the red, green, blue,
  ## and alpha source blending factors are computed.
  ## The following symbolic constants are accepted:
  ## GL_ZERO,
  ## GL_ONE,
  ## GL_SRC_COLOR,
  ## GL_ONE_MINUS_SRC_COLOR,
  ## GL_DST_COLOR,
  ## GL_ONE_MINUS_DST_COLOR,
  ## GL_SRC_ALPHA,
  ## GL_ONE_MINUS_SRC_ALPHA,
  ## GL_DST_ALPHA,
  ## GL_ONE_MINUS_DST_ALPHA,
  ## GL_CONSTANT_COLOR,
  ## GL_ONE_MINUS_CONSTANT_COLOR,
  ## GL_CONSTANT_ALPHA,
  ## GL_ONE_MINUS_CONSTANT_ALPHA, and
  ## GL_SRC_ALPHA_SATURATE.
  ## The initial value is GL_ONE.
  glCallTemplate(cglBlendFunci(buf, src, dst), "glBlendFunci")
proc glBlitFramebuffer*(srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum): void =
  ## Copy a block of pixels from one framebuffer object to another
  ## Specifies the name of the source framebuffer object
  ## for glBlitNamedFramebuffer.
  glCallTemplate(cglBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), "glBlitFramebuffer")
proc glBlitNamedFramebuffer*(readFramebuffer: GLuint, drawFramebuffer: GLuint, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum): void =
  ## Copy a block of pixels from one framebuffer object to another
  ## Specifies the name of the source framebuffer object
  ## for glBlitNamedFramebuffer.
  glCallTemplate(cglBlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), "glBlitNamedFramebuffer")
proc glBufferData*(target: GLenum, size: GLsizeiptr, data: pointer, usage: GLenum): void =
  ## Creates and initializes a buffer object's data store
  ## Specifies the target buffer object.
  ## The symbolic constant must be GL_ARRAY_BUFFER,
  ## GL_ELEMENT_ARRAY_BUFFER,
  ## GL_PIXEL_PACK_BUFFER, or
  ## GL_PIXEL_UNPACK_BUFFER.
  glCallTemplate(cglBufferData(target, size, data, usage), "glBufferData")
proc glBufferStorage*(target: GLenum, size: GLsizeiptr, data: pointer, flags: GLbitfield): void =
  ## Creates and initializes a buffer object's immutable data
  ## store
  ## Specifies the target to which the buffer object is bound for
  ## glBufferStorage, which must be one of the
  ## buffer binding targets in the following table:
  glCallTemplate(cglBufferStorage(target, size, data, flags), "glBufferStorage")
proc glBufferSubData*(target: GLenum, offset: GLintptr, size: GLsizeiptr, data: pointer): void =
  ## Updates a subset of a buffer object's data store
  ## Specifies the target buffer object.
  ## The symbolic constant must be GL_ARRAY_BUFFER,
  ## GL_ELEMENT_ARRAY_BUFFER,
  ## GL_PIXEL_PACK_BUFFER, or
  ## GL_PIXEL_UNPACK_BUFFER.
  glCallTemplate(cglBufferSubData(target, offset, size, data), "glBufferSubData")
proc glCheckFramebufferStatus*(target: GLenum): GLenum =
  ## Check the completeness status of a framebuffer
  ## Specify the target to which the framebuffer is bound for
  ## glCheckFramebufferStatus, and the
  ## target against which framebuffer completeness of
  ## framebufferis checked for
  ## glCheckNamedFramebufferStatus.
  glTypedCallTemplate(cglCheckFramebufferStatus(target), "glCheckFramebufferStatus")
proc glCheckNamedFramebufferStatus*(framebuffer: GLuint, target: GLenum): GLenum =
  ## Check the completeness status of a framebuffer
  ## Specify the target to which the framebuffer is bound for
  ## glCheckFramebufferStatus, and the
  ## target against which framebuffer completeness of
  ## framebufferis checked for
  ## glCheckNamedFramebufferStatus.
  glTypedCallTemplate(cglCheckNamedFramebufferStatus(framebuffer, target), "glCheckNamedFramebufferStatus")
proc glClampColor*(target: GLenum, clamp: GLenum): void =
  ## Specify whether data read via glReadPixelsshould be clamped
  ## Target for color clamping. targetmust be GL_CLAMP_READ_COLOR.
  glCallTemplate(cglClampColor(target, clamp), "glClampColor")
proc glClear*(mask: GLbitfield): void =
  ## Clear buffers to preset values
  ## Bitwise OR of masks that indicate the buffers to be cleared.
  ## The four masks are
  ## GL_COLOR_BUFFER_BIT,
  ## GL_DEPTH_BUFFER_BIT,
  ## GL_ACCUM_BUFFER_BIT, and
  ## GL_STENCIL_BUFFER_BIT.
  glCallTemplate(cglClear(mask), "glClear")
proc glClearBufferData*(target: GLenum, internalformat: GLenum, format: GLenum, `type`: GLenum, data: pointer): void =
  ## Fill a buffer object's data store with a fixed value
  ## Specifies the target to which the buffer object is bound
  ## for glClearBufferData, which must
  ## must be one of the buffer binding targets in the
  ## following table:
  glCallTemplate(cglClearBufferData(target, internalformat, format, `type`, data), "glClearBufferData")
proc glClearBufferSubData*(target: GLenum, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, `type`: GLenum, data: pointer): void =
  ## Fill all or part of buffer object's data store with a fixed value
  ## Specifies the target to which the buffer object is bound
  ## for glClearBufferSubData, which
  ## must be one of the buffer binding targets in the
  ## following table:
  glCallTemplate(cglClearBufferSubData(target, internalformat, offset, size, format, `type`, data), "glClearBufferSubData")
proc glClearBufferfi*(buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint): void =
  ## Clear individual buffers of a framebuffer
  ## Specifies the name of the framebuffer object for
  ## glClearNamedFramebuffer*.
  glCallTemplate(cglClearBufferfi(buffer, drawbuffer, depth, stencil), "glClearBufferfi")
proc glClearBufferfv*(buffer: GLenum, drawbuffer: GLint, value: ptr GLfloat): void =
  ## Clear individual buffers of a framebuffer
  ## Specifies the name of the framebuffer object for
  ## glClearNamedFramebuffer*.
  glCallTemplate(cglClearBufferfv(buffer, drawbuffer, value), "glClearBufferfv")
proc glClearBufferiv*(buffer: GLenum, drawbuffer: GLint, value: ptr GLint): void =
  ## Clear individual buffers of a framebuffer
  ## Specifies the name of the framebuffer object for
  ## glClearNamedFramebuffer*.
  glCallTemplate(cglClearBufferiv(buffer, drawbuffer, value), "glClearBufferiv")
proc glClearBufferuiv*(buffer: GLenum, drawbuffer: GLint, value: ptr GLuint): void =
  ## Clear individual buffers of a framebuffer
  ## Specifies the name of the framebuffer object for
  ## glClearNamedFramebuffer*.
  glCallTemplate(cglClearBufferuiv(buffer, drawbuffer, value), "glClearBufferuiv")
proc glClearColor*(red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat): void =
  ## Specify clear values for the color buffers
  ## Specify the red, green, blue, and alpha values used when the
  ## color buffers are cleared.
  ## The initial values are all 0.
  glCallTemplate(cglClearColor(red, green, blue, alpha), "glClearColor")
proc glClearColorx*(red: GLfixed, green: GLfixed, blue: GLfixed, alpha: GLfixed): void =
  ## Specify clear values for the color buffers
  ## Specify the red, green, blue, and alpha values used when the
  ## color buffers are cleared.
  ## The initial values are all 0.
  glCallTemplate(cglClearColorx(red, green, blue, alpha), "glClearColorx")
proc glClearDepth*(depth: GLdouble): void =
  ## Specify the clear value for the depth buffer
  ## Specifies the depth value used when the depth buffer is cleared. The
  ## initial value is 1.
  glCallTemplate(cglClearDepth(depth), "glClearDepth")
proc glClearDepthf*(d: GLfloat): void =
  ## Specify the clear value for the depth buffer
  ## Specifies the depth value used when the depth buffer is cleared. The
  ## initial value is 1.
  glCallTemplate(cglClearDepthf(d), "glClearDepthf")
proc glClearDepthx*(depth: GLfixed): void =
  ## Specify the clear value for the depth buffer
  ## Specifies the depth value used when the depth buffer is cleared. The
  ## initial value is 1.
  glCallTemplate(cglClearDepthx(depth), "glClearDepthx")
proc glClearNamedBufferData*(buffer: GLuint, internalformat: GLenum, format: GLenum, `type`: GLenum, data: pointer): void =
  ## Fill a buffer object's data store with a fixed value
  ## Specifies the target to which the buffer object is bound
  ## for glClearBufferData, which must
  ## must be one of the buffer binding targets in the
  ## following table:
  glCallTemplate(cglClearNamedBufferData(buffer, internalformat, format, `type`, data), "glClearNamedBufferData")
proc glClearNamedBufferSubData*(buffer: GLuint, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, `type`: GLenum, data: pointer): void =
  ## Fill all or part of buffer object's data store with a fixed value
  ## Specifies the target to which the buffer object is bound
  ## for glClearBufferSubData, which
  ## must be one of the buffer binding targets in the
  ## following table:
  glCallTemplate(cglClearNamedBufferSubData(buffer, internalformat, offset, size, format, `type`, data), "glClearNamedBufferSubData")
proc glClearNamedFramebufferfi*(framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint): void =
  ## Clear buffers to preset values
  ## Bitwise OR of masks that indicate the buffers to be cleared.
  ## The four masks are
  ## GL_COLOR_BUFFER_BIT,
  ## GL_DEPTH_BUFFER_BIT,
  ## GL_ACCUM_BUFFER_BIT, and
  ## GL_STENCIL_BUFFER_BIT.
  glCallTemplate(cglClearNamedFramebufferfi(framebuffer, buffer, drawbuffer, depth, stencil), "glClearNamedFramebufferfi")
proc glClearNamedFramebufferfv*(framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: ptr GLfloat): void =
  ## Clear buffers to preset values
  ## Bitwise OR of masks that indicate the buffers to be cleared.
  ## The four masks are
  ## GL_COLOR_BUFFER_BIT,
  ## GL_DEPTH_BUFFER_BIT,
  ## GL_ACCUM_BUFFER_BIT, and
  ## GL_STENCIL_BUFFER_BIT.
  glCallTemplate(cglClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value), "glClearNamedFramebufferfv")
proc glClearNamedFramebufferiv*(framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: ptr GLint): void =
  ## Clear buffers to preset values
  ## Bitwise OR of masks that indicate the buffers to be cleared.
  ## The four masks are
  ## GL_COLOR_BUFFER_BIT,
  ## GL_DEPTH_BUFFER_BIT,
  ## GL_ACCUM_BUFFER_BIT, and
  ## GL_STENCIL_BUFFER_BIT.
  glCallTemplate(cglClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value), "glClearNamedFramebufferiv")
proc glClearNamedFramebufferuiv*(framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: ptr GLuint): void =
  ## Clear buffers to preset values
  ## Bitwise OR of masks that indicate the buffers to be cleared.
  ## The four masks are
  ## GL_COLOR_BUFFER_BIT,
  ## GL_DEPTH_BUFFER_BIT,
  ## GL_ACCUM_BUFFER_BIT, and
  ## GL_STENCIL_BUFFER_BIT.
  glCallTemplate(cglClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value), "glClearNamedFramebufferuiv")
proc glClearStencil*(s: GLint): void =
  ## Specify the clear value for the stencil buffer
  ## Specifies the index used when the stencil buffer is cleared.
  ## The initial value is 0.
  glCallTemplate(cglClearStencil(s), "glClearStencil")
proc glClearTexImage*(texture: GLuint, level: GLint, format: GLenum, `type`: GLenum, data: pointer): void =
  ## Fills all a texture image with a constant value
  ## The name of an existing texture object containing the image to be cleared.
  glCallTemplate(cglClearTexImage(texture, level, format, `type`, data), "glClearTexImage")
proc glClearTexSubImage*(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, `type`: GLenum, data: pointer): void =
  ## Fills all or part of a texture image with a constant value
  ## The name of an existing texture object containing the image to be cleared.
  glCallTemplate(cglClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, `type`, data), "glClearTexSubImage")
proc glVertexAttrib4sv*(index: GLuint, v: ptr GLshort): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4sv(index, v), "glVertexAttrib4sv")
proc glClientWaitSync*(sync: GLsync, flags: GLbitfield, timeout: GLuint64): GLenum =
  ## Block and wait for a sync object to become signaled
  ## The sync object whose status to wait on.
  glTypedCallTemplate(cglClientWaitSync(sync, flags, timeout), "glClientWaitSync")
proc glClipControl*(origin: GLenum, depth: GLenum): void =
  ## Control clip coordinate to window coordinate behavior
  ## Specifies the clip control origin. Must be one of
  ## GL_LOWER_LEFTor
  ## GL_UPPER_LEFT.
  glCallTemplate(cglClipControl(origin, depth), "glClipControl")
proc glClipPlanef*(p: GLenum, eqn: ptr GLfloat): void =
  ## Specify a plane against which all geometry is clipped
  ## Specifies which clipping plane is being positioned.
  ## Symbolic names of the form GL_CLIP_PLANEi,
  ## where iis an integer between 0 and GL_MAX_CLIP_PLANES
  ## -1,
  ## are accepted.
  glCallTemplate(cglClipPlanef(p, eqn), "glClipPlanef")
proc glClipPlanex*(plane: GLenum, equation: ptr GLfixed): void =
  ## Specify a plane against which all geometry is clipped
  ## Specifies which clipping plane is being positioned.
  ## Symbolic names of the form GL_CLIP_PLANEi,
  ## where iis an integer between 0 and GL_MAX_CLIP_PLANES
  ## -1,
  ## are accepted.
  glCallTemplate(cglClipPlanex(plane, equation), "glClipPlanex")
proc glVertexAttrib2dv*(index: GLuint, v: ptr GLdouble): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib2dv(index, v), "glVertexAttrib2dv")
proc glVertexAttrib2f*(index: GLuint, x: GLfloat, y: GLfloat): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib2f(index, x, y), "glVertexAttrib2f")
proc glColor4x*(red: GLfixed, green: GLfixed, blue: GLfixed, alpha: GLfixed): void =
  ## Set the current color
  ## Specify new red, green, and blue values for the current color.
  glCallTemplate(cglColor4x(red, green, blue, alpha), "glColor4x")
proc glColorMask*(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean): void =
  ## Enable and disable writing of frame buffer color components
  ## Specify whether red, green, blue, and alpha can or cannot be written
  ## into the frame buffer.
  ## The initial values are all GL_TRUE,
  ## indicating that the color components can be written.
  glCallTemplate(cglColorMask(red, green, blue, alpha), "glColorMask")
proc glColorMaski*(index: GLuint, r: GLboolean, g: GLboolean, b: GLboolean, a: GLboolean): void =
  ## Enable and disable writing of frame buffer color components
  ## Specify whether red, green, blue, and alpha can or cannot be written
  ## into the frame buffer.
  ## The initial values are all GL_TRUE,
  ## indicating that the color components can be written.
  glCallTemplate(cglColorMaski(index, r, g, b, a), "glColorMaski")
proc glColorP3ui*(`type`: GLenum, color: GLuint): void =
  ## Set the current color
  ## Specify new red, green, and blue values for the current color.
  glCallTemplate(cglColorP3ui(`type`, color), "glColorP3ui")
proc glColorP3uiv*(`type`: GLenum, color: ptr GLuint): void =
  ## Set the current color
  ## Specify new red, green, and blue values for the current color.
  glCallTemplate(cglColorP3uiv(`type`, color), "glColorP3uiv")
proc glColorP4ui*(`type`: GLenum, color: GLuint): void =
  ## Set the current color
  ## Specify new red, green, and blue values for the current color.
  glCallTemplate(cglColorP4ui(`type`, color), "glColorP4ui")
proc glColorP4uiv*(`type`: GLenum, color: ptr GLuint): void =
  ## Set the current color
  ## Specify new red, green, and blue values for the current color.
  glCallTemplate(cglColorP4uiv(`type`, color), "glColorP4uiv")
proc glCompileShader*(shader: GLuint): void =
  ## Compiles a shader object
  ## Specifies the shader object to be
  glCallTemplate(cglCompileShader(shader), "glCompileShader")
proc glCompressedTexImage1D*(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, border: GLint, imageSize: GLsizei, data: pointer): void =
  ## Specify a one-dimensional texture image in a compressed format
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_1Dor GL_PROXY_TEXTURE_1D.
  glCallTemplate(cglCompressedTexImage1D(target, level, internalformat, width, border, imageSize, data), "glCompressedTexImage1D")
proc glCompressedTexImage2D*(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, imageSize: GLsizei, data: pointer): void =
  ## Specify a two-dimensional texture image in a compressed format
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or
  ## GL_PROXY_TEXTURE_CUBE_MAP.
  glCallTemplate(cglCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data), "glCompressedTexImage2D")
proc glCompressedTexImage3D*(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, data: pointer): void =
  ## Specify a three-dimensional texture image in a compressed format
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_3Dor GL_PROXY_TEXTURE_3D.
  glCallTemplate(cglCompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data), "glCompressedTexImage3D")
proc glCompressedTexSubImage1D*(target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void =
  ## Specify a one-dimensional texture subimage in a compressed format
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_1D.
  glCallTemplate(cglCompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data), "glCompressedTexSubImage1D")
proc glCompressedTexSubImage2D*(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void =
  ## Specify a two-dimensional texture subimage in a compressed format
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_2D,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
  glCallTemplate(cglCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data), "glCompressedTexSubImage2D")
proc glCompressedTexSubImage3D*(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void =
  ## Specify a three-dimensional texture subimage in a compressed format
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_3D.
  glCallTemplate(cglCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data), "glCompressedTexSubImage3D")
proc glCompressedTextureSubImage1D*(texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void =
  ## Specify a one-dimensional texture subimage in a compressed format
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_1D.
  glCallTemplate(cglCompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data), "glCompressedTextureSubImage1D")
proc glCompressedTextureSubImage2D*(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void =
  ## Specify a two-dimensional texture subimage in a compressed format
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_2D,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
  glCallTemplate(cglCompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data), "glCompressedTextureSubImage2D")
proc glCompressedTextureSubImage3D*(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer): void =
  ## Specify a three-dimensional texture subimage in a compressed format
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_3D.
  glCallTemplate(cglCompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data), "glCompressedTextureSubImage3D")
proc glCopyBufferSubData*(readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr): void =
  ## Copy all or part of the data store of a buffer object to the data store of another buffer object
  ## Specifies the target to which the source buffer object
  glCallTemplate(cglCopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size), "glCopyBufferSubData")
proc glCopyImageSubData*(srcName: GLuint, srcTarget: GLenum, srcLevel: GLint, srcX: GLint, srcY: GLint, srcZ: GLint, dstName: GLuint, dstTarget: GLenum, dstLevel: GLint, dstX: GLint, dstY: GLint, dstZ: GLint, srcWidth: GLsizei, srcHeight: GLsizei, srcDepth: GLsizei): void =
  ## Perform a raw data copy between two images
  ## The name of a texture or renderbuffer object from which to copy.
  glCallTemplate(cglCopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth), "glCopyImageSubData")
proc glCopyNamedBufferSubData*(readBuffer: GLuint, writeBuffer: GLuint, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr): void =
  ## Copy all or part of the data store of a buffer object to the data store of another buffer object
  ## Specifies the target to which the source buffer object
  glCallTemplate(cglCopyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size), "glCopyNamedBufferSubData")
proc glCopyTexImage1D*(target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, border: GLint): void =
  ## Copy pixels into a 1D texture image
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_1D.
  glCallTemplate(cglCopyTexImage1D(target, level, internalformat, x, y, width, border), "glCopyTexImage1D")
proc glCopyTexImage2D*(target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint): void =
  ## Copy pixels into a 2D texture image
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_2D,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
  glCallTemplate(cglCopyTexImage2D(target, level, internalformat, x, y, width, height, border), "glCopyTexImage2D")
proc glCopyTexSubImage1D*(target: GLenum, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei): void =
  ## Copy a one-dimensional texture subimage
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_1D.
  glCallTemplate(cglCopyTexSubImage1D(target, level, xoffset, x, y, width), "glCopyTexSubImage1D")
proc glCopyTexSubImage2D*(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void =
  ## Copy a two-dimensional texture subimage
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_2D,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
  glCallTemplate(cglCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height), "glCopyTexSubImage2D")
proc glCopyTexSubImage3D*(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void =
  ## Copy a three-dimensional texture subimage
  ## Specifies the target texture.
  glCallTemplate(cglCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height), "glCopyTexSubImage3D")
proc glCopyTextureSubImage1D*(texture: GLuint, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei): void =
  ## Copy a one-dimensional texture subimage
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_1D.
  glCallTemplate(cglCopyTextureSubImage1D(texture, level, xoffset, x, y, width), "glCopyTextureSubImage1D")
proc glCopyTextureSubImage2D*(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void =
  ## Copy a two-dimensional texture subimage
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_2D,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
  glCallTemplate(cglCopyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, width, height), "glCopyTextureSubImage2D")
proc glCopyTextureSubImage3D*(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void =
  ## Copy a three-dimensional texture subimage
  ## Specifies the target texture.
  glCallTemplate(cglCopyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y, width, height), "glCopyTextureSubImage3D")
proc glCreateBuffers*(n: GLsizei, buffers: ptr GLuint): void =
  ## Create buffer objects
  ## Specifies the number of buffer objects to create.
  glCallTemplate(cglCreateBuffers(n, buffers), "glCreateBuffers")
proc glCreateFramebuffers*(n: GLsizei, framebuffers: ptr GLuint): void =
  ## Create framebuffer objects
  ## Number of framebuffer objects to create.
  glCallTemplate(cglCreateFramebuffers(n, framebuffers), "glCreateFramebuffers")
proc glCreateProgram*(): GLuint =
  ## Creates a program object
  ## glCreateProgramcreates an empty
  ## program object and returns a non-zero value by which it can be
  ## referenced. A program object is an object to which shader
  ## objects can be attached. This provides a mechanism to specify
  ## the shader objects that will be linked to create a program. It
  ## also provides a means for checking the compatibility of the
  ## shaders that will be used to create a program (for instance,
  ## checking the compatibility between a vertex shader and a
  ## fragment shader). When no longer needed as part of a program
  glTypedCallTemplate(cglCreateProgram(), "glCreateProgram")
proc glCreateProgramPipelines*(n: GLsizei, pipelines: ptr GLuint): void =
  ## Create program pipeline objects
  ## Number of program pipeline objects to create.
  glCallTemplate(cglCreateProgramPipelines(n, pipelines), "glCreateProgramPipelines")
proc glCreateQueries*(target: GLenum, n: GLsizei, ids: ptr GLuint): void =
  ## Create query objects
  ## Specifies the target of each created query object.
  glCallTemplate(cglCreateQueries(target, n, ids), "glCreateQueries")
proc glCreateRenderbuffers*(n: GLsizei, renderbuffers: ptr GLuint): void =
  ## Create renderbuffer objects
  ## Number of renderbuffer objects to create.
  glCallTemplate(cglCreateRenderbuffers(n, renderbuffers), "glCreateRenderbuffers")
proc glCreateSamplers*(n: GLsizei, samplers: ptr GLuint): void =
  ## Create sampler objects
  ## Number of sampler objects to create.
  glCallTemplate(cglCreateSamplers(n, samplers), "glCreateSamplers")
proc glCreateShader*(`type`: GLenum): GLuint =
  ## Creates a shader object
  ## Specifies the type of shader to be created.
  glTypedCallTemplate(cglCreateShader(`type`), "glCreateShader")
proc glCreateShaderProgramv*(`type`: GLenum, count: GLsizei, strings: ptr cstring): GLuint =
  ## Create a stand-alone program from an array of null-terminated source code strings
  ## Specifies the type of shader to create.
  glTypedCallTemplate(cglCreateShaderProgramv(`type`, count, strings), "glCreateShaderProgramv")
proc glCreateTextures*(target: GLenum, n: GLsizei, textures: ptr GLuint): void =
  ## Create texture objects
  ## Specifies the effective texture target
  ## of each created texture.
  glCallTemplate(cglCreateTextures(target, n, textures), "glCreateTextures")
proc glCreateTransformFeedbacks*(n: GLsizei, ids: ptr GLuint): void =
  ## Create transform feedback objects
  ## Number of transform feedback objects to create.
  glCallTemplate(cglCreateTransformFeedbacks(n, ids), "glCreateTransformFeedbacks")
proc glCreateVertexArrays*(n: GLsizei, arrays: ptr GLuint): void =
  ## Create vertex array objects
  ## Number of vertex array objects to create.
  glCallTemplate(cglCreateVertexArrays(n, arrays), "glCreateVertexArrays")
proc glCullFace*(mode: GLenum): void =
  ## Specify whether front- or back-facing facets can be culled
  ## Specifies whether front- or back-facing facets are candidates for culling.
  ## Symbolic constants
  ## GL_FRONT, GL_BACK, and GL_FRONT_AND_BACKare accepted.
  ## The initial value is GL_BACK.
  glCallTemplate(cglCullFace(mode), "glCullFace")
proc glDebugMessageCallback*(callback: GLDEBUGPROC, userParam: pointer): void =
  ## Specify a callback to receive debugging messages from the GL
  ## The address of a callback function that will be called when a debug message is generated.
  glCallTemplate(cglDebugMessageCallback(callback, userParam), "glDebugMessageCallback")
proc glDebugMessageControl*(source: GLenum, `type`: GLenum, severity: GLenum, count: GLsizei, ids: ptr GLuint, enabled: GLboolean): void =
  ## Control the reporting of debug messages in a debug context
  ## The source of debug messages to enable or disable.
  glCallTemplate(cglDebugMessageControl(source, `type`, severity, count, ids, enabled), "glDebugMessageControl")
proc glDebugMessageInsert*(source: GLenum, `type`: GLenum, id: GLuint, severity: GLenum, length: GLsizei, buf: cstring): void =
  ## Inject an application-supplied message into the debug message queue
  ## The source of the debug message to insert.
  glCallTemplate(cglDebugMessageInsert(source, `type`, id, severity, length, buf), "glDebugMessageInsert")
proc glDeleteBuffers*(n: GLsizei, buffers: ptr GLuint): void =
  ## Delete named buffer objects
  ## Specifies the number of buffer objects to be deleted.
  glCallTemplate(cglDeleteBuffers(n, buffers), "glDeleteBuffers")
proc glDeleteFramebuffers*(n: GLsizei, framebuffers: ptr GLuint): void =
  ## Delete framebuffer objects
  ## Specifies the number of framebuffer objects to be deleted.
  glCallTemplate(cglDeleteFramebuffers(n, framebuffers), "glDeleteFramebuffers")
proc glDeleteProgram*(program: GLuint): void =
  ## Deletes a program object
  ## Specifies the program object to be
  glCallTemplate(cglDeleteProgram(program), "glDeleteProgram")
proc glDeleteProgramPipelines*(n: GLsizei, pipelines: ptr GLuint): void =
  ## Delete program pipeline objects
  ## Specifies the number of program pipeline objects to delete.
  glCallTemplate(cglDeleteProgramPipelines(n, pipelines), "glDeleteProgramPipelines")
proc glDeleteQueries*(n: GLsizei, ids: ptr GLuint): void =
  ## Delete named query objects
  ## Specifies the number of query objects to be deleted.
  glCallTemplate(cglDeleteQueries(n, ids), "glDeleteQueries")
proc glDeleteRenderbuffers*(n: GLsizei, renderbuffers: ptr GLuint): void =
  ## Delete renderbuffer objects
  ## Specifies the number of renderbuffer objects to be deleted.
  glCallTemplate(cglDeleteRenderbuffers(n, renderbuffers), "glDeleteRenderbuffers")
proc glDeleteSamplers*(count: GLsizei, samplers: ptr GLuint): void =
  ## Delete named sampler objects
  ## Specifies the number of sampler objects to be deleted.
  glCallTemplate(cglDeleteSamplers(count, samplers), "glDeleteSamplers")
proc glDeleteShader*(shader: GLuint): void =
  ## Deletes a shader object
  glCallTemplate(cglDeleteShader(shader), "glDeleteShader")
proc glDeleteSync*(sync: GLsync): void =
  ## Delete a sync object
  ## The sync object to be deleted.
  glCallTemplate(cglDeleteSync(sync), "glDeleteSync")
proc glDeleteTextures*(n: GLsizei, textures: ptr GLuint): void =
  ## Delete named textures
  ## Specifies the number of textures to be deleted.
  glCallTemplate(cglDeleteTextures(n, textures), "glDeleteTextures")
proc glDeleteTransformFeedbacks*(n: GLsizei, ids: ptr GLuint): void =
  ## Delete transform feedback objects
  ## Specifies the number of transform feedback objects to delete.
  glCallTemplate(cglDeleteTransformFeedbacks(n, ids), "glDeleteTransformFeedbacks")
proc glDeleteVertexArrays*(n: GLsizei, arrays: ptr GLuint): void =
  ## Delete vertex array objects
  ## Specifies the number of vertex array objects to be deleted.
  glCallTemplate(cglDeleteVertexArrays(n, arrays), "glDeleteVertexArrays")
proc glDepthFunc*(`func`: GLenum): void =
  ## Specify the value used for depth buffer comparisons
  ## Specifies the depth comparison function.
  ## Symbolic constants
  ## GL_NEVER,
  ## GL_LESS,
  ## GL_EQUAL,
  ## GL_LEQUAL,
  ## GL_GREATER,
  ## GL_NOTEQUAL,
  ## GL_GEQUAL, and
  ## GL_ALWAYSare accepted.
  ## The initial value is GL_LESS.
  glCallTemplate(cglDepthFunc(`func`), "glDepthFunc")
proc glDepthMask*(flag: GLboolean): void =
  ## Enable or disable writing into the depth buffer
  ## Specifies whether the depth buffer is enabled for writing.
  ## If flagis GL_FALSE,
  ## depth buffer writing is disabled.
  ## Otherwise, it is enabled.
  ## Initially, depth buffer writing is enabled.
  glCallTemplate(cglDepthMask(flag), "glDepthMask")
proc glDepthRange*(n: GLdouble, f: GLdouble): void =
  ## Specify mapping of depth values from normalized device coordinates to window coordinates
  ## Specifies the mapping of the near clipping plane to window coordinates.
  ## The initial value is 0.
  glCallTemplate(cglDepthRange(n, f), "glDepthRange")
proc glDepthRangeArrayv*(first: GLuint, count: GLsizei, v: ptr GLdouble): void =
  ## Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
  ## Specifies the index of the first viewport whose depth range to update.
  glCallTemplate(cglDepthRangeArrayv(first, count, v), "glDepthRangeArrayv")
proc glDepthRangeIndexed*(index: GLuint, n: GLdouble, f: GLdouble): void =
  ## Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport
  ## Specifies the index of the viewport whose depth range to update.
  glCallTemplate(cglDepthRangeIndexed(index, n, f), "glDepthRangeIndexed")
proc glDepthRangef*(n: GLfloat, f: GLfloat): void =
  ## Specify mapping of depth values from normalized device coordinates to window coordinates
  ## Specifies the mapping of the near clipping plane to window coordinates.
  ## The initial value is 0.
  glCallTemplate(cglDepthRangef(n, f), "glDepthRangef")
proc glDepthRangex*(n: GLfixed, f: GLfixed): void =
  ## Specify mapping of depth values from normalized device coordinates to window coordinates
  ## Specifies the mapping of the near clipping plane to window coordinates.
  ## The initial value is 0.
  glCallTemplate(cglDepthRangex(n, f), "glDepthRangex")
proc glDetachShader*(program: GLuint, shader: GLuint): void =
  ## Detaches a shader object from a program object to which it is attached
  ## Specifies the program object from which to
  glCallTemplate(cglDetachShader(program, shader), "glDetachShader")
proc glDisable*(cap: GLenum): void =
  ## Enable or disable server-side GL capabilities
  ## Specifies a symbolic constant indicating a GL capability.
  glCallTemplate(cglDisable(cap), "glDisable")
proc glDisableVertexArrayAttrib*(vaobj: GLuint, index: GLuint): void =
  ## Enable or disable a generic vertex attribute array
  ## Specifies the index of the generic vertex
  glCallTemplate(cglDisableVertexArrayAttrib(vaobj, index), "glDisableVertexArrayAttrib")
proc glDisableVertexAttribArray*(index: GLuint): void =
  ## Enable or disable a generic vertex attribute array
  ## Specifies the index of the generic vertex
  glCallTemplate(cglDisableVertexAttribArray(index), "glDisableVertexAttribArray")
proc glDisablei*(target: GLenum, index: GLuint): void =
  ## Enable or disable server-side GL capabilities
  ## Specifies a symbolic constant indicating a GL capability.
  glCallTemplate(cglDisablei(target, index), "glDisablei")
proc glDispatchCompute*(num_groups_x: GLuint, num_groups_y: GLuint, num_groups_z: GLuint): void =
  ## Launch one or more compute work groups
  ## The number of work groups to be launched in the X dimension.
  glCallTemplate(cglDispatchCompute(num_groups_x, num_groups_y, num_groups_z), "glDispatchCompute")
proc glDispatchComputeIndirect*(indirect: GLintptr): void =
  ## Launch one or more compute work groups using parameters stored in a buffer
  ## The offset into the buffer object currently bound to the
  ## GL_DISPATCH_INDIRECT_BUFFERbuffer target at
  ## which the dispatch parameters are stored.
  glCallTemplate(cglDispatchComputeIndirect(indirect), "glDispatchComputeIndirect")
proc glDrawArrays*(mode: GLenum, first: GLint, count: GLsizei): void =
  ## Render primitives from array data
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_QUAD_STRIP,
  ## GL_QUADS,
  ## and GL_POLYGONare accepted.
  glCallTemplate(cglDrawArrays(mode, first, count), "glDrawArrays")
proc glDrawArraysIndirect*(mode: GLenum, indirect: pointer): void =
  ## Render primitives from array data, taking parameters from memory
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_LINE_STRIP_ADJACENCY,
  ## GL_LINES_ADJACENCY,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_TRIANGLE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCY, and
  ## GL_PATCHESare accepted.
  glCallTemplate(cglDrawArraysIndirect(mode, indirect), "glDrawArraysIndirect")
proc glDrawArraysInstanced*(mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei): void =
  ## Draw multiple instances of a range of elements
  ## Specifies what kind of primitives to render. Symbolic constants GL_POINTS,
  ## GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
  ## GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLESGL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCYand GL_PATCHESare accepted.
  glCallTemplate(cglDrawArraysInstanced(mode, first, count, instancecount), "glDrawArraysInstanced")
proc glDrawArraysInstancedBaseInstance*(mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei, baseinstance: GLuint): void =
  ## Draw multiple instances of a range of elements with offset applied to instanced attributes
  ## Specifies what kind of primitives to render. Symbolic constants GL_POINTS,
  ## GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
  ## GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLESGL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCYand GL_PATCHESare accepted.
  glCallTemplate(cglDrawArraysInstancedBaseInstance(mode, first, count, instancecount, baseinstance), "glDrawArraysInstancedBaseInstance")
proc glDrawBuffer*(buf: GLenum): void =
  ## Specify which color buffers are to be drawn into
  ## Specifies up to four color buffers to be drawn into.
  ## Symbolic constants
  ## GL_NONE,
  ## GL_FRONT_LEFT,
  ## GL_FRONT_RIGHT,
  ## GL_BACK_LEFT,
  ## GL_BACK_RIGHT,
  ## GL_FRONT,
  ## GL_BACK,
  ## GL_LEFT,
  ## GL_RIGHT,
  ## GL_FRONT_AND_BACK, and
  ## GL_AUXi,
  ## where iis between 0 and the value of GL_AUX_BUFFERSminus 1,
  ## are accepted.  (GL_AUX_BUFFERSis not the upper limit; use glGetto query the number of available aux buffers.)
  ## The initial value is GL_FRONTfor single-buffered contexts,
  ## and GL_BACKfor double-buffered contexts.
  glCallTemplate(cglDrawBuffer(buf), "glDrawBuffer")
proc glDrawBuffers*(n: GLsizei, bufs: ptr GLenum): void =
  ## Specifies a list of color buffers to be drawn into
  ## Specifies the number of buffers in
  glCallTemplate(cglDrawBuffers(n, bufs), "glDrawBuffers")
proc glDrawElements*(mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer): void =
  ## Render primitives from array data
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_QUAD_STRIP,
  ## GL_QUADS,
  ## and GL_POLYGONare accepted.
  glCallTemplate(cglDrawElements(mode, count, `type`, indices), "glDrawElements")
proc glDrawElementsBaseVertex*(mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer, basevertex: GLint): void =
  ## Render primitives from array data with a per-element offset
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP,
  ## GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN,
  ## GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCYand GL_PATCHESare accepted.
  glCallTemplate(cglDrawElementsBaseVertex(mode, count, `type`, indices, basevertex), "glDrawElementsBaseVertex")
proc glDrawElementsIndirect*(mode: GLenum, `type`: GLenum, indirect: pointer): void =
  ## Render indexed primitives from array data, taking parameters from memory
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_LINE_STRIP_ADJACENCY,
  ## GL_LINES_ADJACENCY,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_TRIANGLE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCY, and
  ## GL_PATCHESare accepted.
  glCallTemplate(cglDrawElementsIndirect(mode, `type`, indirect), "glDrawElementsIndirect")
proc glDrawElementsInstanced*(mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer, instancecount: GLsizei): void =
  ## Draw multiple instances of a set of elements
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_LINE_STRIP_ADJACENCY,
  ## GL_LINES_ADJACENCY,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_TRIANGLE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCYand GL_PATCHESare accepted.
  glCallTemplate(cglDrawElementsInstanced(mode, count, `type`, indices, instancecount), "glDrawElementsInstanced")
proc glDrawElementsInstancedBaseInstance*(mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer, instancecount: GLsizei, baseinstance: GLuint): void =
  ## Draw multiple instances of a set of elements with offset applied to instanced attributes
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_LINE_STRIP_ADJACENCY,
  ## GL_LINES_ADJACENCY,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_TRIANGLE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCYand GL_PATCHESare accepted.
  glCallTemplate(cglDrawElementsInstancedBaseInstance(mode, count, `type`, indices, instancecount, baseinstance), "glDrawElementsInstancedBaseInstance")
proc glDrawElementsInstancedBaseVertex*(mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer, instancecount: GLsizei, basevertex: GLint): void =
  ## Render multiple instances of a set of primitives from array data with a per-element offset
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP,
  ## GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN,
  ## GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCYand GL_PATCHESare accepted.
  glCallTemplate(cglDrawElementsInstancedBaseVertex(mode, count, `type`, indices, instancecount, basevertex), "glDrawElementsInstancedBaseVertex")
proc glDrawElementsInstancedBaseVertexBaseInstance*(mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer, instancecount: GLsizei, basevertex: GLint, baseinstance: GLuint): void =
  ## Render multiple instances of a set of primitives from array data with a per-element offset
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP,
  ## GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN,
  ## GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCYand GL_PATCHESare accepted.
  glCallTemplate(cglDrawElementsInstancedBaseVertexBaseInstance(mode, count, `type`, indices, instancecount, basevertex, baseinstance), "glDrawElementsInstancedBaseVertexBaseInstance")
proc glVertexAttribI4ubv*(index: GLuint, v: ptr GLubyte): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI4ubv(index, v), "glVertexAttribI4ubv")
proc glDrawRangeElements*(mode: GLenum, start: GLuint, `end`: GLuint, count: GLsizei, `type`: GLenum, indices: pointer): void =
  ## Render primitives from array data
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_QUAD_STRIP,
  ## GL_QUADS,
  ## and GL_POLYGONare accepted.
  glCallTemplate(cglDrawRangeElements(mode, start, `end`, count, `type`, indices), "glDrawRangeElements")
proc glDrawRangeElementsBaseVertex*(mode: GLenum, start: GLuint, `end`: GLuint, count: GLsizei, `type`: GLenum, indices: pointer, basevertex: GLint): void =
  ## Render primitives from array data with a per-element offset
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP,
  ## GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN,
  ## GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCYand GL_PATCHESare accepted.
  glCallTemplate(cglDrawRangeElementsBaseVertex(mode, start, `end`, count, `type`, indices, basevertex), "glDrawRangeElementsBaseVertex")
proc glDrawTransformFeedback*(mode: GLenum, id: GLuint): void =
  ## Render primitives using a count derived from a transform feedback object
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_LINE_STRIP_ADJACENCY,
  ## GL_LINES_ADJACENCY,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_TRIANGLE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCY, and
  ## GL_PATCHESare accepted.
  glCallTemplate(cglDrawTransformFeedback(mode, id), "glDrawTransformFeedback")
proc glDrawTransformFeedbackInstanced*(mode: GLenum, id: GLuint, instancecount: GLsizei): void =
  ## Render multiple instances of primitives using a count derived from a transform feedback object
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_LINE_STRIP_ADJACENCY,
  ## GL_LINES_ADJACENCY,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_TRIANGLE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCY, and
  ## GL_PATCHESare accepted.
  glCallTemplate(cglDrawTransformFeedbackInstanced(mode, id, instancecount), "glDrawTransformFeedbackInstanced")
proc glDrawTransformFeedbackStream*(mode: GLenum, id: GLuint, stream: GLuint): void =
  ## Render primitives using a count derived from a specifed stream of a transform feedback object
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_LINE_STRIP_ADJACENCY,
  ## GL_LINES_ADJACENCY,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_TRIANGLE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCY, and
  ## GL_PATCHESare accepted.
  glCallTemplate(cglDrawTransformFeedbackStream(mode, id, stream), "glDrawTransformFeedbackStream")
proc glDrawTransformFeedbackStreamInstanced*(mode: GLenum, id: GLuint, stream: GLuint, instancecount: GLsizei): void =
  ## Render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_LINE_STRIP_ADJACENCY,
  ## GL_LINES_ADJACENCY,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_TRIANGLE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCY, and
  ## GL_PATCHESare accepted.
  glCallTemplate(cglDrawTransformFeedbackStreamInstanced(mode, id, stream, instancecount), "glDrawTransformFeedbackStreamInstanced")
proc glVertexAttrib2fv*(index: GLuint, v: ptr GLfloat): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib2fv(index, v), "glVertexAttrib2fv")
proc glEnable*(cap: GLenum): void =
  ## Enable or disable server-side GL capabilities
  ## Specifies a symbolic constant indicating a GL capability.
  glCallTemplate(cglEnable(cap), "glEnable")
proc glVertexAttribDivisor*(index: GLuint, divisor: GLuint): void =
  ## Modify the rate at which generic vertex attributes advance during instanced rendering
  ## Specify the index of the generic vertex attribute.
  glCallTemplate(cglVertexAttribDivisor(index, divisor), "glVertexAttribDivisor")
proc glEnableVertexArrayAttrib*(vaobj: GLuint, index: GLuint): void =
  ## Enable or disable a generic vertex attribute array
  ## Specifies the index of the generic vertex
  glCallTemplate(cglEnableVertexArrayAttrib(vaobj, index), "glEnableVertexArrayAttrib")
proc glEnableVertexAttribArray*(index: GLuint): void =
  ## Enable or disable a generic vertex attribute array
  ## Specifies the index of the generic vertex
  glCallTemplate(cglEnableVertexAttribArray(index), "glEnableVertexAttribArray")
proc glEnablei*(target: GLenum, index: GLuint): void =
  ## Enable or disable server-side GL capabilities
  ## Specifies a symbolic constant indicating a GL capability.
  glCallTemplate(cglEnablei(target, index), "glEnablei")
proc glEndConditionalRender*(): void =
  ## Start conditional rendering
  ## Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded.
  glCallTemplate(cglEndConditionalRender(), "glEndConditionalRender")
proc glEndQuery*(target: GLenum): void =
  ## Delimit the boundaries of a query object
  ## Specifies the target type of query object established between
  ## glBeginQueryand the subsequent glEndQuery.
  ## The symbolic constant must be GL_SAMPLES_PASSED.
  glCallTemplate(cglEndQuery(target), "glEndQuery")
proc glEndQueryIndexed*(target: GLenum, index: GLuint): void =
  ## Delimit the boundaries of a query object on an indexed target
  ## Specifies the target type of query object established between
  ## glBeginQueryIndexedand the subsequent  glEndQueryIndexed.
  ## The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED,
  ## GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or
  ## GL_TIME_ELAPSED.
  glCallTemplate(cglEndQueryIndexed(target, index), "glEndQueryIndexed")
proc glEndTransformFeedback*(): void =
  ## Start transform feedback operation
  ## Specify the output type of the primitives that will be recorded into the
  ## buffer objects that are bound for transform feedback.
  glCallTemplate(cglEndTransformFeedback(), "glEndTransformFeedback")
proc glVertexAttribL1dv*(index: GLuint, v: ptr GLdouble): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribL1dv(index, v), "glVertexAttribL1dv")
proc glVertexAttribL1d*(index: GLuint, x: GLdouble): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribL1d(index, x), "glVertexAttribL1d")
proc glVertexAttribIPointer*(index: GLuint, size: GLint, `type`: GLenum, stride: GLsizei, pointer: pointer): void =
  ## Define an array of generic vertex attribute data
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribIPointer(index, size, `type`, stride, pointer), "glVertexAttribIPointer")
proc glFenceSync*(condition: GLenum, flags: GLbitfield): GLsync =
  ## Create a new sync object and insert it into the GL command stream
  ## Specifies the condition that must be met to set the sync object's state to signaled. conditionmust be GL_SYNC_GPU_COMMANDS_COMPLETE.
  glTypedCallTemplate(cglFenceSync(condition, flags), "glFenceSync")
proc glFinish*(): void =
  ## Block until all GL execution is complete
  ## glFinishdoes not return until the effects of all previously
  ## called GL commands are complete.
  ## Such effects include all changes to GL state,
  ## all changes to connection state,
  ## and all changes to the frame buffer contents.
  glCallTemplate(cglFinish(), "glFinish")
proc glFlush*(): void =
  ## Force execution of GL commands in finite time
  ## Different GL implementations buffer commands in several different locations,
  ## including network buffers and the graphics accelerator itself.
  ## glFlushempties all of these buffers,
  ## causing all issued commands to be executed as quickly as
  ## they are accepted by the actual rendering engine.
  ## Though this execution may not be completed in any particular
  ## time period,
  ## it does complete in finite time.
  glCallTemplate(cglFlush(), "glFlush")
proc glFlushMappedBufferRange*(target: GLenum, offset: GLintptr, length: GLsizeiptr): void =
  ## Indicate modifications to a range of a mapped buffer
  ## Specifies the target to which the buffer object is bound
  ## for glFlushMappedBufferRange, which
  ## must be one of the buffer binding targets in the
  ## following table:
  glCallTemplate(cglFlushMappedBufferRange(target, offset, length), "glFlushMappedBufferRange")
proc glFlushMappedNamedBufferRange*(buffer: GLuint, offset: GLintptr, length: GLsizeiptr): void =
  ## Indicate modifications to a range of a mapped buffer
  ## Specifies the target to which the buffer object is bound
  ## for glFlushMappedBufferRange, which
  ## must be one of the buffer binding targets in the
  ## following table:
  glCallTemplate(cglFlushMappedNamedBufferRange(buffer, offset, length), "glFlushMappedNamedBufferRange")
proc glVertexAttrib3s*(index: GLuint, x: GLshort, y: GLshort, z: GLshort): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib3s(index, x, y, z), "glVertexAttrib3s")
proc glVertexAttrib3sv*(index: GLuint, v: ptr GLshort): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib3sv(index, v), "glVertexAttrib3sv")
proc glFogx*(pname: GLenum, param: GLfixed): void =
  ## Specify fog parameters
  ## Specifies a single-valued fog parameter.
  ## GL_FOG_MODE,
  ## GL_FOG_DENSITY,
  ## GL_FOG_START,
  ## GL_FOG_END,
  ## GL_FOG_INDEX, and
  ## GL_FOG_COORD_SRCare accepted.
  glCallTemplate(cglFogx(pname, param), "glFogx")
proc glFogxv*(pname: GLenum, param: ptr GLfixed): void =
  ## Specify fog parameters
  ## Specifies a single-valued fog parameter.
  ## GL_FOG_MODE,
  ## GL_FOG_DENSITY,
  ## GL_FOG_START,
  ## GL_FOG_END,
  ## GL_FOG_INDEX, and
  ## GL_FOG_COORD_SRCare accepted.
  glCallTemplate(cglFogxv(pname, param), "glFogxv")
proc glFramebufferParameteri*(target: GLenum, pname: GLenum, param: GLint): void =
  ## Set a named parameter of a framebuffer object
  ## Specifies the target to which the framebuffer is bound
  ## for glFramebufferParameteri.
  glCallTemplate(cglFramebufferParameteri(target, pname, param), "glFramebufferParameteri")
proc glFramebufferRenderbuffer*(target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint): void =
  ## Attach a renderbuffer as a logical buffer of a framebuffer object
  ## Specifies the target to which the framebuffer is bound
  ## for glFramebufferRenderbuffer.
  glCallTemplate(cglFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer), "glFramebufferRenderbuffer")
proc glFramebufferTexture*(target: GLenum, attachment: GLenum, texture: GLuint, level: GLint): void =
  ## Attach a level of a texture object as a logical buffer of a framebuffer object
  ## Specifies the target to which the framebuffer is bound
  ## for all commands exceptglNamedFramebufferTexture.
  glCallTemplate(cglFramebufferTexture(target, attachment, texture, level), "glFramebufferTexture")
proc glFramebufferTexture1D*(target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint): void =
  ## Attach a level of a texture object as a logical buffer of a framebuffer object
  ## Specifies the target to which the framebuffer is bound
  ## for all commands exceptglNamedFramebufferTexture.
  glCallTemplate(cglFramebufferTexture1D(target, attachment, textarget, texture, level), "glFramebufferTexture1D")
proc glFramebufferTexture2D*(target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint): void =
  ## Attach a level of a texture object as a logical buffer to the currently bound framebuffer object
  ## Specifies the framebuffer target. targetmust be GL_DRAW_FRAMEBUFFER,
  ## GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFERis equivalent to GL_DRAW_FRAMEBUFFER.
  glCallTemplate(cglFramebufferTexture2D(target, attachment, textarget, texture, level), "glFramebufferTexture2D")
proc glFramebufferTexture3D*(target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint, zoffset: GLint): void =
  ## Attach a level of a texture object as a logical buffer of a framebuffer object
  ## Specifies the target to which the framebuffer is bound
  ## for all commands exceptglNamedFramebufferTexture.
  glCallTemplate(cglFramebufferTexture3D(target, attachment, textarget, texture, level, zoffset), "glFramebufferTexture3D")
proc glFramebufferTextureLayer*(target: GLenum, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint): void =
  ## Attach a single layer of a texture object as a logical buffer of a framebuffer object
  ## Specifies the target to which the framebuffer is bound
  ## for glFramebufferTextureLayer.
  glCallTemplate(cglFramebufferTextureLayer(target, attachment, texture, level, layer), "glFramebufferTextureLayer")
proc glFrontFace*(mode: GLenum): void =
  ## Define front- and back-facing polygons
  ## Specifies the orientation of front-facing polygons.
  ## GL_CWand GL_CCWare accepted.
  ## The initial value is GL_CCW.
  glCallTemplate(cglFrontFace(mode), "glFrontFace")
proc glFrustumf*(l: GLfloat, r: GLfloat, b: GLfloat, t: GLfloat, n: GLfloat, f: GLfloat): void =
  ## Multiply the current matrix by a perspective matrix
  ## Specify the coordinates for the left and right vertical clipping planes.
  glCallTemplate(cglFrustumf(l, r, b, t, n, f), "glFrustumf")
proc glFrustumx*(l: GLfixed, r: GLfixed, b: GLfixed, t: GLfixed, n: GLfixed, f: GLfixed): void =
  ## Multiply the current matrix by a perspective matrix
  ## Specify the coordinates for the left and right vertical clipping planes.
  glCallTemplate(cglFrustumx(l, r, b, t, n, f), "glFrustumx")
proc glGenBuffers*(n: GLsizei, buffers: ptr GLuint): void =
  ## Generate buffer object names
  ## Specifies the number of buffer object names to be generated.
  glCallTemplate(cglGenBuffers(n, buffers), "glGenBuffers")
proc glGenFramebuffers*(n: GLsizei, framebuffers: ptr GLuint): void =
  ## Generate framebuffer object names
  ## Specifies the number of framebuffer object names to generate.
  glCallTemplate(cglGenFramebuffers(n, framebuffers), "glGenFramebuffers")
proc glGenProgramPipelines*(n: GLsizei, pipelines: ptr GLuint): void =
  ## Reserve program pipeline object names
  ## Specifies the number of program pipeline object names to reserve.
  glCallTemplate(cglGenProgramPipelines(n, pipelines), "glGenProgramPipelines")
proc glGenQueries*(n: GLsizei, ids: ptr GLuint): void =
  ## Generate query object names
  ## Specifies the number of query object names to be generated.
  glCallTemplate(cglGenQueries(n, ids), "glGenQueries")
proc glGenRenderbuffers*(n: GLsizei, renderbuffers: ptr GLuint): void =
  ## Generate renderbuffer object names
  ## Specifies the number of renderbuffer object names to generate.
  glCallTemplate(cglGenRenderbuffers(n, renderbuffers), "glGenRenderbuffers")
proc glGenSamplers*(count: GLsizei, samplers: ptr GLuint): void =
  ## Generate sampler object names
  ## Specifies the number of sampler object names to generate.
  glCallTemplate(cglGenSamplers(count, samplers), "glGenSamplers")
proc glGenTextures*(n: GLsizei, textures: ptr GLuint): void =
  ## Generate texture names
  ## Specifies the number of texture names to be generated.
  glCallTemplate(cglGenTextures(n, textures), "glGenTextures")
proc glGenTransformFeedbacks*(n: GLsizei, ids: ptr GLuint): void =
  ## Reserve transform feedback object names
  ## Specifies the number of transform feedback object names to reserve.
  glCallTemplate(cglGenTransformFeedbacks(n, ids), "glGenTransformFeedbacks")
proc glGenVertexArrays*(n: GLsizei, arrays: ptr GLuint): void =
  ## Generate vertex array object names
  ## Specifies the number of vertex array object names to generate.
  glCallTemplate(cglGenVertexArrays(n, arrays), "glGenVertexArrays")
proc glGenerateMipmap*(target: GLenum): void =
  ## Generate mipmaps for a specified texture object
  ## Specifies the target to which the texture object is
  ## bound for glGenerateMipmap. Must be
  ## one of GL_TEXTURE_1D,
  ## GL_TEXTURE_2D,
  ## GL_TEXTURE_3D,
  ## GL_TEXTURE_1D_ARRAY,
  ## GL_TEXTURE_2D_ARRAY,
  ## GL_TEXTURE_CUBE_MAP, or
  ## GL_TEXTURE_CUBE_MAP_ARRAY.
  glCallTemplate(cglGenerateMipmap(target), "glGenerateMipmap")
proc glGenerateTextureMipmap*(texture: GLuint): void =
  ## Generate mipmaps for a specified texture object
  ## Specifies the target to which the texture object is
  ## bound for glGenerateMipmap. Must be
  ## one of GL_TEXTURE_1D,
  ## GL_TEXTURE_2D,
  ## GL_TEXTURE_3D,
  ## GL_TEXTURE_1D_ARRAY,
  ## GL_TEXTURE_2D_ARRAY,
  ## GL_TEXTURE_CUBE_MAP, or
  ## GL_TEXTURE_CUBE_MAP_ARRAY.
  glCallTemplate(cglGenerateTextureMipmap(texture), "glGenerateTextureMipmap")
proc glGetActiveAtomicCounterBufferiv*(program: GLuint, bufferIndex: GLuint, pname: GLenum, params: ptr GLint): void =
  ## Retrieve information about the set of active atomic counter buffers for a program
  ## The name of a program object from which to retrieve information.
  glCallTemplate(cglGetActiveAtomicCounterBufferiv(program, bufferIndex, pname, params), "glGetActiveAtomicCounterBufferiv")
proc glGetActiveAttrib*(program: GLuint, index: GLuint, bufSize: GLsizei, length: ptr GLsizei, size: ptr GLint, `type`: ptr GLenum, name: cstring): void =
  ## Returns information about an active attribute variable for the specified program object
  ## Specifies the program object to be
  glCallTemplate(cglGetActiveAttrib(program, index, bufSize, length, size, `type`, name), "glGetActiveAttrib")
proc glGetActiveSubroutineName*(program: GLuint, shadertype: GLenum, index: GLuint, bufsize: GLsizei, length: ptr GLsizei, name: cstring): void =
  ## Query the name of an active shader subroutine
  ## Specifies the name of the program containing the subroutine.
  glCallTemplate(cglGetActiveSubroutineName(program, shadertype, index, bufsize, length, name), "glGetActiveSubroutineName")
proc glGetActiveSubroutineUniformName*(program: GLuint, shadertype: GLenum, index: GLuint, bufsize: GLsizei, length: ptr GLsizei, name: cstring): void =
  ## Query the name of an active shader subroutine uniform
  ## Specifies the name of the program containing the subroutine.
  glCallTemplate(cglGetActiveSubroutineUniformName(program, shadertype, index, bufsize, length, name), "glGetActiveSubroutineUniformName")
proc glGetActiveSubroutineUniformiv*(program: GLuint, shadertype: GLenum, index: GLuint, pname: GLenum, values: ptr GLint): void =
  ## Query a property of an active shader subroutine uniform
  ## Specifies the name of the program containing the subroutine.
  glCallTemplate(cglGetActiveSubroutineUniformiv(program, shadertype, index, pname, values), "glGetActiveSubroutineUniformiv")
proc glGetActiveUniform*(program: GLuint, index: GLuint, bufSize: GLsizei, length: ptr GLsizei, size: ptr GLint, `type`: ptr GLenum, name: cstring): void =
  ## Returns information about an active uniform variable for the specified program object
  ## Specifies the program object to be
  glCallTemplate(cglGetActiveUniform(program, index, bufSize, length, size, `type`, name), "glGetActiveUniform")
proc glGetActiveUniformBlockName*(program: GLuint, uniformBlockIndex: GLuint, bufSize: GLsizei, length: ptr GLsizei, uniformBlockName: cstring): void =
  ## Retrieve the name of an active uniform block
  ## Specifies the name of a program containing the uniform block.
  glCallTemplate(cglGetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName), "glGetActiveUniformBlockName")
proc glGetActiveUniformBlockiv*(program: GLuint, uniformBlockIndex: GLuint, pname: GLenum, params: ptr GLint): void =
  ## Query information about an active uniform block
  ## Specifies the name of a program containing the uniform block.
  glCallTemplate(cglGetActiveUniformBlockiv(program, uniformBlockIndex, pname, params), "glGetActiveUniformBlockiv")
proc glGetActiveUniformName*(program: GLuint, uniformIndex: GLuint, bufSize: GLsizei, length: ptr GLsizei, uniformName: cstring): void =
  ## Query the name of an active uniform
  ## Specifies the program containing the active uniform index uniformIndex.
  glCallTemplate(cglGetActiveUniformName(program, uniformIndex, bufSize, length, uniformName), "glGetActiveUniformName")
proc glGetActiveUniformsiv*(program: GLuint, uniformCount: GLsizei, uniformIndices: ptr GLuint, pname: GLenum, params: ptr GLint): void =
  ## Returns information about several active uniform variables for the specified program object
  glCallTemplate(cglGetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params), "glGetActiveUniformsiv")
proc glGetAttachedShaders*(program: GLuint, maxCount: GLsizei, count: ptr GLsizei, shaders: ptr GLuint): void =
  ## Returns the handles of the shader objects attached to a program object
  ## Specifies the program object to be
  glCallTemplate(cglGetAttachedShaders(program, maxCount, count, shaders), "glGetAttachedShaders")
proc glGetAttribLocation*(program: GLuint, name: cstring): GLint =
  ## Returns the location of an attribute variable
  ## Specifies the program object to be
  glTypedCallTemplate(cglGetAttribLocation(program, name), "glGetAttribLocation")
proc glGetBooleani_v*(target: GLenum, index: GLuint, data: ptr GLboolean): void =
  ## Return the value or values of a selected parameter
  ## Specifies the parameter value to be returned.
  ## The symbolic constants in the list below are accepted.
  glCallTemplate(cglGetBooleani_v(target, index, data), "glGetBooleani_v")
proc glGetBooleanv*(pname: GLenum, data: ptr GLboolean): void =
  ## Return the value or values of a selected parameter
  ## Specifies the parameter value to be returned.
  ## The symbolic constants in the list below are accepted.
  glCallTemplate(cglGetBooleanv(pname, data), "glGetBooleanv")
proc glGetBufferParameteri64v*(target: GLenum, pname: GLenum, params: ptr GLint64): void =
  ## Return parameters of a buffer object
  ## Specifies the target to which the buffer object is bound
  ## for glGetBufferParameterivand
  ## glGetBufferParameteri64v. Must be
  ## one of the buffer binding targets in the following
  ## table:
  glCallTemplate(cglGetBufferParameteri64v(target, pname, params), "glGetBufferParameteri64v")
proc glGetBufferParameteriv*(target: GLenum, pname: GLenum, params: ptr GLint): void =
  ## Return parameters of a buffer object
  ## Specifies the target buffer object.
  ## The symbolic constant must be GL_ARRAY_BUFFER,
  ## GL_ELEMENT_ARRAY_BUFFER,
  ## GL_PIXEL_PACK_BUFFER, or
  ## GL_PIXEL_UNPACK_BUFFER.
  glCallTemplate(cglGetBufferParameteriv(target, pname, params), "glGetBufferParameteriv")
proc glGetBufferPointerv*(target: GLenum, pname: GLenum, params: ptr pointer): void =
  ## Return the pointer to a mapped buffer object's data store
  ## Specifies the target buffer object.
  ## The symbolic constant must be GL_ARRAY_BUFFER,
  ## GL_ELEMENT_ARRAY_BUFFER,
  ## GL_PIXEL_PACK_BUFFER, or
  ## GL_PIXEL_UNPACK_BUFFER.
  glCallTemplate(cglGetBufferPointerv(target, pname, params), "glGetBufferPointerv")
proc glGetBufferSubData*(target: GLenum, offset: GLintptr, size: GLsizeiptr, data: pointer): void =
  ## Returns a subset of a buffer object's data store
  ## Specifies the target buffer object.
  ## The symbolic constant must be GL_ARRAY_BUFFER,
  ## GL_ELEMENT_ARRAY_BUFFER,
  ## GL_PIXEL_PACK_BUFFER, or
  ## GL_PIXEL_UNPACK_BUFFER.
  glCallTemplate(cglGetBufferSubData(target, offset, size, data), "glGetBufferSubData")
proc glGetClipPlanef*(plane: GLenum, equation: ptr GLfloat): void =
  ## Return the coefficients of the specified clipping plane
  ## Specifies a clipping plane.
  ## The number of clipping planes depends on the implementation,
  ## but at least six clipping planes are supported.
  ## They are identified by symbolic names of the form GL_CLIP_PLANEiwhere i ranges from 0 to the value of GL_MAX_CLIP_PLANES- 1.
  glCallTemplate(cglGetClipPlanef(plane, equation), "glGetClipPlanef")
proc glGetClipPlanex*(plane: GLenum, equation: ptr GLfixed): void =
  ## Return the coefficients of the specified clipping plane
  ## Specifies a clipping plane.
  ## The number of clipping planes depends on the implementation,
  ## but at least six clipping planes are supported.
  ## They are identified by symbolic names of the form GL_CLIP_PLANEiwhere i ranges from 0 to the value of GL_MAX_CLIP_PLANES- 1.
  glCallTemplate(cglGetClipPlanex(plane, equation), "glGetClipPlanex")
proc glGetCompressedTexImage*(target: GLenum, level: GLint, img: pointer): void =
  ## Return a compressed texture image
  ## Specifies which texture is to be obtained.
  ## GL_TEXTURE_1D, GL_TEXTURE_2D, and GL_TEXTURE_3DGL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Zare accepted.
  glCallTemplate(cglGetCompressedTexImage(target, level, img), "glGetCompressedTexImage")
proc glGetCompressedTextureImage*(texture: GLuint, level: GLint, bufSize: GLsizei, pixels: pointer): void =
  ## Return a compressed texture image
  ## Specifies which texture is to be obtained.
  ## GL_TEXTURE_1D, GL_TEXTURE_2D, and GL_TEXTURE_3DGL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Zare accepted.
  glCallTemplate(cglGetCompressedTextureImage(texture, level, bufSize, pixels), "glGetCompressedTextureImage")
proc glGetCompressedTextureSubImage*(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, bufSize: GLsizei, pixels: pointer): void =
  ## Retrieve a sub-region of a compressed texture image from a
  ## compressed texture object
  ## Specifies the name of the source texture object. Must be
  ## GL_TEXTURE_1D,
  ## GL_TEXTURE_1D_ARRAY,
  ## GL_TEXTURE_2D,
  ## GL_TEXTURE_2D_ARRAY,
  ## GL_TEXTURE_3D,
  ## GL_TEXTURE_CUBE_MAP,
  ## GL_TEXTURE_CUBE_MAP_ARRAYor
  ## GL_TEXTURE_RECTANGLE. In specific, buffer and
  glCallTemplate(cglGetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels), "glGetCompressedTextureSubImage")
proc glGetDebugMessageLog*(count: GLuint, bufSize: GLsizei, sources: ptr GLenum, types: ptr GLenum, ids: ptr GLuint, severities: ptr GLenum, lengths: ptr GLsizei, messageLog: cstring): GLuint =
  ## Retrieve messages from the debug message log
  ## The number of debug messages to retrieve from the log.
  glTypedCallTemplate(cglGetDebugMessageLog(count, bufSize, sources, types, ids, severities, lengths, messageLog), "glGetDebugMessageLog")
proc glGetDoublei_v*(target: GLenum, index: GLuint, data: ptr GLdouble): void =
  ## Return the value or values of a selected parameter
  ## Specifies the parameter value to be returned.
  ## The symbolic constants in the list below are accepted.
  glCallTemplate(cglGetDoublei_v(target, index, data), "glGetDoublei_v")
proc glGetDoublev*(pname: GLenum, data: ptr GLdouble): void =
  ## Return the value or values of a selected parameter
  ## Specifies the parameter value to be returned.
  ## The symbolic constants in the list below are accepted.
  glCallTemplate(cglGetDoublev(pname, data), "glGetDoublev")
proc glGetError*(): GLenum =
  ## Return error information
  ## No error has been recorded.
  ## The value of this symbolic constant is guaranteed to be 0.
  glTypedCallTemplate(cglGetError(), "glGetError")
proc glGetFixedv*(pname: GLenum, params: ptr GLfixed): void =
  ## Return the value or values of a selected parameter
  ## Specifies the parameter value to be returned.
  ## The symbolic constants in the list below are accepted.
  glCallTemplate(cglGetFixedv(pname, params), "glGetFixedv")
proc glGetFloati_v*(target: GLenum, index: GLuint, data: ptr GLfloat): void =
  ## Return the value or values of a selected parameter
  ## Specifies the parameter value to be returned.
  ## The symbolic constants in the list below are accepted.
  glCallTemplate(cglGetFloati_v(target, index, data), "glGetFloati_v")
proc glGetFloatv*(pname: GLenum, data: ptr GLfloat): void =
  ## Return the value or values of a selected parameter
  ## Specifies the parameter value to be returned.
  ## The symbolic constants in the list below are accepted.
  glCallTemplate(cglGetFloatv(pname, data), "glGetFloatv")
proc glGetFragDataIndex*(program: GLuint, name: cstring): GLint =
  ## Query the bindings of color indices to user-defined varying out variables
  ## The name of the program containing varying out variable whose binding to query
  glTypedCallTemplate(cglGetFragDataIndex(program, name), "glGetFragDataIndex")
proc glGetFragDataLocation*(program: GLuint, name: cstring): GLint =
  ## Query the bindings of color numbers to user-defined varying out variables
  ## The name of the program containing varying out variable whose binding to query
  glTypedCallTemplate(cglGetFragDataLocation(program, name), "glGetFragDataLocation")
proc glGetFramebufferAttachmentParameteriv*(target: GLenum, attachment: GLenum, pname: GLenum, params: ptr GLint): void =
  ## Retrieve information about attachments of a bound framebuffer object
  ## Specifies the target of the query operation.
  glCallTemplate(cglGetFramebufferAttachmentParameteriv(target, attachment, pname, params), "glGetFramebufferAttachmentParameteriv")
proc glGetFramebufferParameteriv*(target: GLenum, pname: GLenum, params: ptr GLint): void =
  ## Retrieve a named parameter from a framebuffer
  ## The target of the operation, which must be GL_READ_FRAMEBUFFER,
  ## GL_DRAW_FRAMEBUFFERor GL_FRAMEBUFFER.
  glCallTemplate(cglGetFramebufferParameteriv(target, pname, params), "glGetFramebufferParameteriv")
proc glGetGraphicsResetStatus*(): GLenum =
  ## Check if the rendering context has not been lost due to software or hardware issues
  ## Indicates that the GL context has not been in a reset state since
  ## the last call.
  glTypedCallTemplate(cglGetGraphicsResetStatus(), "glGetGraphicsResetStatus")
proc glGetInteger64i_v*(target: GLenum, index: GLuint, data: ptr GLint64): void =
  ## Return the value or values of a selected parameter
  ## Specifies the parameter value to be returned.
  ## The symbolic constants in the list below are accepted.
  glCallTemplate(cglGetInteger64i_v(target, index, data), "glGetInteger64i_v")
proc glGetInteger64v*(pname: GLenum, data: ptr GLint64): void =
  ## Return the value or values of a selected parameter
  ## Specifies the parameter value to be returned.
  ## The symbolic constants in the list below are accepted.
  glCallTemplate(cglGetInteger64v(pname, data), "glGetInteger64v")
proc glGetIntegeri_v*(target: GLenum, index: GLuint, data: ptr GLint): void =
  ## Return the value or values of a selected parameter
  ## Specifies the parameter value to be returned.
  ## The symbolic constants in the list below are accepted.
  glCallTemplate(cglGetIntegeri_v(target, index, data), "glGetIntegeri_v")
proc glGetIntegerv*(pname: GLenum, data: ptr GLint): void =
  ## Return the value or values of a selected parameter
  ## Specifies the parameter value to be returned.
  ## The symbolic constants in the list below are accepted.
  glCallTemplate(cglGetIntegerv(pname, data), "glGetIntegerv")
proc glGetInternalformati64v*(target: GLenum, internalformat: GLenum, pname: GLenum, bufSize: GLsizei, params: ptr GLint64): void =
  ## Retrieve information about implementation-dependent support for internal formats
  ## Indicates the usage of the internal format. targetmust be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY,
  ## GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D,
  ## GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE,
  ## GL_TEXTURE_BUFFER,
  ## GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLEor GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
  glCallTemplate(cglGetInternalformati64v(target, internalformat, pname, bufSize, params), "glGetInternalformati64v")
proc glGetInternalformativ*(target: GLenum, internalformat: GLenum, pname: GLenum, bufSize: GLsizei, params: ptr GLint): void =
  ## Retrieve information about implementation-dependent support for internal formats
  ## Indicates the usage of the internal format. targetmust be GL_RENDERBUFFERor
  ## GL_TEXTURE_2D_MULTISAMPLE.
  glCallTemplate(cglGetInternalformativ(target, internalformat, pname, bufSize, params), "glGetInternalformativ")
proc glVertexAttribI4sv*(index: GLuint, v: ptr GLshort): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI4sv(index, v), "glVertexAttribI4sv")
proc glGetLightxv*(light: GLenum, pname: GLenum, params: ptr GLfixed): void =
  ## Return light source parameter values
  ## Specifies a light source.
  ## The number of possible lights depends on the implementation,
  ## but at least eight lights are supported.
  ## They are identified by symbolic names of the form GL_LIGHTiwhere
  ## iranges from 0 to the value of GL_MAX_LIGHTS- 1.
  glCallTemplate(cglGetLightxv(light, pname, params), "glGetLightxv")
proc glVertexAttribI4iv*(index: GLuint, v: ptr GLint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI4iv(index, v), "glVertexAttribI4iv")
proc glVertexAttribI4i*(index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI4i(index, x, y, z, w), "glVertexAttribI4i")
proc glVertexAttribI4bv*(index: GLuint, v: ptr GLbyte): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI4bv(index, v), "glVertexAttribI4bv")
proc glGetMaterialxv*(face: GLenum, pname: GLenum, params: ptr GLfixed): void =
  ## Return material parameters
  ## Specifies which of the two materials is being queried.
  ## GL_FRONTor GL_BACKare accepted,
  ## representing the front and back materials,
  ## respectively.
  glCallTemplate(cglGetMaterialxv(face, pname, params), "glGetMaterialxv")
proc glGetMultisamplefv*(pname: GLenum, index: GLuint, val: ptr GLfloat): void =
  ## Retrieve the location of a sample
  ## Specifies the sample parameter name. pnamemust be GL_SAMPLE_POSITION.
  glCallTemplate(cglGetMultisamplefv(pname, index, val), "glGetMultisamplefv")
proc glGetNamedBufferParameteri64v*(buffer: GLuint, pname: GLenum, params: ptr GLint64): void =
  ## Return parameters of a buffer object
  ## Specifies the target to which the buffer object is bound
  ## for glGetBufferParameterivand
  ## glGetBufferParameteri64v. Must be
  ## one of the buffer binding targets in the following
  ## table:
  glCallTemplate(cglGetNamedBufferParameteri64v(buffer, pname, params), "glGetNamedBufferParameteri64v")
proc glGetNamedBufferParameteriv*(buffer: GLuint, pname: GLenum, params: ptr GLint): void =
  ## Return parameters of a buffer object
  ## Specifies the target buffer object.
  ## The symbolic constant must be GL_ARRAY_BUFFER,
  ## GL_ELEMENT_ARRAY_BUFFER,
  ## GL_PIXEL_PACK_BUFFER, or
  ## GL_PIXEL_UNPACK_BUFFER.
  glCallTemplate(cglGetNamedBufferParameteriv(buffer, pname, params), "glGetNamedBufferParameteriv")
proc glGetNamedBufferPointerv*(buffer: GLuint, pname: GLenum, params: ptr pointer): void =
  ## Return the pointer to a mapped buffer object's data store
  ## Specifies the target buffer object.
  ## The symbolic constant must be GL_ARRAY_BUFFER,
  ## GL_ELEMENT_ARRAY_BUFFER,
  ## GL_PIXEL_PACK_BUFFER, or
  ## GL_PIXEL_UNPACK_BUFFER.
  glCallTemplate(cglGetNamedBufferPointerv(buffer, pname, params), "glGetNamedBufferPointerv")
proc glGetNamedBufferSubData*(buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: pointer): void =
  ## Returns a subset of a buffer object's data store
  ## Specifies the target buffer object.
  ## The symbolic constant must be GL_ARRAY_BUFFER,
  ## GL_ELEMENT_ARRAY_BUFFER,
  ## GL_PIXEL_PACK_BUFFER, or
  ## GL_PIXEL_UNPACK_BUFFER.
  glCallTemplate(cglGetNamedBufferSubData(buffer, offset, size, data), "glGetNamedBufferSubData")
proc glGetNamedFramebufferAttachmentParameteriv*(framebuffer: GLuint, attachment: GLenum, pname: GLenum, params: ptr GLint): void =
  ## Retrieve information about attachments of a bound framebuffer object
  ## Specifies the target of the query operation.
  glCallTemplate(cglGetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, params), "glGetNamedFramebufferAttachmentParameteriv")
proc glGetNamedFramebufferParameteriv*(framebuffer: GLuint, pname: GLenum, param: ptr GLint): void =
  ## Retrieve a named parameter from a framebuffer
  ## The target of the operation, which must be GL_READ_FRAMEBUFFER,
  ## GL_DRAW_FRAMEBUFFERor GL_FRAMEBUFFER.
  glCallTemplate(cglGetNamedFramebufferParameteriv(framebuffer, pname, param), "glGetNamedFramebufferParameteriv")
proc glGetNamedRenderbufferParameteriv*(renderbuffer: GLuint, pname: GLenum, params: ptr GLint): void =
  ## Retrieve information about a bound renderbuffer object
  ## Specifies the target of the query operation. targetmust be GL_RENDERBUFFER.
  glCallTemplate(cglGetNamedRenderbufferParameteriv(renderbuffer, pname, params), "glGetNamedRenderbufferParameteriv")
proc glGetObjectLabel*(identifier: GLenum, name: GLuint, bufSize: GLsizei, length: ptr GLsizei, label: cstring): void =
  ## Retrieve the label of a named object identified within a namespace
  ## The namespace from which the name of the object is allocated.
  glCallTemplate(cglGetObjectLabel(identifier, name, bufSize, length, label), "glGetObjectLabel")
proc glGetObjectPtrLabel*(`ptr`: pointer, bufSize: GLsizei, length: ptr GLsizei, label: cstring): void =
  ## Retrieve the label of a sync object identified by a pointer
  ## The name of the sync object whose label to retrieve.
  glCallTemplate(cglGetObjectPtrLabel(`ptr`, bufSize, length, label), "glGetObjectPtrLabel")
proc glVertexAttribI3uiv*(index: GLuint, v: ptr GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI3uiv(index, v), "glVertexAttribI3uiv")
proc glVertexAttribI3ui*(index: GLuint, x: GLuint, y: GLuint, z: GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI3ui(index, x, y, z), "glVertexAttribI3ui")
proc glGetProgramBinary*(program: GLuint, bufSize: GLsizei, length: ptr GLsizei, binaryFormat: ptr GLenum, binary: pointer): void =
  ## Return a binary representation of a program object's compiled and linked executable source
  ## Specifies the name of a program object whose binary representation to retrieve.
  glCallTemplate(cglGetProgramBinary(program, bufSize, length, binaryFormat, binary), "glGetProgramBinary")
proc glGetProgramInfoLog*(program: GLuint, bufSize: GLsizei, length: ptr GLsizei, infoLog: cstring): void =
  ## Returns the information log for a program object
  ## Specifies the program object whose information
  glCallTemplate(cglGetProgramInfoLog(program, bufSize, length, infoLog), "glGetProgramInfoLog")
proc glGetProgramInterfaceiv*(program: GLuint, programInterface: GLenum, pname: GLenum, params: ptr GLint): void =
  ## Query a property of an interface in a program
  ## The name of a program object whose interface to query.
  glCallTemplate(cglGetProgramInterfaceiv(program, programInterface, pname, params), "glGetProgramInterfaceiv")
proc glGetProgramPipelineInfoLog*(pipeline: GLuint, bufSize: GLsizei, length: ptr GLsizei, infoLog: cstring): void =
  ## Retrieve the info log string from a program pipeline object
  ## Specifies the name of a program pipeline object from which to retrieve the info log.
  glCallTemplate(cglGetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog), "glGetProgramPipelineInfoLog")
proc glGetProgramPipelineiv*(pipeline: GLuint, pname: GLenum, params: ptr GLint): void =
  ## Retrieve properties of a program pipeline object
  ## Specifies the name of a program pipeline object whose parameter retrieve.
  glCallTemplate(cglGetProgramPipelineiv(pipeline, pname, params), "glGetProgramPipelineiv")
proc glGetProgramResourceIndex*(program: GLuint, programInterface: GLenum, name: cstring): GLuint =
  ## Query the index of a named resource within a program
  ## The name of a program object whose resources to query.
  glTypedCallTemplate(cglGetProgramResourceIndex(program, programInterface, name), "glGetProgramResourceIndex")
proc glGetProgramResourceLocation*(program: GLuint, programInterface: GLenum, name: cstring): GLint =
  ## Query the location of a named resource within a program
  ## The name of a program object whose resources to query.
  glTypedCallTemplate(cglGetProgramResourceLocation(program, programInterface, name), "glGetProgramResourceLocation")
proc glGetProgramResourceLocationIndex*(program: GLuint, programInterface: GLenum, name: cstring): GLint =
  ## Query the fragment color index of a named variable within a program
  ## The name of a program object whose resources to query.
  glTypedCallTemplate(cglGetProgramResourceLocationIndex(program, programInterface, name), "glGetProgramResourceLocationIndex")
proc glGetProgramResourceName*(program: GLuint, programInterface: GLenum, index: GLuint, bufSize: GLsizei, length: ptr GLsizei, name: cstring): void =
  ## Query the name of an indexed resource within a program
  ## The name of a program object whose resources to query.
  glCallTemplate(cglGetProgramResourceName(program, programInterface, index, bufSize, length, name), "glGetProgramResourceName")
proc glGetProgramResourceiv*(program: GLuint, programInterface: GLenum, index: GLuint, propCount: GLsizei, props: ptr GLenum, bufSize: GLsizei, length: ptr GLsizei, params: ptr GLint): void =
  ## Retrieve values for multiple properties of a single active resource within a program object
  ## The name of a program object whose resources to query.
  glCallTemplate(cglGetProgramResourceiv(program, programInterface, index, propCount, props, bufSize, length, params), "glGetProgramResourceiv")
proc glGetProgramStageiv*(program: GLuint, shadertype: GLenum, pname: GLenum, values: ptr GLint): void =
  ## Retrieve properties of a program object corresponding to a specified shader stage
  ## Specifies the name of the program containing shader stage.
  glCallTemplate(cglGetProgramStageiv(program, shadertype, pname, values), "glGetProgramStageiv")
proc glGetProgramiv*(program: GLuint, pname: GLenum, params: ptr GLint): void =
  ## Returns a parameter from a program object
  ## Specifies the program object to be
  glCallTemplate(cglGetProgramiv(program, pname, params), "glGetProgramiv")
proc glGetQueryBufferObjecti64v*(id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr): void =
  ## Missing: https://github.com/KhronosGroup/OpenGL-Refpages/issues/10
  glCallTemplate(cglGetQueryBufferObjecti64v(id, buffer, pname, offset), "glGetQueryBufferObjecti64v")
proc glGetQueryBufferObjectiv*(id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr): void =
  ## Missing: https://github.com/KhronosGroup/OpenGL-Refpages/issues/10
  glCallTemplate(cglGetQueryBufferObjectiv(id, buffer, pname, offset), "glGetQueryBufferObjectiv")
proc glGetQueryBufferObjectui64v*(id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr): void =
  ## Missing: https://github.com/KhronosGroup/OpenGL-Refpages/issues/10
  glCallTemplate(cglGetQueryBufferObjectui64v(id, buffer, pname, offset), "glGetQueryBufferObjectui64v")
proc glGetQueryBufferObjectuiv*(id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr): void =
  ## Missing: https://github.com/KhronosGroup/OpenGL-Refpages/issues/10
  glCallTemplate(cglGetQueryBufferObjectuiv(id, buffer, pname, offset), "glGetQueryBufferObjectuiv")
proc glGetQueryIndexediv*(target: GLenum, index: GLuint, pname: GLenum, params: ptr GLint): void =
  ## Return parameters of an indexed query object target
  ## Specifies a query object target.
  ## Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVEGL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN,
  ## GL_TIME_ELAPSED, or GL_TIMESTAMP.
  glCallTemplate(cglGetQueryIndexediv(target, index, pname, params), "glGetQueryIndexediv")
proc glGetQueryObjecti64v*(id: GLuint, pname: GLenum, params: ptr GLint64): void =
  ## Return parameters of a query object
  ## Specifies the name of a query object.
  glCallTemplate(cglGetQueryObjecti64v(id, pname, params), "glGetQueryObjecti64v")
proc glGetQueryObjectiv*(id: GLuint, pname: GLenum, params: ptr GLint): void =
  ## Return parameters of a query object
  ## Specifies the name of a query object.
  glCallTemplate(cglGetQueryObjectiv(id, pname, params), "glGetQueryObjectiv")
proc glGetQueryObjectui64v*(id: GLuint, pname: GLenum, params: ptr GLuint64): void =
  ## Return parameters of a query object
  ## Specifies the name of a query object.
  glCallTemplate(cglGetQueryObjectui64v(id, pname, params), "glGetQueryObjectui64v")
proc glGetQueryObjectuiv*(id: GLuint, pname: GLenum, params: ptr GLuint): void =
  ## Return parameters of a query object
  ## Specifies the name of a query object.
  glCallTemplate(cglGetQueryObjectuiv(id, pname, params), "glGetQueryObjectuiv")
proc glGetQueryiv*(target: GLenum, pname: GLenum, params: ptr GLint): void =
  ## Return parameters of a query object target
  ## Specifies a query object target.
  ## Must be GL_SAMPLES_PASSED.
  glCallTemplate(cglGetQueryiv(target, pname, params), "glGetQueryiv")
proc glGetRenderbufferParameteriv*(target: GLenum, pname: GLenum, params: ptr GLint): void =
  ## Retrieve information about a bound renderbuffer object
  ## Specifies the target of the query operation. targetmust be GL_RENDERBUFFER.
  glCallTemplate(cglGetRenderbufferParameteriv(target, pname, params), "glGetRenderbufferParameteriv")
proc glGetSamplerParameterIiv*(sampler: GLuint, pname: GLenum, params: ptr GLint): void =
  ## Return sampler parameter values
  ## Specifies name of the sampler object from which to retrieve parameters.
  glCallTemplate(cglGetSamplerParameterIiv(sampler, pname, params), "glGetSamplerParameterIiv")
proc glGetSamplerParameterIuiv*(sampler: GLuint, pname: GLenum, params: ptr GLuint): void =
  ## Return sampler parameter values
  ## Specifies name of the sampler object from which to retrieve parameters.
  glCallTemplate(cglGetSamplerParameterIuiv(sampler, pname, params), "glGetSamplerParameterIuiv")
proc glGetSamplerParameterfv*(sampler: GLuint, pname: GLenum, params: ptr GLfloat): void =
  ## Return sampler parameter values
  ## Specifies name of the sampler object from which to retrieve parameters.
  glCallTemplate(cglGetSamplerParameterfv(sampler, pname, params), "glGetSamplerParameterfv")
proc glGetSamplerParameteriv*(sampler: GLuint, pname: GLenum, params: ptr GLint): void =
  ## Return sampler parameter values
  ## Specifies name of the sampler object from which to retrieve parameters.
  glCallTemplate(cglGetSamplerParameteriv(sampler, pname, params), "glGetSamplerParameteriv")
proc glGetShaderInfoLog*(shader: GLuint, bufSize: GLsizei, length: ptr GLsizei, infoLog: cstring): void =
  ## Returns the information log for a shader object
  ## Specifies the shader object whose information
  glCallTemplate(cglGetShaderInfoLog(shader, bufSize, length, infoLog), "glGetShaderInfoLog")
proc glGetShaderPrecisionFormat*(shadertype: GLenum, precisiontype: GLenum, range: ptr GLint, precision: ptr GLint): void =
  ## Retrieve the range and precision for numeric formats supported by the shader compiler
  ## Specifies the type of shader whose precision to query. shaderTypemust be GL_VERTEX_SHADERor GL_FRAGMENT_SHADER.
  glCallTemplate(cglGetShaderPrecisionFormat(shadertype, precisiontype, range, precision), "glGetShaderPrecisionFormat")
proc glGetShaderSource*(shader: GLuint, bufSize: GLsizei, length: ptr GLsizei, source: cstring): void =
  ## Returns the source code string from a shader object
  ## Specifies the shader object to be
  glCallTemplate(cglGetShaderSource(shader, bufSize, length, source), "glGetShaderSource")
proc glGetShaderiv*(shader: GLuint, pname: GLenum, params: ptr GLint): void =
  ## Returns a parameter from a shader object
  ## Specifies the shader object to be
  glCallTemplate(cglGetShaderiv(shader, pname, params), "glGetShaderiv")
proc glGetString*(name: GLenum): ptr GLubyte =
  ## Return a string describing the current GL connection
  ## Specifies a symbolic constant, one of
  ## GL_VENDOR, GL_RENDERER, GL_VERSION, GL_SHADING_LANGUAGE_VERSION, or GL_EXTENSIONS.
  glTypedCallTemplate(cglGetString(name), "glGetString")
proc glGetStringi*(name: GLenum, index: GLuint): ptr GLubyte =
  ## Return a string describing the current GL connection
  ## Specifies a symbolic constant, one of
  ## GL_VENDOR, GL_RENDERER, GL_VERSION, GL_SHADING_LANGUAGE_VERSION, or GL_EXTENSIONS.
  glTypedCallTemplate(cglGetStringi(name, index), "glGetStringi")
proc glGetSubroutineIndex*(program: GLuint, shadertype: GLenum, name: cstring): GLuint =
  ## Retrieve the index of a subroutine uniform of a given shader stage within a program
  ## Specifies the name of the program containing shader stage.
  glTypedCallTemplate(cglGetSubroutineIndex(program, shadertype, name), "glGetSubroutineIndex")
proc glGetSubroutineUniformLocation*(program: GLuint, shadertype: GLenum, name: cstring): GLint =
  ## Retrieve the location of a subroutine uniform of a given shader stage within a program
  ## Specifies the name of the program containing shader stage.
  glTypedCallTemplate(cglGetSubroutineUniformLocation(program, shadertype, name), "glGetSubroutineUniformLocation")
proc glGetSynciv*(sync: GLsync, pname: GLenum, bufSize: GLsizei, length: ptr GLsizei, values: ptr GLint): void =
  ## Query the properties of a sync object
  ## Specifies the sync object whose properties to query.
  glCallTemplate(cglGetSynciv(sync, pname, bufSize, length, values), "glGetSynciv")
proc glVertexAttribI3iv*(index: GLuint, v: ptr GLint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI3iv(index, v), "glVertexAttribI3iv")
proc glGetTexEnvxv*(target: GLenum, pname: GLenum, params: ptr GLfixed): void =
  ## Return texture environment parameters
  ## Specifies a texture environment. May be
  ## GL_TEXTURE_ENV,
  ## GL_TEXTURE_FILTER_CONTROL, or
  ## GL_POINT_SPRITE.
  glCallTemplate(cglGetTexEnvxv(target, pname, params), "glGetTexEnvxv")
proc glVertexAttribI3i*(index: GLuint, x: GLint, y: GLint, z: GLint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI3i(index, x, y, z), "glVertexAttribI3i")
proc glGetTexImage*(target: GLenum, level: GLint, format: GLenum, `type`: GLenum, pixels: pointer): void =
  ## Return a texture image
  ## Specifies which texture is to be obtained.
  ## GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Zare accepted.
  glCallTemplate(cglGetTexImage(target, level, format, `type`, pixels), "glGetTexImage")
proc glGetTexLevelParameterfv*(target: GLenum, level: GLint, pname: GLenum, params: ptr GLfloat): void =
  ## Return texture parameter values for a specific level of detail
  ## Specifies the symbolic name of the target texture,
  ## either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D,
  ## GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D,
  ## GL_PROXY_TEXTURE_3D,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or
  ## GL_PROXY_TEXTURE_CUBE_MAP.
  glCallTemplate(cglGetTexLevelParameterfv(target, level, pname, params), "glGetTexLevelParameterfv")
proc glGetTexLevelParameteriv*(target: GLenum, level: GLint, pname: GLenum, params: ptr GLint): void =
  ## Return texture parameter values for a specific level of detail
  ## Specifies the symbolic name of the target texture,
  ## either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D,
  ## GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D,
  ## GL_PROXY_TEXTURE_3D,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or
  ## GL_PROXY_TEXTURE_CUBE_MAP.
  glCallTemplate(cglGetTexLevelParameteriv(target, level, pname, params), "glGetTexLevelParameteriv")
proc glGetTexParameterIiv*(target: GLenum, pname: GLenum, params: ptr GLint): void =
  ## Return texture parameter values
  ## Specifies the symbolic name of the target texture.
  ## GL_TEXTURE_1D,
  ## GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, and
  ## GL_TEXTURE_CUBE_MAPare accepted.
  glCallTemplate(cglGetTexParameterIiv(target, pname, params), "glGetTexParameterIiv")
proc glGetTexParameterIuiv*(target: GLenum, pname: GLenum, params: ptr GLuint): void =
  ## Return texture parameter values
  ## Specifies the symbolic name of the target texture.
  ## GL_TEXTURE_1D,
  ## GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, and
  ## GL_TEXTURE_CUBE_MAPare accepted.
  glCallTemplate(cglGetTexParameterIuiv(target, pname, params), "glGetTexParameterIuiv")
proc glGetTexParameterfv*(target: GLenum, pname: GLenum, params: ptr GLfloat): void =
  ## Return texture parameter values
  ## Specifies the symbolic name of the target texture.
  ## GL_TEXTURE_1D,
  ## GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, and
  ## GL_TEXTURE_CUBE_MAPare accepted.
  glCallTemplate(cglGetTexParameterfv(target, pname, params), "glGetTexParameterfv")
proc glGetTexParameteriv*(target: GLenum, pname: GLenum, params: ptr GLint): void =
  ## Return texture parameter values
  ## Specifies the symbolic name of the target texture.
  ## GL_TEXTURE_1D,
  ## GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, and
  ## GL_TEXTURE_CUBE_MAPare accepted.
  glCallTemplate(cglGetTexParameteriv(target, pname, params), "glGetTexParameteriv")
proc glGetTexParameterxv*(target: GLenum, pname: GLenum, params: ptr GLfixed): void =
  ## Return texture parameter values
  ## Specifies the symbolic name of the target texture.
  ## GL_TEXTURE_1D,
  ## GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, and
  ## GL_TEXTURE_CUBE_MAPare accepted.
  glCallTemplate(cglGetTexParameterxv(target, pname, params), "glGetTexParameterxv")
proc glGetTextureImage*(texture: GLuint, level: GLint, format: GLenum, `type`: GLenum, bufSize: GLsizei, pixels: pointer): void =
  ## Return a texture image
  ## Specifies which texture is to be obtained.
  ## GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Zare accepted.
  glCallTemplate(cglGetTextureImage(texture, level, format, `type`, bufSize, pixels), "glGetTextureImage")
proc glGetTextureLevelParameterfv*(texture: GLuint, level: GLint, pname: GLenum, params: ptr GLfloat): void =
  ## Return texture parameter values for a specific level of detail
  ## Specifies the symbolic name of the target texture,
  ## either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D,
  ## GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D,
  ## GL_PROXY_TEXTURE_3D,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or
  ## GL_PROXY_TEXTURE_CUBE_MAP.
  glCallTemplate(cglGetTextureLevelParameterfv(texture, level, pname, params), "glGetTextureLevelParameterfv")
proc glGetTextureLevelParameteriv*(texture: GLuint, level: GLint, pname: GLenum, params: ptr GLint): void =
  ## Return texture parameter values for a specific level of detail
  ## Specifies the symbolic name of the target texture,
  ## either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D,
  ## GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D,
  ## GL_PROXY_TEXTURE_3D,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or
  ## GL_PROXY_TEXTURE_CUBE_MAP.
  glCallTemplate(cglGetTextureLevelParameteriv(texture, level, pname, params), "glGetTextureLevelParameteriv")
proc glGetTextureParameterIiv*(texture: GLuint, pname: GLenum, params: ptr GLint): void =
  ## Return texture parameter values
  ## Specifies the symbolic name of the target texture.
  ## GL_TEXTURE_1D,
  ## GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, and
  ## GL_TEXTURE_CUBE_MAPare accepted.
  glCallTemplate(cglGetTextureParameterIiv(texture, pname, params), "glGetTextureParameterIiv")
proc glGetTextureParameterIuiv*(texture: GLuint, pname: GLenum, params: ptr GLuint): void =
  ## Return texture parameter values
  ## Specifies the symbolic name of the target texture.
  ## GL_TEXTURE_1D,
  ## GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, and
  ## GL_TEXTURE_CUBE_MAPare accepted.
  glCallTemplate(cglGetTextureParameterIuiv(texture, pname, params), "glGetTextureParameterIuiv")
proc glGetTextureParameterfv*(texture: GLuint, pname: GLenum, params: ptr GLfloat): void =
  ## Return texture parameter values
  ## Specifies the symbolic name of the target texture.
  ## GL_TEXTURE_1D,
  ## GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, and
  ## GL_TEXTURE_CUBE_MAPare accepted.
  glCallTemplate(cglGetTextureParameterfv(texture, pname, params), "glGetTextureParameterfv")
proc glGetTextureParameteriv*(texture: GLuint, pname: GLenum, params: ptr GLint): void =
  ## Return texture parameter values
  ## Specifies the symbolic name of the target texture.
  ## GL_TEXTURE_1D,
  ## GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, and
  ## GL_TEXTURE_CUBE_MAPare accepted.
  glCallTemplate(cglGetTextureParameteriv(texture, pname, params), "glGetTextureParameteriv")
proc glGetTextureSubImage*(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, `type`: GLenum, bufSize: GLsizei, pixels: pointer): void =
  ## Retrieve a sub-region of a texture image from a texture
  ## object
  ## Specifies the name of the source texture object. Must be
  ## GL_TEXTURE_1D,
  ## GL_TEXTURE_1D_ARRAY,
  ## GL_TEXTURE_2D,
  ## GL_TEXTURE_2D_ARRAY,
  ## GL_TEXTURE_3D,
  ## GL_TEXTURE_CUBE_MAP,
  ## GL_TEXTURE_CUBE_MAP_ARRAYor
  ## GL_TEXTURE_RECTANGLE. In specific, buffer and
  glCallTemplate(cglGetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, `type`, bufSize, pixels), "glGetTextureSubImage")
proc glGetTransformFeedbackVarying*(program: GLuint, index: GLuint, bufSize: GLsizei, length: ptr GLsizei, size: ptr GLsizei, `type`: ptr GLenum, name: cstring): void =
  ## Retrieve information about varying variables selected for transform feedback
  ## The name of the target program object.
  glCallTemplate(cglGetTransformFeedbackVarying(program, index, bufSize, length, size, `type`, name), "glGetTransformFeedbackVarying")
proc glGetTransformFeedbacki64_v*(xfb: GLuint, pname: GLenum, index: GLuint, param: ptr GLint64): void =
  ## Query the state of a transform feedback object.
  ## The name of an existing transform feedback object, or zero for
  glCallTemplate(cglGetTransformFeedbacki64_v(xfb, pname, index, param), "glGetTransformFeedbacki64_v")
proc glGetTransformFeedbackiv*(xfb: GLuint, pname: GLenum, param: ptr GLint): void =
  ## Query the state of a transform feedback object.
  ## The name of an existing transform feedback object, or zero for
  glCallTemplate(cglGetTransformFeedbackiv(xfb, pname, param), "glGetTransformFeedbackiv")
proc glGetUniformBlockIndex*(program: GLuint, uniformBlockName: cstring): GLuint =
  ## Retrieve the index of a named uniform block
  ## Specifies the name of a program containing the uniform block.
  glTypedCallTemplate(cglGetUniformBlockIndex(program, uniformBlockName), "glGetUniformBlockIndex")
proc glGetUniformIndices*(program: GLuint, uniformCount: GLsizei, uniformNames: ptr cstring, uniformIndices: ptr GLuint): void =
  ## Retrieve the index of a named uniform block
  ## Specifies the name of a program containing uniforms whose indices to query.
  glCallTemplate(cglGetUniformIndices(program, uniformCount, uniformNames, uniformIndices), "glGetUniformIndices")
proc glGetUniformLocation*(program: GLuint, name: cstring): GLint =
  ## Returns the location of a uniform variable
  ## Specifies the program object to be
  glTypedCallTemplate(cglGetUniformLocation(program, name), "glGetUniformLocation")
proc glGetUniformSubroutineuiv*(shadertype: GLenum, location: GLint, params: ptr GLuint): void =
  ## Retrieve the value of a subroutine uniform of a given shader stage of the current program
  ## Specifies the shader stage from which to query for subroutine uniform index.
  ## shadertypemust be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER,
  ## GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADERor
  ## GL_FRAGMENT_SHADER.
  glCallTemplate(cglGetUniformSubroutineuiv(shadertype, location, params), "glGetUniformSubroutineuiv")
proc glGetUniformdv*(program: GLuint, location: GLint, params: ptr GLdouble): void =
  ## Returns the value of a uniform variable
  ## Specifies the program object to be
  glCallTemplate(cglGetUniformdv(program, location, params), "glGetUniformdv")
proc glGetUniformfv*(program: GLuint, location: GLint, params: ptr GLfloat): void =
  ## Returns the value of a uniform variable
  ## Specifies the program object to be
  glCallTemplate(cglGetUniformfv(program, location, params), "glGetUniformfv")
proc glGetUniformiv*(program: GLuint, location: GLint, params: ptr GLint): void =
  ## Returns the value of a uniform variable
  ## Specifies the program object to be
  glCallTemplate(cglGetUniformiv(program, location, params), "glGetUniformiv")
proc glGetUniformuiv*(program: GLuint, location: GLint, params: ptr GLuint): void =
  ## Returns the value of a uniform variable
  ## Specifies the program object to be
  glCallTemplate(cglGetUniformuiv(program, location, params), "glGetUniformuiv")
proc glGetVertexArrayIndexed64iv*(vaobj: GLuint, index: GLuint, pname: GLenum, param: ptr GLint64): void =
  ## Retrieve parameters of an attribute of a vertex array
  ## object
  glCallTemplate(cglGetVertexArrayIndexed64iv(vaobj, index, pname, param), "glGetVertexArrayIndexed64iv")
proc glGetVertexArrayIndexediv*(vaobj: GLuint, index: GLuint, pname: GLenum, param: ptr GLint): void =
  ## Retrieve parameters of an attribute of a vertex array
  ## object
  glCallTemplate(cglGetVertexArrayIndexediv(vaobj, index, pname, param), "glGetVertexArrayIndexediv")
proc glGetVertexArrayiv*(vaobj: GLuint, pname: GLenum, param: ptr GLint): void =
  ## Retrieve parameters of a vertex array object
  ## specifies the name of the vertex array object to use for the
  glCallTemplate(cglGetVertexArrayiv(vaobj, pname, param), "glGetVertexArrayiv")
proc glGetVertexAttribIiv*(index: GLuint, pname: GLenum, params: ptr GLint): void =
  ## Return a generic vertex attribute parameter
  ## Specifies the generic vertex attribute
  glCallTemplate(cglGetVertexAttribIiv(index, pname, params), "glGetVertexAttribIiv")
proc glGetVertexAttribIuiv*(index: GLuint, pname: GLenum, params: ptr GLuint): void =
  ## Return a generic vertex attribute parameter
  ## Specifies the generic vertex attribute
  glCallTemplate(cglGetVertexAttribIuiv(index, pname, params), "glGetVertexAttribIuiv")
proc glGetVertexAttribLdv*(index: GLuint, pname: GLenum, params: ptr GLdouble): void =
  ## Return a generic vertex attribute parameter
  ## Specifies the generic vertex attribute
  glCallTemplate(cglGetVertexAttribLdv(index, pname, params), "glGetVertexAttribLdv")
proc glGetVertexAttribPointerv*(index: GLuint, pname: GLenum, pointer: ptr pointer): void =
  ## Return the address of the specified generic vertex attribute pointer
  ## Specifies the generic vertex attribute
  glCallTemplate(cglGetVertexAttribPointerv(index, pname, pointer), "glGetVertexAttribPointerv")
proc glGetVertexAttribdv*(index: GLuint, pname: GLenum, params: ptr GLdouble): void =
  ## Return a generic vertex attribute parameter
  ## Specifies the generic vertex attribute
  glCallTemplate(cglGetVertexAttribdv(index, pname, params), "glGetVertexAttribdv")
proc glGetVertexAttribfv*(index: GLuint, pname: GLenum, params: ptr GLfloat): void =
  ## Return a generic vertex attribute parameter
  ## Specifies the generic vertex attribute
  glCallTemplate(cglGetVertexAttribfv(index, pname, params), "glGetVertexAttribfv")
proc glGetVertexAttribiv*(index: GLuint, pname: GLenum, params: ptr GLint): void =
  ## Return a generic vertex attribute parameter
  ## Specifies the generic vertex attribute
  glCallTemplate(cglGetVertexAttribiv(index, pname, params), "glGetVertexAttribiv")
proc glGetnColorTable*(target: GLenum, format: GLenum, `type`: GLenum, bufSize: GLsizei, table: pointer): void =
  ## Retrieve contents of a color lookup table
  ## Must be GL_COLOR_TABLE,
  ## GL_POST_CONVOLUTION_COLOR_TABLE,
  ## or
  ## GL_POST_COLOR_MATRIX_COLOR_TABLE.
  glCallTemplate(cglGetnColorTable(target, format, `type`, bufSize, table), "glGetnColorTable")
proc glGetnCompressedTexImage*(target: GLenum, lod: GLint, bufSize: GLsizei, pixels: pointer): void =
  ## Return a compressed texture image
  ## Specifies which texture is to be obtained.
  ## GL_TEXTURE_1D, GL_TEXTURE_2D, and GL_TEXTURE_3DGL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Zare accepted.
  glCallTemplate(cglGetnCompressedTexImage(target, lod, bufSize, pixels), "glGetnCompressedTexImage")
proc glGetnConvolutionFilter*(target: GLenum, format: GLenum, `type`: GLenum, bufSize: GLsizei, image: pointer): void =
  ## Get current 1D or 2D convolution filter kernel
  ## The filter to be retrieved.
  ## Must be one of
  ## GL_CONVOLUTION_1Dor
  ## GL_CONVOLUTION_2D.
  glCallTemplate(cglGetnConvolutionFilter(target, format, `type`, bufSize, image), "glGetnConvolutionFilter")
proc glGetnHistogram*(target: GLenum, reset: GLboolean, format: GLenum, `type`: GLenum, bufSize: GLsizei, values: pointer): void =
  ## Get histogram table
  ## Must be
  ## GL_HISTOGRAM.
  glCallTemplate(cglGetnHistogram(target, reset, format, `type`, bufSize, values), "glGetnHistogram")
proc glGetnMapdv*(target: GLenum, query: GLenum, bufSize: GLsizei, v: ptr GLdouble): void =
  ## Return evaluator parameters
  ## Specifies the symbolic name of a map.
  ## Accepted values are
  ## GL_MAP1_COLOR_4,
  ## GL_MAP1_INDEX,
  ## GL_MAP1_NORMAL,
  ## GL_MAP1_TEXTURE_COORD_1,
  ## GL_MAP1_TEXTURE_COORD_2,
  ## GL_MAP1_TEXTURE_COORD_3,
  ## GL_MAP1_TEXTURE_COORD_4,
  ## GL_MAP1_VERTEX_3,
  ## GL_MAP1_VERTEX_4,
  ## GL_MAP2_COLOR_4,
  ## GL_MAP2_INDEX,
  ## GL_MAP2_NORMAL,
  ## GL_MAP2_TEXTURE_COORD_1,
  ## GL_MAP2_TEXTURE_COORD_2,
  ## GL_MAP2_TEXTURE_COORD_3,
  ## GL_MAP2_TEXTURE_COORD_4,
  ## GL_MAP2_VERTEX_3, and
  ## GL_MAP2_VERTEX_4.
  glCallTemplate(cglGetnMapdv(target, query, bufSize, v), "glGetnMapdv")
proc glGetnMapfv*(target: GLenum, query: GLenum, bufSize: GLsizei, v: ptr GLfloat): void =
  ## Return evaluator parameters
  ## Specifies the symbolic name of a map.
  ## Accepted values are
  ## GL_MAP1_COLOR_4,
  ## GL_MAP1_INDEX,
  ## GL_MAP1_NORMAL,
  ## GL_MAP1_TEXTURE_COORD_1,
  ## GL_MAP1_TEXTURE_COORD_2,
  ## GL_MAP1_TEXTURE_COORD_3,
  ## GL_MAP1_TEXTURE_COORD_4,
  ## GL_MAP1_VERTEX_3,
  ## GL_MAP1_VERTEX_4,
  ## GL_MAP2_COLOR_4,
  ## GL_MAP2_INDEX,
  ## GL_MAP2_NORMAL,
  ## GL_MAP2_TEXTURE_COORD_1,
  ## GL_MAP2_TEXTURE_COORD_2,
  ## GL_MAP2_TEXTURE_COORD_3,
  ## GL_MAP2_TEXTURE_COORD_4,
  ## GL_MAP2_VERTEX_3, and
  ## GL_MAP2_VERTEX_4.
  glCallTemplate(cglGetnMapfv(target, query, bufSize, v), "glGetnMapfv")
proc glGetnMapiv*(target: GLenum, query: GLenum, bufSize: GLsizei, v: ptr GLint): void =
  ## Return evaluator parameters
  ## Specifies the symbolic name of a map.
  ## Accepted values are
  ## GL_MAP1_COLOR_4,
  ## GL_MAP1_INDEX,
  ## GL_MAP1_NORMAL,
  ## GL_MAP1_TEXTURE_COORD_1,
  ## GL_MAP1_TEXTURE_COORD_2,
  ## GL_MAP1_TEXTURE_COORD_3,
  ## GL_MAP1_TEXTURE_COORD_4,
  ## GL_MAP1_VERTEX_3,
  ## GL_MAP1_VERTEX_4,
  ## GL_MAP2_COLOR_4,
  ## GL_MAP2_INDEX,
  ## GL_MAP2_NORMAL,
  ## GL_MAP2_TEXTURE_COORD_1,
  ## GL_MAP2_TEXTURE_COORD_2,
  ## GL_MAP2_TEXTURE_COORD_3,
  ## GL_MAP2_TEXTURE_COORD_4,
  ## GL_MAP2_VERTEX_3, and
  ## GL_MAP2_VERTEX_4.
  glCallTemplate(cglGetnMapiv(target, query, bufSize, v), "glGetnMapiv")
proc glGetnMinmax*(target: GLenum, reset: GLboolean, format: GLenum, `type`: GLenum, bufSize: GLsizei, values: pointer): void =
  ## Get minimum and maximum pixel values
  ## Must be
  ## GL_MINMAX.
  glCallTemplate(cglGetnMinmax(target, reset, format, `type`, bufSize, values), "glGetnMinmax")
proc glGetnPixelMapfv*(map: GLenum, bufSize: GLsizei, values: ptr GLfloat): void =
  ## Return the specified pixel map
  ## Specifies the name of the pixel map to return.
  ## Accepted values are
  ## GL_PIXEL_MAP_I_TO_I,
  ## GL_PIXEL_MAP_S_TO_S,
  ## GL_PIXEL_MAP_I_TO_R,
  ## GL_PIXEL_MAP_I_TO_G,
  ## GL_PIXEL_MAP_I_TO_B,
  ## GL_PIXEL_MAP_I_TO_A,
  ## GL_PIXEL_MAP_R_TO_R,
  ## GL_PIXEL_MAP_G_TO_G,
  ## GL_PIXEL_MAP_B_TO_B, and
  ## GL_PIXEL_MAP_A_TO_A.
  glCallTemplate(cglGetnPixelMapfv(map, bufSize, values), "glGetnPixelMapfv")
proc glGetnPixelMapuiv*(map: GLenum, bufSize: GLsizei, values: ptr GLuint): void =
  ## Return the specified pixel map
  ## Specifies the name of the pixel map to return.
  ## Accepted values are
  ## GL_PIXEL_MAP_I_TO_I,
  ## GL_PIXEL_MAP_S_TO_S,
  ## GL_PIXEL_MAP_I_TO_R,
  ## GL_PIXEL_MAP_I_TO_G,
  ## GL_PIXEL_MAP_I_TO_B,
  ## GL_PIXEL_MAP_I_TO_A,
  ## GL_PIXEL_MAP_R_TO_R,
  ## GL_PIXEL_MAP_G_TO_G,
  ## GL_PIXEL_MAP_B_TO_B, and
  ## GL_PIXEL_MAP_A_TO_A.
  glCallTemplate(cglGetnPixelMapuiv(map, bufSize, values), "glGetnPixelMapuiv")
proc glGetnPixelMapusv*(map: GLenum, bufSize: GLsizei, values: ptr GLushort): void =
  ## Return the specified pixel map
  ## Specifies the name of the pixel map to return.
  ## Accepted values are
  ## GL_PIXEL_MAP_I_TO_I,
  ## GL_PIXEL_MAP_S_TO_S,
  ## GL_PIXEL_MAP_I_TO_R,
  ## GL_PIXEL_MAP_I_TO_G,
  ## GL_PIXEL_MAP_I_TO_B,
  ## GL_PIXEL_MAP_I_TO_A,
  ## GL_PIXEL_MAP_R_TO_R,
  ## GL_PIXEL_MAP_G_TO_G,
  ## GL_PIXEL_MAP_B_TO_B, and
  ## GL_PIXEL_MAP_A_TO_A.
  glCallTemplate(cglGetnPixelMapusv(map, bufSize, values), "glGetnPixelMapusv")
proc glGetnPolygonStipple*(bufSize: GLsizei, pattern: ptr GLubyte): void =
  ## Return the polygon stipple pattern
  ## Returns the stipple pattern. The initial value is all 1's.
  glCallTemplate(cglGetnPolygonStipple(bufSize, pattern), "glGetnPolygonStipple")
proc glGetnSeparableFilter*(target: GLenum, format: GLenum, `type`: GLenum, rowBufSize: GLsizei, row: pointer, columnBufSize: GLsizei, column: pointer, span: pointer): void =
  ## Get separable convolution filter kernel images
  ## The separable filter to be retrieved.
  ## Must be
  ## GL_SEPARABLE_2D.
  glCallTemplate(cglGetnSeparableFilter(target, format, `type`, rowBufSize, row, columnBufSize, column, span), "glGetnSeparableFilter")
proc glGetnTexImage*(target: GLenum, level: GLint, format: GLenum, `type`: GLenum, bufSize: GLsizei, pixels: pointer): void =
  ## Return a texture image
  ## Specifies which texture is to be obtained.
  ## GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Zare accepted.
  glCallTemplate(cglGetnTexImage(target, level, format, `type`, bufSize, pixels), "glGetnTexImage")
proc glGetnUniformdv*(program: GLuint, location: GLint, bufSize: GLsizei, params: ptr GLdouble): void =
  ## Returns the value of a uniform variable
  ## Specifies the program object to be
  glCallTemplate(cglGetnUniformdv(program, location, bufSize, params), "glGetnUniformdv")
proc glGetnUniformfv*(program: GLuint, location: GLint, bufSize: GLsizei, params: ptr GLfloat): void =
  ## Returns the value of a uniform variable
  ## Specifies the program object to be
  glCallTemplate(cglGetnUniformfv(program, location, bufSize, params), "glGetnUniformfv")
proc glGetnUniformiv*(program: GLuint, location: GLint, bufSize: GLsizei, params: ptr GLint): void =
  ## Returns the value of a uniform variable
  ## Specifies the program object to be
  glCallTemplate(cglGetnUniformiv(program, location, bufSize, params), "glGetnUniformiv")
proc glGetnUniformuiv*(program: GLuint, location: GLint, bufSize: GLsizei, params: ptr GLuint): void =
  ## Returns the value of a uniform variable
  ## Specifies the program object to be
  glCallTemplate(cglGetnUniformuiv(program, location, bufSize, params), "glGetnUniformuiv")
proc glHint*(target: GLenum, mode: GLenum): void =
  ## Specify implementation-specific hints
  ## Specifies a symbolic constant indicating the behavior to be controlled.
  ## GL_FOG_HINT,
  ## GL_GENERATE_MIPMAP_HINT,
  ## GL_LINE_SMOOTH_HINT,
  ## GL_PERSPECTIVE_CORRECTION_HINT,
  ## GL_POINT_SMOOTH_HINT,
  ## GL_POLYGON_SMOOTH_HINT,
  ## GL_TEXTURE_COMPRESSION_HINT, and
  ## GL_FRAGMENT_SHADER_DERIVATIVE_HINTare accepted.
  glCallTemplate(cglHint(target, mode), "glHint")
proc glVertexAttribL3dv*(index: GLuint, v: ptr GLdouble): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribL3dv(index, v), "glVertexAttribL3dv")
proc glVertexAttribBinding*(attribindex: GLuint, bindingindex: GLuint): void =
  ## Associate a vertex attribute and a vertex buffer binding for a vertex array object
  ## Specifies the name of the vertex array object for
  ## glVertexArrayAttribBinding.
  glCallTemplate(cglVertexAttribBinding(attribindex, bindingindex), "glVertexAttribBinding")
proc glVertexAttrib4ubv*(index: GLuint, v: ptr GLubyte): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4ubv(index, v), "glVertexAttrib4ubv")
proc glInvalidateBufferData*(buffer: GLuint): void =
  ## Invalidate the content of a buffer object's data store
  ## The name of a buffer object whose data store to invalidate.
  glCallTemplate(cglInvalidateBufferData(buffer), "glInvalidateBufferData")
proc glInvalidateBufferSubData*(buffer: GLuint, offset: GLintptr, length: GLsizeiptr): void =
  ## Invalidate a region of a buffer object's data store
  ## The name of a buffer object, a subrange of whose data store to invalidate.
  glCallTemplate(cglInvalidateBufferSubData(buffer, offset, length), "glInvalidateBufferSubData")
proc glInvalidateFramebuffer*(target: GLenum, numAttachments: GLsizei, attachments: ptr GLenum): void =
  ## Invalidate the content of some or all of a framebuffer's attachments
  ## Specifies the target to which the framebuffer object is
  ## attached for
  ## glInvalidateFramebuffer.
  glCallTemplate(cglInvalidateFramebuffer(target, numAttachments, attachments), "glInvalidateFramebuffer")
proc glInvalidateNamedFramebufferData*(framebuffer: GLuint, numAttachments: GLsizei, attachments: ptr GLenum): void =
  ## Invalidate the content of some or all of a framebuffer's attachments
  ## Specifies the target to which the framebuffer object is
  ## attached for
  ## glInvalidateFramebuffer.
  glCallTemplate(cglInvalidateNamedFramebufferData(framebuffer, numAttachments, attachments), "glInvalidateNamedFramebufferData")
proc glInvalidateNamedFramebufferSubData*(framebuffer: GLuint, numAttachments: GLsizei, attachments: ptr GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void =
  ## Invalidate the content of some or all of a framebuffer's attachments
  ## Specifies the target to which the framebuffer object is
  ## attached for
  ## glInvalidateFramebuffer.
  glCallTemplate(cglInvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments, x, y, width, height), "glInvalidateNamedFramebufferSubData")
proc glInvalidateSubFramebuffer*(target: GLenum, numAttachments: GLsizei, attachments: ptr GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void =
  ## Invalidate the content of a region of some or all of a framebuffer's attachments
  ## Specifies the target to which the framebuffer object is
  ## attached for
  ## glInvalidateSubFramebuffer.
  glCallTemplate(cglInvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height), "glInvalidateSubFramebuffer")
proc glInvalidateTexImage*(texture: GLuint, level: GLint): void =
  ## Invalidate the entirety a texture image
  ## The name of a texture object to invalidate.
  glCallTemplate(cglInvalidateTexImage(texture, level), "glInvalidateTexImage")
proc glInvalidateTexSubImage*(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei): void =
  ## Invalidate a region of a texture image
  ## The name of a texture object a subregion of which to invalidate.
  glCallTemplate(cglInvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth), "glInvalidateTexSubImage")
proc glIsBuffer*(buffer: GLuint): GLboolean =
  ## Determine if a name corresponds to a buffer object
  ## Specifies a value that may be the name of a buffer object.
  glTypedCallTemplate(cglIsBuffer(buffer), "glIsBuffer")
proc glIsEnabled*(cap: GLenum): GLboolean =
  ## Test whether a capability is enabled
  ## Specifies a symbolic constant indicating a GL capability.
  glTypedCallTemplate(cglIsEnabled(cap), "glIsEnabled")
proc glIsEnabledi*(target: GLenum, index: GLuint): GLboolean =
  ## Test whether a capability is enabled
  ## Specifies a symbolic constant indicating a GL capability.
  glTypedCallTemplate(cglIsEnabledi(target, index), "glIsEnabledi")
proc glIsFramebuffer*(framebuffer: GLuint): GLboolean =
  ## Determine if a name corresponds to a framebuffer object
  ## Specifies a value that may be the name of a framebuffer object.
  glTypedCallTemplate(cglIsFramebuffer(framebuffer), "glIsFramebuffer")
proc glVertexAttribI2uiv*(index: GLuint, v: ptr GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI2uiv(index, v), "glVertexAttribI2uiv")
proc glIsProgram*(program: GLuint): GLboolean =
  ## Determines if a name corresponds to a program object
  glTypedCallTemplate(cglIsProgram(program), "glIsProgram")
proc glIsProgramPipeline*(pipeline: GLuint): GLboolean =
  ## Determine if a name corresponds to a program pipeline object
  ## Specifies a value that may be the name of a program pipeline object.
  glTypedCallTemplate(cglIsProgramPipeline(pipeline), "glIsProgramPipeline")
proc glIsQuery*(id: GLuint): GLboolean =
  ## Determine if a name corresponds to a query object
  ## Specifies a value that may be the name of a query object.
  glTypedCallTemplate(cglIsQuery(id), "glIsQuery")
proc glIsRenderbuffer*(renderbuffer: GLuint): GLboolean =
  ## Determine if a name corresponds to a renderbuffer object
  ## Specifies a value that may be the name of a renderbuffer object.
  glTypedCallTemplate(cglIsRenderbuffer(renderbuffer), "glIsRenderbuffer")
proc glIsSampler*(sampler: GLuint): GLboolean =
  ## Determine if a name corresponds to a sampler object
  ## Specifies a value that may be the name of a sampler object.
  glTypedCallTemplate(cglIsSampler(sampler), "glIsSampler")
proc glIsShader*(shader: GLuint): GLboolean =
  ## Determines if a name corresponds to a shader object
  glTypedCallTemplate(cglIsShader(shader), "glIsShader")
proc glIsSync*(sync: GLsync): GLboolean =
  ## Determine if a name corresponds to a sync object
  ## Specifies a value that may be the name of a sync object.
  glTypedCallTemplate(cglIsSync(sync), "glIsSync")
proc glIsTexture*(texture: GLuint): GLboolean =
  ## Determine if a name corresponds to a texture
  ## Specifies a value that may be the name of a texture.
  glTypedCallTemplate(cglIsTexture(texture), "glIsTexture")
proc glIsTransformFeedback*(id: GLuint): GLboolean =
  ## Determine if a name corresponds to a transform feedback object
  ## Specifies a value that may be the name of a transform feedback object.
  glTypedCallTemplate(cglIsTransformFeedback(id), "glIsTransformFeedback")
proc glIsVertexArray*(array: GLuint): GLboolean =
  ## Determine if a name corresponds to a vertex array object
  ## Specifies a value that may be the name of a vertex array object.
  glTypedCallTemplate(cglIsVertexArray(array), "glIsVertexArray")
proc glLightModelx*(pname: GLenum, param: GLfixed): void =
  ## Set the lighting model parameters
  ## Specifies a single-valued lighting model parameter.
  ## GL_LIGHT_MODEL_LOCAL_VIEWER,
  ## GL_LIGHT_MODEL_COLOR_CONTROL, and
  ## GL_LIGHT_MODEL_TWO_SIDEare accepted.
  glCallTemplate(cglLightModelx(pname, param), "glLightModelx")
proc glLightModelxv*(pname: GLenum, param: ptr GLfixed): void =
  ## Set the lighting model parameters
  ## Specifies a single-valued lighting model parameter.
  ## GL_LIGHT_MODEL_LOCAL_VIEWER,
  ## GL_LIGHT_MODEL_COLOR_CONTROL, and
  ## GL_LIGHT_MODEL_TWO_SIDEare accepted.
  glCallTemplate(cglLightModelxv(pname, param), "glLightModelxv")
proc glLightx*(light: GLenum, pname: GLenum, param: GLfixed): void =
  ## Set light source parameters
  ## Specifies a light.
  ## The number of lights depends on the implementation,
  ## but at least eight lights are supported.
  ## They are identified by symbolic names of the form GL_LIGHTi,
  ## where i ranges from 0 to the value of GL_MAX_LIGHTS- 1.
  glCallTemplate(cglLightx(light, pname, param), "glLightx")
proc glLightxv*(light: GLenum, pname: GLenum, params: ptr GLfixed): void =
  ## Set light source parameters
  ## Specifies a light.
  ## The number of lights depends on the implementation,
  ## but at least eight lights are supported.
  ## They are identified by symbolic names of the form GL_LIGHTi,
  ## where i ranges from 0 to the value of GL_MAX_LIGHTS- 1.
  glCallTemplate(cglLightxv(light, pname, params), "glLightxv")
proc glVertexAttribPointer*(index: GLuint, size: GLint, `type`: GLenum, normalized: GLboolean, stride: GLsizei, pointer: pointer): void =
  ## Define an array of generic vertex attribute data
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribPointer(index, size, `type`, normalized, stride, pointer), "glVertexAttribPointer")
proc glLineWidth*(width: GLfloat): void =
  ## Specify the width of rasterized lines
  ## Specifies the width of rasterized lines.
  ## The initial value is 1.
  glCallTemplate(cglLineWidth(width), "glLineWidth")
proc glLineWidthx*(width: GLfixed): void =
  ## Specify the width of rasterized lines
  ## Specifies the width of rasterized lines.
  ## The initial value is 1.
  glCallTemplate(cglLineWidthx(width), "glLineWidthx")
proc glLinkProgram*(program: GLuint): void =
  ## Links a program object
  glCallTemplate(cglLinkProgram(program), "glLinkProgram")
proc glVertexAttribI2ui*(index: GLuint, x: GLuint, y: GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI2ui(index, x, y), "glVertexAttribI2ui")
proc glVertexAttribI2iv*(index: GLuint, v: ptr GLint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI2iv(index, v), "glVertexAttribI2iv")
proc glLoadMatrixx*(m: ptr GLfixed): void =
  ## Replace the current matrix with the specified matrix
  ## Specifies a pointer to 16 consecutive values, which are used as the
  ## elements of a
  ##
  ## 4times4column-major matrix.
  glCallTemplate(cglLoadMatrixx(m), "glLoadMatrixx")
proc glVertexAttribL4d*(index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribL4d(index, x, y, z, w), "glVertexAttribL4d")
proc glVertexAttrib4Niv*(index: GLuint, v: ptr GLint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4Niv(index, v), "glVertexAttrib4Niv")
proc glLogicOp*(opcode: GLenum): void =
  ## Specify a logical pixel operation for color index rendering
  ## Specifies a symbolic constant that selects a logical operation.
  ## The following symbols are accepted:
  ## GL_CLEAR,
  ## GL_SET,
  ## GL_COPY,
  ## GL_COPY_INVERTED,
  ## GL_NOOP,
  ## GL_INVERT,
  ## GL_AND,
  ## GL_NAND,
  ## GL_OR,
  ## GL_NOR,
  ## GL_XOR,
  ## GL_EQUIV,
  ## GL_AND_REVERSE,
  ## GL_AND_INVERTED,
  ## GL_OR_REVERSE, and
  ## GL_OR_INVERTED. The initial value is GL_COPY.
  glCallTemplate(cglLogicOp(opcode), "glLogicOp")
proc glMapBuffer*(target: GLenum, access: GLenum): pointer =
  ## Map a buffer object's data store
  ## Specifies the target buffer object being mapped.
  ## The symbolic constant must be
  ## GL_ARRAY_BUFFER,
  ## GL_ELEMENT_ARRAY_BUFFER,
  ## GL_PIXEL_PACK_BUFFER, or
  ## GL_PIXEL_UNPACK_BUFFER.
  glTypedCallTemplate(cglMapBuffer(target, access), "glMapBuffer")
proc glMapBufferRange*(target: GLenum, offset: GLintptr, length: GLsizeiptr, access: GLbitfield): pointer =
  ## Map all or part of a buffer object's data store into the client's address space
  ## Specifies the target to which the buffer object is bound
  ## for glMapBufferRange, which must be
  ## one of the buffer binding targets in the following
  ## table:
  glTypedCallTemplate(cglMapBufferRange(target, offset, length, access), "glMapBufferRange")
proc glVertexAttribL2dv*(index: GLuint, v: ptr GLdouble): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribL2dv(index, v), "glVertexAttribL2dv")
proc glVertexAttribL2d*(index: GLuint, x: GLdouble, y: GLdouble): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribL2d(index, x, y), "glVertexAttribL2d")
proc glMapNamedBuffer*(buffer: GLuint, access: GLenum): pointer =
  ## Map a buffer object's data store
  ## Specifies the target buffer object being mapped.
  ## The symbolic constant must be
  ## GL_ARRAY_BUFFER,
  ## GL_ELEMENT_ARRAY_BUFFER,
  ## GL_PIXEL_PACK_BUFFER, or
  ## GL_PIXEL_UNPACK_BUFFER.
  glTypedCallTemplate(cglMapNamedBuffer(buffer, access), "glMapNamedBuffer")
proc glMapNamedBufferRange*(buffer: GLuint, offset: GLintptr, length: GLsizeiptr, access: GLbitfield): pointer =
  ## Map all or part of a buffer object's data store into the client's address space
  ## Specifies the target to which the buffer object is bound
  ## for glMapBufferRange, which must be
  ## one of the buffer binding targets in the following
  ## table:
  glTypedCallTemplate(cglMapNamedBufferRange(buffer, offset, length, access), "glMapNamedBufferRange")
proc glVertexAttribP4uiv*(index: GLuint, `type`: GLenum, normalized: GLboolean, value: ptr GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribP4uiv(index, `type`, normalized, value), "glVertexAttribP4uiv")
proc glVertexAttribP4ui*(index: GLuint, `type`: GLenum, normalized: GLboolean, value: GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribP4ui(index, `type`, normalized, value), "glVertexAttribP4ui")
proc glVertexAttribP3uiv*(index: GLuint, `type`: GLenum, normalized: GLboolean, value: ptr GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribP3uiv(index, `type`, normalized, value), "glVertexAttribP3uiv")
proc glMaterialx*(face: GLenum, pname: GLenum, param: GLfixed): void =
  ## Specify material parameters for the lighting model
  ## Specifies which face or faces are being updated.
  ## Must be one of
  ## GL_FRONT,
  ## GL_BACK, or
  ## GL_FRONT_AND_BACK.
  glCallTemplate(cglMaterialx(face, pname, param), "glMaterialx")
proc glMaterialxv*(face: GLenum, pname: GLenum, param: ptr GLfixed): void =
  ## Specify material parameters for the lighting model
  ## Specifies which face or faces are being updated.
  ## Must be one of
  ## GL_FRONT,
  ## GL_BACK, or
  ## GL_FRONT_AND_BACK.
  glCallTemplate(cglMaterialxv(face, pname, param), "glMaterialxv")
proc glMemoryBarrier*(barriers: GLbitfield): void =
  ## Defines a barrier ordering memory transactions
  ## Specifies the barriers to insert.
  glCallTemplate(cglMemoryBarrier(barriers), "glMemoryBarrier")
proc glMemoryBarrierByRegion*(barriers: GLbitfield): void =
  ## Defines a barrier ordering memory transactions
  ## Specifies the barriers to insert.
  glCallTemplate(cglMemoryBarrierByRegion(barriers), "glMemoryBarrierByRegion")
proc glMinSampleShading*(value: GLfloat): void =
  ## Specifies minimum rate at which sample shaing takes place
  ## Specifies the rate at which samples are shaded within each covered pixel.
  glCallTemplate(cglMinSampleShading(value), "glMinSampleShading")
proc glVertexAttribI2i*(index: GLuint, x: GLint, y: GLint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI2i(index, x, y), "glVertexAttribI2i")
proc glMultMatrixx*(m: ptr GLfixed): void =
  ## Multiply the current matrix with the specified matrix
  ## Points to 16 consecutive values that are used as the elements of
  ## a
  ##
  ## 4times4column-major matrix.
  glCallTemplate(cglMultMatrixx(m), "glMultMatrixx")
proc glVertexAttrib4Nbv*(index: GLuint, v: ptr GLbyte): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4Nbv(index, v), "glVertexAttrib4Nbv")
proc glMultiDrawArrays*(mode: GLenum, first: ptr GLint, count: ptr GLsizei, drawcount: GLsizei): void =
  ## Render multiple sets of primitives from array data
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_QUAD_STRIP,
  ## GL_QUADS,
  ## and GL_POLYGONare accepted.
  glCallTemplate(cglMultiDrawArrays(mode, first, count, drawcount), "glMultiDrawArrays")
proc glMultiDrawArraysIndirect*(mode: GLenum, indirect: pointer, drawcount: GLsizei, stride: GLsizei): void =
  ## Render multiple sets of primitives from array data, taking parameters from memory
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_LINE_STRIP_ADJACENCY,
  ## GL_LINES_ADJACENCY,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_TRIANGLE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCY, and
  ## GL_PATCHESare accepted.
  glCallTemplate(cglMultiDrawArraysIndirect(mode, indirect, drawcount, stride), "glMultiDrawArraysIndirect")
proc glMultiDrawArraysIndirectCount*(mode: GLenum, indirect: pointer, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei): void =
  ## Render multiple sets of primitives from array data, taking parameters from memory
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_LINE_STRIP_ADJACENCY,
  ## GL_LINES_ADJACENCY,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_TRIANGLE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCY, and
  ## GL_PATCHESare accepted.
  glCallTemplate(cglMultiDrawArraysIndirectCount(mode, indirect, drawcount, maxdrawcount, stride), "glMultiDrawArraysIndirectCount")
proc glMultiDrawElements*(mode: GLenum, count: ptr GLsizei, `type`: GLenum, indices: ptr pointer, drawcount: GLsizei): void =
  ## Render multiple sets of primitives by specifying indices of array data elements
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_QUAD_STRIP,
  ## GL_QUADS,
  ## and GL_POLYGONare accepted.
  glCallTemplate(cglMultiDrawElements(mode, count, `type`, indices, drawcount), "glMultiDrawElements")
proc glMultiDrawElementsBaseVertex*(mode: GLenum, count: ptr GLsizei, `type`: GLenum, indices: ptr pointer, drawcount: GLsizei, basevertex: ptr GLint): void =
  ## Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_LINE_STRIP_ADJACENCY,
  ## GL_LINES_ADJACENCY,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_TRIANGLE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCYand GL_PATCHESare accepted.
  glCallTemplate(cglMultiDrawElementsBaseVertex(mode, count, `type`, indices, drawcount, basevertex), "glMultiDrawElementsBaseVertex")
proc glMultiDrawElementsIndirect*(mode: GLenum, `type`: GLenum, indirect: pointer, drawcount: GLsizei, stride: GLsizei): void =
  ## Render indexed primitives from array data, taking parameters from memory
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_LINE_STRIP_ADJACENCY,
  ## GL_LINES_ADJACENCY,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_TRIANGLE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCY, and
  ## GL_PATCHESare accepted.
  glCallTemplate(cglMultiDrawElementsIndirect(mode, `type`, indirect, drawcount, stride), "glMultiDrawElementsIndirect")
proc glMultiDrawElementsIndirectCount*(mode: GLenum, `type`: GLenum, indirect: pointer, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei): void =
  ## Render indexed primitives from array data, taking parameters from memory
  ## Specifies what kind of primitives to render.
  ## Symbolic constants
  ## GL_POINTS,
  ## GL_LINE_STRIP,
  ## GL_LINE_LOOP,
  ## GL_LINES,
  ## GL_LINE_STRIP_ADJACENCY,
  ## GL_LINES_ADJACENCY,
  ## GL_TRIANGLE_STRIP,
  ## GL_TRIANGLE_FAN,
  ## GL_TRIANGLES,
  ## GL_TRIANGLE_STRIP_ADJACENCY,
  ## GL_TRIANGLES_ADJACENCY, and
  ## GL_PATCHESare accepted.
  glCallTemplate(cglMultiDrawElementsIndirectCount(mode, `type`, indirect, drawcount, maxdrawcount, stride), "glMultiDrawElementsIndirectCount")
proc glVertexAttrib4s*(index: GLuint, x: GLshort, y: GLshort, z: GLshort, w: GLshort): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4s(index, x, y, z, w), "glVertexAttrib4s")
proc glVertexAttrib4iv*(index: GLuint, v: ptr GLint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4iv(index, v), "glVertexAttrib4iv")
proc glVertexAttrib4fv*(index: GLuint, v: ptr GLfloat): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4fv(index, v), "glVertexAttrib4fv")
proc glVertexAttrib4f*(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4f(index, x, y, z, w), "glVertexAttrib4f")
proc glVertexAttrib4dv*(index: GLuint, v: ptr GLdouble): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4dv(index, v), "glVertexAttrib4dv")
proc glVertexAttrib4d*(index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4d(index, x, y, z, w), "glVertexAttrib4d")
proc glVertexAttrib4bv*(index: GLuint, v: ptr GLbyte): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4bv(index, v), "glVertexAttrib4bv")
proc glVertexAttrib4Nusv*(index: GLuint, v: ptr GLushort): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4Nusv(index, v), "glVertexAttrib4Nusv")
proc glVertexAttrib4Nuiv*(index: GLuint, v: ptr GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4Nuiv(index, v), "glVertexAttrib4Nuiv")
proc glVertexAttrib4Nubv*(index: GLuint, v: ptr GLubyte): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4Nubv(index, v), "glVertexAttrib4Nubv")
proc glVertexAttrib4Nub*(index: GLuint, x: GLubyte, y: GLubyte, z: GLubyte, w: GLubyte): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4Nub(index, x, y, z, w), "glVertexAttrib4Nub")
proc glVertexAttrib4Nsv*(index: GLuint, v: ptr GLshort): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4Nsv(index, v), "glVertexAttrib4Nsv")
proc glMultiTexCoord4x*(texture: GLenum, s: GLfixed, t: GLfixed, r: GLfixed, q: GLfixed): void =
  ## Set the current texture coordinates
  ## Specifies the texture unit whose coordinates should be modified. The number
  ## of texture units is implementation dependent, but must be at least
  ## two. Symbolic constant must be one of
  ## GL_TEXTUREi,
  ## where i ranges from 0 to GL_MAX_TEXTURE_COORDS- 1,
  ## which is an implementation-dependent value.
  glCallTemplate(cglMultiTexCoord4x(texture, s, t, r, q), "glMultiTexCoord4x")
proc glMultiTexCoordP1ui*(texture: GLenum, `type`: GLenum, coords: GLuint): void =
  ## Set the current texture coordinates
  ## Specifies the texture unit whose coordinates should be modified. The number
  ## of texture units is implementation dependent, but must be at least
  ## two. Symbolic constant must be one of
  ## GL_TEXTUREi,
  ## where i ranges from 0 to GL_MAX_TEXTURE_COORDS- 1,
  ## which is an implementation-dependent value.
  glCallTemplate(cglMultiTexCoordP1ui(texture, `type`, coords), "glMultiTexCoordP1ui")
proc glMultiTexCoordP1uiv*(texture: GLenum, `type`: GLenum, coords: ptr GLuint): void =
  ## Set the current texture coordinates
  ## Specifies the texture unit whose coordinates should be modified. The number
  ## of texture units is implementation dependent, but must be at least
  ## two. Symbolic constant must be one of
  ## GL_TEXTUREi,
  ## where i ranges from 0 to GL_MAX_TEXTURE_COORDS- 1,
  ## which is an implementation-dependent value.
  glCallTemplate(cglMultiTexCoordP1uiv(texture, `type`, coords), "glMultiTexCoordP1uiv")
proc glMultiTexCoordP2ui*(texture: GLenum, `type`: GLenum, coords: GLuint): void =
  ## Set the current texture coordinates
  ## Specifies the texture unit whose coordinates should be modified. The number
  ## of texture units is implementation dependent, but must be at least
  ## two. Symbolic constant must be one of
  ## GL_TEXTUREi,
  ## where i ranges from 0 to GL_MAX_TEXTURE_COORDS- 1,
  ## which is an implementation-dependent value.
  glCallTemplate(cglMultiTexCoordP2ui(texture, `type`, coords), "glMultiTexCoordP2ui")
proc glMultiTexCoordP2uiv*(texture: GLenum, `type`: GLenum, coords: ptr GLuint): void =
  ## Set the current texture coordinates
  ## Specifies the texture unit whose coordinates should be modified. The number
  ## of texture units is implementation dependent, but must be at least
  ## two. Symbolic constant must be one of
  ## GL_TEXTUREi,
  ## where i ranges from 0 to GL_MAX_TEXTURE_COORDS- 1,
  ## which is an implementation-dependent value.
  glCallTemplate(cglMultiTexCoordP2uiv(texture, `type`, coords), "glMultiTexCoordP2uiv")
proc glMultiTexCoordP3ui*(texture: GLenum, `type`: GLenum, coords: GLuint): void =
  ## Set the current texture coordinates
  ## Specifies the texture unit whose coordinates should be modified. The number
  ## of texture units is implementation dependent, but must be at least
  ## two. Symbolic constant must be one of
  ## GL_TEXTUREi,
  ## where i ranges from 0 to GL_MAX_TEXTURE_COORDS- 1,
  ## which is an implementation-dependent value.
  glCallTemplate(cglMultiTexCoordP3ui(texture, `type`, coords), "glMultiTexCoordP3ui")
proc glMultiTexCoordP3uiv*(texture: GLenum, `type`: GLenum, coords: ptr GLuint): void =
  ## Set the current texture coordinates
  ## Specifies the texture unit whose coordinates should be modified. The number
  ## of texture units is implementation dependent, but must be at least
  ## two. Symbolic constant must be one of
  ## GL_TEXTUREi,
  ## where i ranges from 0 to GL_MAX_TEXTURE_COORDS- 1,
  ## which is an implementation-dependent value.
  glCallTemplate(cglMultiTexCoordP3uiv(texture, `type`, coords), "glMultiTexCoordP3uiv")
proc glMultiTexCoordP4ui*(texture: GLenum, `type`: GLenum, coords: GLuint): void =
  ## Set the current texture coordinates
  ## Specifies the texture unit whose coordinates should be modified. The number
  ## of texture units is implementation dependent, but must be at least
  ## two. Symbolic constant must be one of
  ## GL_TEXTUREi,
  ## where i ranges from 0 to GL_MAX_TEXTURE_COORDS- 1,
  ## which is an implementation-dependent value.
  glCallTemplate(cglMultiTexCoordP4ui(texture, `type`, coords), "glMultiTexCoordP4ui")
proc glMultiTexCoordP4uiv*(texture: GLenum, `type`: GLenum, coords: ptr GLuint): void =
  ## Set the current texture coordinates
  ## Specifies the texture unit whose coordinates should be modified. The number
  ## of texture units is implementation dependent, but must be at least
  ## two. Symbolic constant must be one of
  ## GL_TEXTUREi,
  ## where i ranges from 0 to GL_MAX_TEXTURE_COORDS- 1,
  ## which is an implementation-dependent value.
  glCallTemplate(cglMultiTexCoordP4uiv(texture, `type`, coords), "glMultiTexCoordP4uiv")
proc glNamedBufferData*(buffer: GLuint, size: GLsizeiptr, data: pointer, usage: GLenum): void =
  ## Creates and initializes a buffer object's data store
  ## Specifies the target buffer object.
  ## The symbolic constant must be GL_ARRAY_BUFFER,
  ## GL_ELEMENT_ARRAY_BUFFER,
  ## GL_PIXEL_PACK_BUFFER, or
  ## GL_PIXEL_UNPACK_BUFFER.
  glCallTemplate(cglNamedBufferData(buffer, size, data, usage), "glNamedBufferData")
proc glNamedBufferStorage*(buffer: GLuint, size: GLsizeiptr, data: pointer, flags: GLbitfield): void =
  ## Creates and initializes a buffer object's immutable data
  ## store
  ## Specifies the target to which the buffer object is bound for
  ## glBufferStorage, which must be one of the
  ## buffer binding targets in the following table:
  glCallTemplate(cglNamedBufferStorage(buffer, size, data, flags), "glNamedBufferStorage")
proc glNamedBufferSubData*(buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: pointer): void =
  ## Updates a subset of a buffer object's data store
  ## Specifies the target buffer object.
  ## The symbolic constant must be GL_ARRAY_BUFFER,
  ## GL_ELEMENT_ARRAY_BUFFER,
  ## GL_PIXEL_PACK_BUFFER, or
  ## GL_PIXEL_UNPACK_BUFFER.
  glCallTemplate(cglNamedBufferSubData(buffer, offset, size, data), "glNamedBufferSubData")
proc glNamedFramebufferDrawBuffer*(framebuffer: GLuint, buf: GLenum): void =
  ## Specify which color buffers are to be drawn into
  ## Specifies up to four color buffers to be drawn into.
  ## Symbolic constants
  ## GL_NONE,
  ## GL_FRONT_LEFT,
  ## GL_FRONT_RIGHT,
  ## GL_BACK_LEFT,
  ## GL_BACK_RIGHT,
  ## GL_FRONT,
  ## GL_BACK,
  ## GL_LEFT,
  ## GL_RIGHT,
  ## GL_FRONT_AND_BACK, and
  ## GL_AUXi,
  ## where iis between 0 and the value of GL_AUX_BUFFERSminus 1,
  ## are accepted.  (GL_AUX_BUFFERSis not the upper limit; use glGetto query the number of available aux buffers.)
  ## The initial value is GL_FRONTfor single-buffered contexts,
  ## and GL_BACKfor double-buffered contexts.
  glCallTemplate(cglNamedFramebufferDrawBuffer(framebuffer, buf), "glNamedFramebufferDrawBuffer")
proc glNamedFramebufferDrawBuffers*(framebuffer: GLuint, n: GLsizei, bufs: ptr GLenum): void =
  ## Specifies a list of color buffers to be drawn into
  ## Specifies the number of buffers in
  glCallTemplate(cglNamedFramebufferDrawBuffers(framebuffer, n, bufs), "glNamedFramebufferDrawBuffers")
proc glNamedFramebufferParameteri*(framebuffer: GLuint, pname: GLenum, param: GLint): void =
  ## Set a named parameter of a framebuffer object
  ## Specifies the target to which the framebuffer is bound
  ## for glFramebufferParameteri.
  glCallTemplate(cglNamedFramebufferParameteri(framebuffer, pname, param), "glNamedFramebufferParameteri")
proc glNamedFramebufferReadBuffer*(framebuffer: GLuint, src: GLenum): void =
  ## Select a color buffer source for pixels
  ## Specifies a color buffer.
  ## Accepted values are
  ## GL_FRONT_LEFT,
  ## GL_FRONT_RIGHT,
  ## GL_BACK_LEFT,
  ## GL_BACK_RIGHT,
  ## GL_FRONT,
  ## GL_BACK,
  ## GL_LEFT,
  ## GL_RIGHT, and
  ## GL_AUXi,
  ## where iis between 0 and the value of GL_AUX_BUFFERSminus 1.
  glCallTemplate(cglNamedFramebufferReadBuffer(framebuffer, src), "glNamedFramebufferReadBuffer")
proc glNamedFramebufferRenderbuffer*(framebuffer: GLuint, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint): void =
  ## Attach a renderbuffer as a logical buffer of a framebuffer object
  ## Specifies the target to which the framebuffer is bound
  ## for glFramebufferRenderbuffer.
  glCallTemplate(cglNamedFramebufferRenderbuffer(framebuffer, attachment, renderbuffertarget, renderbuffer), "glNamedFramebufferRenderbuffer")
proc glNamedFramebufferTexture*(framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint): void =
  ## Attach a level of a texture object as a logical buffer of a framebuffer object
  ## Specifies the target to which the framebuffer is bound
  ## for all commands exceptglNamedFramebufferTexture.
  glCallTemplate(cglNamedFramebufferTexture(framebuffer, attachment, texture, level), "glNamedFramebufferTexture")
proc glNamedFramebufferTextureLayer*(framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint): void =
  ## Attach a single layer of a texture object as a logical buffer of a framebuffer object
  ## Specifies the target to which the framebuffer is bound
  ## for glFramebufferTextureLayer.
  glCallTemplate(cglNamedFramebufferTextureLayer(framebuffer, attachment, texture, level, layer), "glNamedFramebufferTextureLayer")
proc glNamedRenderbufferStorage*(renderbuffer: GLuint, internalformat: GLenum, width: GLsizei, height: GLsizei): void =
  ## Establish data storage, format and dimensions of a
  ## renderbuffer object's image
  ## Specifies a binding target of the allocation for
  ## glRenderbufferStoragefunction. Must be
  glCallTemplate(cglNamedRenderbufferStorage(renderbuffer, internalformat, width, height), "glNamedRenderbufferStorage")
proc glNamedRenderbufferStorageMultisample*(renderbuffer: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void =
  ## Establish data storage, format, dimensions and sample count of
  ## a renderbuffer object's image
  ## Specifies a binding target of the allocation for
  ## glRenderbufferStorageMultisamplefunction. Must
  glCallTemplate(cglNamedRenderbufferStorageMultisample(renderbuffer, samples, internalformat, width, height), "glNamedRenderbufferStorageMultisample")
proc glVertexAttrib2s*(index: GLuint, x: GLshort, y: GLshort): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib2s(index, x, y), "glVertexAttrib2s")
proc glNormal3x*(nx: GLfixed, ny: GLfixed, nz: GLfixed): void =
  ## Set the current normal vector
  ## Specify the
  ## x,
  ## y,
  ## and
  ## zcoordinates of the new current normal.
  ## The initial value of the current normal is the unit vector, (0, 0, 1).
  glCallTemplate(cglNormal3x(nx, ny, nz), "glNormal3x")
proc glNormalP3ui*(`type`: GLenum, coords: GLuint): void =
  ## Set the current normal vector
  ## Specify the
  ## x,
  ## y,
  ## and
  ## zcoordinates of the new current normal.
  ## The initial value of the current normal is the unit vector, (0, 0, 1).
  glCallTemplate(cglNormalP3ui(`type`, coords), "glNormalP3ui")
proc glNormalP3uiv*(`type`: GLenum, coords: ptr GLuint): void =
  ## Set the current normal vector
  ## Specify the
  ## x,
  ## y,
  ## and
  ## zcoordinates of the new current normal.
  ## The initial value of the current normal is the unit vector, (0, 0, 1).
  glCallTemplate(cglNormalP3uiv(`type`, coords), "glNormalP3uiv")
proc glVertexAttrib4usv*(index: GLuint, v: ptr GLushort): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4usv(index, v), "glVertexAttrib4usv")
proc glObjectLabel*(identifier: GLenum, name: GLuint, length: GLsizei, label: cstring): void =
  ## Label a named object identified within a namespace
  ## The namespace from which the name of the object is allocated.
  glCallTemplate(cglObjectLabel(identifier, name, length, label), "glObjectLabel")
proc glObjectPtrLabel*(`ptr`: pointer, length: GLsizei, label: cstring): void =
  ## Label a a sync object identified by a pointer
  ## A pointer identifying a sync object.
  glCallTemplate(cglObjectPtrLabel(`ptr`, length, label), "glObjectPtrLabel")
proc glVertexAttribI1uiv*(index: GLuint, v: ptr GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI1uiv(index, v), "glVertexAttribI1uiv")
proc glOrthof*(l: GLfloat, r: GLfloat, b: GLfloat, t: GLfloat, n: GLfloat, f: GLfloat): void =
  ## Multiply the current matrix with an orthographic matrix
  ## Specify the coordinates for the left and right vertical clipping planes.
  glCallTemplate(cglOrthof(l, r, b, t, n, f), "glOrthof")
proc glOrthox*(l: GLfixed, r: GLfixed, b: GLfixed, t: GLfixed, n: GLfixed, f: GLfixed): void =
  ## Multiply the current matrix with an orthographic matrix
  ## Specify the coordinates for the left and right vertical clipping planes.
  glCallTemplate(cglOrthox(l, r, b, t, n, f), "glOrthox")
proc glPatchParameterfv*(pname: GLenum, values: ptr GLfloat): void =
  ## Specifies the parameters for patch primitives
  ## Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES,
  ## GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVELare accepted.
  glCallTemplate(cglPatchParameterfv(pname, values), "glPatchParameterfv")
proc glPatchParameteri*(pname: GLenum, value: GLint): void =
  ## Specifies the parameters for patch primitives
  ## Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICESis accepted.
  glCallTemplate(cglPatchParameteri(pname, value), "glPatchParameteri")
proc glPauseTransformFeedback*(): void =
  ## Pause transform feedback operations
  ## glPauseTransformFeedbackpauses transform feedback operations on the currently active transform feedback
  ## object. When transform feedback operations are paused, transform feedback is still considered active and changing most
  ## transform feedback state related to the object results in an error. However, a new transform feedback object may be bound
  ## while transform feedback is paused.
  glCallTemplate(cglPauseTransformFeedback(), "glPauseTransformFeedback")
proc glVertexAttribI4uiv*(index: GLuint, v: ptr GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI4uiv(index, v), "glVertexAttribI4uiv")
proc glVertexAttribI4ui*(index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI4ui(index, x, y, z, w), "glVertexAttribI4ui")
proc glPixelStoref*(pname: GLenum, param: GLfloat): void =
  ## Set pixel storage modes
  ## Specifies the symbolic name of the parameter to be set.
  ## Six values affect the packing of pixel data into memory:
  ## GL_PACK_SWAP_BYTES,
  ## GL_PACK_LSB_FIRST,
  ## GL_PACK_ROW_LENGTH,
  ## GL_PACK_IMAGE_HEIGHT,
  ## GL_PACK_SKIP_PIXELS,
  ## GL_PACK_SKIP_ROWS,
  ## GL_PACK_SKIP_IMAGES, and
  ## GL_PACK_ALIGNMENT.
  ## Six more affect the unpacking of pixel data frommemory:
  ## GL_UNPACK_SWAP_BYTES,
  ## GL_UNPACK_LSB_FIRST,
  ## GL_UNPACK_ROW_LENGTH,
  ## GL_UNPACK_IMAGE_HEIGHT,
  ## GL_UNPACK_SKIP_PIXELS,
  ## GL_UNPACK_SKIP_ROWS,
  ## GL_UNPACK_SKIP_IMAGES, and
  ## GL_UNPACK_ALIGNMENT.
  glCallTemplate(cglPixelStoref(pname, param), "glPixelStoref")
proc glPixelStorei*(pname: GLenum, param: GLint): void =
  ## Set pixel storage modes
  ## Specifies the symbolic name of the parameter to be set.
  ## Four values affect the packing of pixel data into memory:
  ## GL_PACK_ROW_LENGTH,
  ## GL_PACK_SKIP_PIXELS,
  ## GL_PACK_SKIP_ROWS, and
  ## GL_PACK_ALIGNMENT.
  ## Six more affect the unpacking of pixel data frommemory:
  ## GL_UNPACK_ROW_LENGTH,
  ## GL_UNPACK_IMAGE_HEIGHT,
  ## GL_UNPACK_SKIP_PIXELS,
  ## GL_UNPACK_SKIP_ROWS,
  ## GL_UNPACK_SKIP_IMAGES, and
  ## GL_UNPACK_ALIGNMENT.
  glCallTemplate(cglPixelStorei(pname, param), "glPixelStorei")
proc glVertexAttribI4usv*(index: GLuint, v: ptr GLushort): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI4usv(index, v), "glVertexAttribI4usv")
proc glPointParameterf*(pname: GLenum, param: GLfloat): void =
  ## Specify point parameters
  ## Specifies a single-valued point parameter.
  ## GL_POINT_SIZE_MIN,
  ## GL_POINT_SIZE_MAX,
  ## GL_POINT_FADE_THRESHOLD_SIZE, and
  ## GL_POINT_SPRITE_COORD_ORIGINare accepted.
  glCallTemplate(cglPointParameterf(pname, param), "glPointParameterf")
proc glPointParameterfv*(pname: GLenum, params: ptr GLfloat): void =
  ## Specify point parameters
  ## Specifies a single-valued point parameter.
  ## GL_POINT_SIZE_MIN,
  ## GL_POINT_SIZE_MAX,
  ## GL_POINT_FADE_THRESHOLD_SIZE, and
  ## GL_POINT_SPRITE_COORD_ORIGINare accepted.
  glCallTemplate(cglPointParameterfv(pname, params), "glPointParameterfv")
proc glPointParameteri*(pname: GLenum, param: GLint): void =
  ## Specify point parameters
  ## Specifies a single-valued point parameter.
  ## GL_POINT_SIZE_MIN,
  ## GL_POINT_SIZE_MAX,
  ## GL_POINT_FADE_THRESHOLD_SIZE, and
  ## GL_POINT_SPRITE_COORD_ORIGINare accepted.
  glCallTemplate(cglPointParameteri(pname, param), "glPointParameteri")
proc glPointParameteriv*(pname: GLenum, params: ptr GLint): void =
  ## Specify point parameters
  ## Specifies a single-valued point parameter.
  ## GL_POINT_SIZE_MIN,
  ## GL_POINT_SIZE_MAX,
  ## GL_POINT_FADE_THRESHOLD_SIZE, and
  ## GL_POINT_SPRITE_COORD_ORIGINare accepted.
  glCallTemplate(cglPointParameteriv(pname, params), "glPointParameteriv")
proc glPointParameterx*(pname: GLenum, param: GLfixed): void =
  ## Specify point parameters
  ## Specifies a single-valued point parameter.
  ## GL_POINT_SIZE_MIN,
  ## GL_POINT_SIZE_MAX,
  ## GL_POINT_FADE_THRESHOLD_SIZE, and
  ## GL_POINT_SPRITE_COORD_ORIGINare accepted.
  glCallTemplate(cglPointParameterx(pname, param), "glPointParameterx")
proc glPointParameterxv*(pname: GLenum, params: ptr GLfixed): void =
  ## Specify point parameters
  ## Specifies a single-valued point parameter.
  ## GL_POINT_SIZE_MIN,
  ## GL_POINT_SIZE_MAX,
  ## GL_POINT_FADE_THRESHOLD_SIZE, and
  ## GL_POINT_SPRITE_COORD_ORIGINare accepted.
  glCallTemplate(cglPointParameterxv(pname, params), "glPointParameterxv")
proc glPointSize*(size: GLfloat): void =
  ## Specify the diameter of rasterized points
  ## Specifies the diameter of rasterized points.
  ## The initial value is 1.
  glCallTemplate(cglPointSize(size), "glPointSize")
proc glPointSizex*(size: GLfixed): void =
  ## Specify the diameter of rasterized points
  ## Specifies the diameter of rasterized points.
  ## The initial value is 1.
  glCallTemplate(cglPointSizex(size), "glPointSizex")
proc glPolygonMode*(face: GLenum, mode: GLenum): void =
  ## Select a polygon rasterization mode
  ## Specifies the polygons that modeapplies to.
  ## Must be
  ## GL_FRONTfor front-facing polygons,
  ## GL_BACKfor back-facing polygons,
  ## or GL_FRONT_AND_BACKfor front- and back-facing polygons.
  glCallTemplate(cglPolygonMode(face, mode), "glPolygonMode")
proc glPolygonOffset*(factor: GLfloat, units: GLfloat): void =
  ## Set the scale and units used to calculate depth values
  ## Specifies a scale factor that is used to create a variable
  ## depth offset for each polygon. The initial value is 0.
  glCallTemplate(cglPolygonOffset(factor, units), "glPolygonOffset")
proc glPolygonOffsetClamp*(factor: GLfloat, units: GLfloat, clamp: GLfloat): void =
  ## Set the scale and units used to calculate depth values
  ## Specifies a scale factor that is used to create a variable
  ## depth offset for each polygon. The initial value is 0.
  glCallTemplate(cglPolygonOffsetClamp(factor, units, clamp), "glPolygonOffsetClamp")
proc glPolygonOffsetx*(factor: GLfixed, units: GLfixed): void =
  ## Set the scale and units used to calculate depth values
  ## Specifies a scale factor that is used to create a variable
  ## depth offset for each polygon. The initial value is 0.
  glCallTemplate(cglPolygonOffsetx(factor, units), "glPolygonOffsetx")
proc glVertexAttribP3ui*(index: GLuint, `type`: GLenum, normalized: GLboolean, value: GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribP3ui(index, `type`, normalized, value), "glVertexAttribP3ui")
proc glVertexAttribL3d*(index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribL3d(index, x, y, z), "glVertexAttribL3d")
proc glPopDebugGroup*(): void =
  ## Pop the active debug group
  ## glPopDebugGrouppops the active debug group.
  ## After popping a debug group, the GL will also generate a debug
  ## output message describing its cause based on the messagestring, the source source, and an ID idsubmitted to the corresponding glPushDebugGroupcommand. GL_DEBUG_TYPE_PUSH_GROUPand GL_DEBUG_TYPE_POP_GROUPshare a single namespace for message id.
  ## severityhas the value GL_DEBUG_SEVERITY_NOTIFICATION. The typehas the value GL_DEBUG_TYPE_POP_GROUP. Popping a debug group restores
  ## the debug output volume control of the parent debug group.
  glCallTemplate(cglPopDebugGroup(), "glPopDebugGroup")
proc glPrimitiveBoundingBox*(minX: GLfloat, minY: GLfloat, minZ: GLfloat, minW: GLfloat, maxX: GLfloat, maxY: GLfloat, maxZ: GLfloat, maxW: GLfloat): void =
  ## Set the bounding box for a primitive
  ## Specify the minimum clip space cooridnate of the bounding box. The initial value is (-1, -1, -1, -1).
  glCallTemplate(cglPrimitiveBoundingBox(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW), "glPrimitiveBoundingBox")
proc glPrimitiveRestartIndex*(index: GLuint): void =
  ## Specify the primitive restart index
  ## Specifies the value to be interpreted as the primitive restart index.
  glCallTemplate(cglPrimitiveRestartIndex(index), "glPrimitiveRestartIndex")
proc glProgramBinary*(program: GLuint, binaryFormat: GLenum, binary: pointer, length: GLsizei): void =
  ## Load a program object with a program binary
  ## Specifies the name of a program object into which to load a program binary.
  glCallTemplate(cglProgramBinary(program, binaryFormat, binary, length), "glProgramBinary")
proc glProgramParameteri*(program: GLuint, pname: GLenum, value: GLint): void =
  ## Specify a parameter for a program object
  ## Specifies the name of a program object whose parameter to modify.
  glCallTemplate(cglProgramParameteri(program, pname, value), "glProgramParameteri")
proc glProgramUniform1d*(program: GLuint, location: GLint, v0: GLdouble): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform1d(program, location, v0), "glProgramUniform1d")
proc glProgramUniform1dv*(program: GLuint, location: GLint, count: GLsizei, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform1dv(program, location, count, value), "glProgramUniform1dv")
proc glProgramUniform1f*(program: GLuint, location: GLint, v0: GLfloat): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform1f(program, location, v0), "glProgramUniform1f")
proc glProgramUniform1fv*(program: GLuint, location: GLint, count: GLsizei, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform1fv(program, location, count, value), "glProgramUniform1fv")
proc glProgramUniform1i*(program: GLuint, location: GLint, v0: GLint): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform1i(program, location, v0), "glProgramUniform1i")
proc glProgramUniform1iv*(program: GLuint, location: GLint, count: GLsizei, value: ptr GLint): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform1iv(program, location, count, value), "glProgramUniform1iv")
proc glProgramUniform1ui*(program: GLuint, location: GLint, v0: GLuint): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform1ui(program, location, v0), "glProgramUniform1ui")
proc glProgramUniform1uiv*(program: GLuint, location: GLint, count: GLsizei, value: ptr GLuint): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform1uiv(program, location, count, value), "glProgramUniform1uiv")
proc glProgramUniform2d*(program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform2d(program, location, v0, v1), "glProgramUniform2d")
proc glProgramUniform2dv*(program: GLuint, location: GLint, count: GLsizei, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform2dv(program, location, count, value), "glProgramUniform2dv")
proc glProgramUniform2f*(program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform2f(program, location, v0, v1), "glProgramUniform2f")
proc glProgramUniform2fv*(program: GLuint, location: GLint, count: GLsizei, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform2fv(program, location, count, value), "glProgramUniform2fv")
proc glProgramUniform2i*(program: GLuint, location: GLint, v0: GLint, v1: GLint): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform2i(program, location, v0, v1), "glProgramUniform2i")
proc glProgramUniform2iv*(program: GLuint, location: GLint, count: GLsizei, value: ptr GLint): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform2iv(program, location, count, value), "glProgramUniform2iv")
proc glProgramUniform2ui*(program: GLuint, location: GLint, v0: GLuint, v1: GLuint): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform2ui(program, location, v0, v1), "glProgramUniform2ui")
proc glProgramUniform2uiv*(program: GLuint, location: GLint, count: GLsizei, value: ptr GLuint): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform2uiv(program, location, count, value), "glProgramUniform2uiv")
proc glProgramUniform3d*(program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform3d(program, location, v0, v1, v2), "glProgramUniform3d")
proc glProgramUniform3dv*(program: GLuint, location: GLint, count: GLsizei, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform3dv(program, location, count, value), "glProgramUniform3dv")
proc glProgramUniform3f*(program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform3f(program, location, v0, v1, v2), "glProgramUniform3f")
proc glProgramUniform3fv*(program: GLuint, location: GLint, count: GLsizei, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform3fv(program, location, count, value), "glProgramUniform3fv")
proc glProgramUniform3i*(program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform3i(program, location, v0, v1, v2), "glProgramUniform3i")
proc glProgramUniform3iv*(program: GLuint, location: GLint, count: GLsizei, value: ptr GLint): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform3iv(program, location, count, value), "glProgramUniform3iv")
proc glProgramUniform3ui*(program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform3ui(program, location, v0, v1, v2), "glProgramUniform3ui")
proc glProgramUniform3uiv*(program: GLuint, location: GLint, count: GLsizei, value: ptr GLuint): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform3uiv(program, location, count, value), "glProgramUniform3uiv")
proc glProgramUniform4d*(program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble, v3: GLdouble): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform4d(program, location, v0, v1, v2, v3), "glProgramUniform4d")
proc glProgramUniform4dv*(program: GLuint, location: GLint, count: GLsizei, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform4dv(program, location, count, value), "glProgramUniform4dv")
proc glProgramUniform4f*(program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform4f(program, location, v0, v1, v2, v3), "glProgramUniform4f")
proc glProgramUniform4fv*(program: GLuint, location: GLint, count: GLsizei, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform4fv(program, location, count, value), "glProgramUniform4fv")
proc glProgramUniform4i*(program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform4i(program, location, v0, v1, v2, v3), "glProgramUniform4i")
proc glProgramUniform4iv*(program: GLuint, location: GLint, count: GLsizei, value: ptr GLint): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform4iv(program, location, count, value), "glProgramUniform4iv")
proc glProgramUniform4ui*(program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform4ui(program, location, v0, v1, v2, v3), "glProgramUniform4ui")
proc glProgramUniform4uiv*(program: GLuint, location: GLint, count: GLsizei, value: ptr GLuint): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniform4uiv(program, location, count, value), "glProgramUniform4uiv")
proc glProgramUniformMatrix2dv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix2dv(program, location, count, transpose, value), "glProgramUniformMatrix2dv")
proc glProgramUniformMatrix2fv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix2fv(program, location, count, transpose, value), "glProgramUniformMatrix2fv")
proc glProgramUniformMatrix2x3dv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix2x3dv(program, location, count, transpose, value), "glProgramUniformMatrix2x3dv")
proc glProgramUniformMatrix2x3fv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix2x3fv(program, location, count, transpose, value), "glProgramUniformMatrix2x3fv")
proc glProgramUniformMatrix2x4dv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix2x4dv(program, location, count, transpose, value), "glProgramUniformMatrix2x4dv")
proc glProgramUniformMatrix2x4fv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix2x4fv(program, location, count, transpose, value), "glProgramUniformMatrix2x4fv")
proc glProgramUniformMatrix3dv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix3dv(program, location, count, transpose, value), "glProgramUniformMatrix3dv")
proc glProgramUniformMatrix3fv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix3fv(program, location, count, transpose, value), "glProgramUniformMatrix3fv")
proc glProgramUniformMatrix3x2dv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix3x2dv(program, location, count, transpose, value), "glProgramUniformMatrix3x2dv")
proc glProgramUniformMatrix3x2fv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix3x2fv(program, location, count, transpose, value), "glProgramUniformMatrix3x2fv")
proc glProgramUniformMatrix3x4dv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix3x4dv(program, location, count, transpose, value), "glProgramUniformMatrix3x4dv")
proc glProgramUniformMatrix3x4fv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix3x4fv(program, location, count, transpose, value), "glProgramUniformMatrix3x4fv")
proc glProgramUniformMatrix4dv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix4dv(program, location, count, transpose, value), "glProgramUniformMatrix4dv")
proc glProgramUniformMatrix4fv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix4fv(program, location, count, transpose, value), "glProgramUniformMatrix4fv")
proc glProgramUniformMatrix4x2dv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix4x2dv(program, location, count, transpose, value), "glProgramUniformMatrix4x2dv")
proc glProgramUniformMatrix4x2fv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix4x2fv(program, location, count, transpose, value), "glProgramUniformMatrix4x2fv")
proc glProgramUniformMatrix4x3dv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix4x3dv(program, location, count, transpose, value), "glProgramUniformMatrix4x3dv")
proc glProgramUniformMatrix4x3fv*(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for a specified program object
  ## Specifies the handle of the program containing the uniform
  glCallTemplate(cglProgramUniformMatrix4x3fv(program, location, count, transpose, value), "glProgramUniformMatrix4x3fv")
proc glProvokingVertex*(mode: GLenum): void =
  ## Specifiy the vertex to be used as the source of data for flat shaded varyings
  ## Specifies the vertex to be used as the source of data for flat shaded varyings.
  glCallTemplate(cglProvokingVertex(mode), "glProvokingVertex")
proc glPushDebugGroup*(source: GLenum, id: GLuint, length: GLsizei, message: cstring): void =
  ## Push a named debug group into the command stream
  ## The source of the debug message.
  glCallTemplate(cglPushDebugGroup(source, id, length, message), "glPushDebugGroup")
proc glVertexAttribI1ui*(index: GLuint, x: GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI1ui(index, x), "glVertexAttribI1ui")
proc glQueryCounter*(id: GLuint, target: GLenum): void =
  ## Record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.
  ## Specify the name of a query object into which to record the GL time.
  glCallTemplate(cglQueryCounter(id, target), "glQueryCounter")
proc glWaitSync*(sync: GLsync, flags: GLbitfield, timeout: GLuint64): void =
  ## Instruct the GL server to block until the specified sync object becomes signaled
  ## Specifies the sync object whose status to wait on.
  glCallTemplate(cglWaitSync(sync, flags, timeout), "glWaitSync")
proc glViewportIndexedfv*(index: GLuint, v: ptr GLfloat): void =
  ## Set a specified viewport
  ## Specify the first viewport to set.
  glCallTemplate(cglViewportIndexedfv(index, v), "glViewportIndexedfv")
proc glViewportIndexedf*(index: GLuint, x: GLfloat, y: GLfloat, w: GLfloat, h: GLfloat): void =
  ## Set a specified viewport
  ## Specify the first viewport to set.
  glCallTemplate(cglViewportIndexedf(index, x, y, w, h), "glViewportIndexedf")
proc glReadBuffer*(src: GLenum): void =
  ## Select a color buffer source for pixels
  ## Specifies a color buffer.
  ## Accepted values are
  ## GL_FRONT_LEFT,
  ## GL_FRONT_RIGHT,
  ## GL_BACK_LEFT,
  ## GL_BACK_RIGHT,
  ## GL_FRONT,
  ## GL_BACK,
  ## GL_LEFT,
  ## GL_RIGHT, and
  ## GL_AUXi,
  ## where iis between 0 and the value of GL_AUX_BUFFERSminus 1.
  glCallTemplate(cglReadBuffer(src), "glReadBuffer")
proc glReadPixels*(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void =
  ## Read a block of pixels from the frame buffer
  ## Specify the window coordinates of the first pixel
  ## that is read from the frame buffer.
  ## This location is the lower left corner of a rectangular block of pixels.
  glCallTemplate(cglReadPixels(x, y, width, height, format, `type`, pixels), "glReadPixels")
proc glReadnPixels*(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, `type`: GLenum, bufSize: GLsizei, data: pointer): void =
  ## Read a block of pixels from the frame buffer
  ## Specify the window coordinates of the first pixel
  ## that is read from the frame buffer.
  ## This location is the lower left corner of a rectangular block of pixels.
  glCallTemplate(cglReadnPixels(x, y, width, height, format, `type`, bufSize, data), "glReadnPixels")
proc glViewportArrayv*(first: GLuint, count: GLsizei, v: ptr GLfloat): void =
  ## Set multiple viewports
  ## Specify the first viewport to set.
  glCallTemplate(cglViewportArrayv(first, count, v), "glViewportArrayv")
proc glViewport*(x: GLint, y: GLint, width: GLsizei, height: GLsizei): void =
  ## Set the viewport
  ## Specify the lower left corner of the viewport rectangle,
  ## in pixels. The initial value is (0,0).
  glCallTemplate(cglViewport(x, y, width, height), "glViewport")
proc glReleaseShaderCompiler*(): void =
  ## Release resources consumed by the implementation's shader compiler
  ## glReleaseShaderCompilerprovides a hint to the implementation that it
  ## may free internal resources associated with its shader compiler. glCompileShadermay subsequently be called and the implementation may at that time reallocate resources
  ## previously freed by the call to glReleaseShaderCompiler.
  glCallTemplate(cglReleaseShaderCompiler(), "glReleaseShaderCompiler")
proc glVertexAttribL4dv*(index: GLuint, v: ptr GLdouble): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribL4dv(index, v), "glVertexAttribL4dv")
proc glRenderbufferStorage*(target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei): void =
  ## Establish data storage, format and dimensions of a
  ## renderbuffer object's image
  ## Specifies a binding target of the allocation for
  ## glRenderbufferStoragefunction. Must be
  glCallTemplate(cglRenderbufferStorage(target, internalformat, width, height), "glRenderbufferStorage")
proc glRenderbufferStorageMultisample*(target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void =
  ## Establish data storage, format, dimensions and sample count of
  ## a renderbuffer object's image
  ## Specifies a binding target of the allocation for
  ## glRenderbufferStorageMultisamplefunction. Must
  glCallTemplate(cglRenderbufferStorageMultisample(target, samples, internalformat, width, height), "glRenderbufferStorageMultisample")
proc glResumeTransformFeedback*(): void =
  ## Resume transform feedback operations
  ## glResumeTransformFeedbackresumes transform feedback operations on the currently active transform feedback
  ## object. When transform feedback operations are paused, transform feedback is still considered active and changing most
  ## transform feedback state related to the object results in an error. However, a new transform feedback object may be bound
  ## while transform feedback is paused.
  glCallTemplate(cglResumeTransformFeedback(), "glResumeTransformFeedback")
proc glVertexAttribI1iv*(index: GLuint, v: ptr GLint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI1iv(index, v), "glVertexAttribI1iv")
proc glRotatex*(angle: GLfixed, x: GLfixed, y: GLfixed, z: GLfixed): void =
  ## Multiply the current matrix by a rotation matrix
  ## Specifies the angle of rotation, in degrees.
  glCallTemplate(cglRotatex(angle, x, y, z), "glRotatex")
proc glSampleCoverage*(value: GLfloat, invert: GLboolean): void =
  ## Specify multisample coverage parameters
  ## Specify a single floating-point sample coverage value.  The value is
  ## clamped to the range
  ##
  ## 01.
  ## The initial value is 1.0.
  glCallTemplate(cglSampleCoverage(value, invert), "glSampleCoverage")
proc glSampleCoveragex*(value: GLclampx, invert: GLboolean): void =
  ## Specify multisample coverage parameters
  ## Specify a single floating-point sample coverage value.  The value is
  ## clamped to the range
  ##
  ## 01.
  ## The initial value is 1.0.
  glCallTemplate(cglSampleCoveragex(value, invert), "glSampleCoveragex")
proc glSampleMaski*(maskNumber: GLuint, mask: GLbitfield): void =
  ## Set the value of a sub-word of the sample mask
  ## Specifies which 32-bit sub-word of the sample mask to update.
  glCallTemplate(cglSampleMaski(maskNumber, mask), "glSampleMaski")
proc glSamplerParameterIiv*(sampler: GLuint, pname: GLenum, param: ptr GLint): void =
  ## Set sampler parameters
  ## Specifies the sampler object whose parameter to modify.
  glCallTemplate(cglSamplerParameterIiv(sampler, pname, param), "glSamplerParameterIiv")
proc glSamplerParameterIuiv*(sampler: GLuint, pname: GLenum, param: ptr GLuint): void =
  ## Set sampler parameters
  ## Specifies the sampler object whose parameter to modify.
  glCallTemplate(cglSamplerParameterIuiv(sampler, pname, param), "glSamplerParameterIuiv")
proc glSamplerParameterf*(sampler: GLuint, pname: GLenum, param: GLfloat): void =
  ## Set sampler parameters
  ## Specifies the sampler object whose parameter to modify.
  glCallTemplate(cglSamplerParameterf(sampler, pname, param), "glSamplerParameterf")
proc glSamplerParameterfv*(sampler: GLuint, pname: GLenum, param: ptr GLfloat): void =
  ## Set sampler parameters
  ## Specifies the sampler object whose parameter to modify.
  glCallTemplate(cglSamplerParameterfv(sampler, pname, param), "glSamplerParameterfv")
proc glSamplerParameteri*(sampler: GLuint, pname: GLenum, param: GLint): void =
  ## Set sampler parameters
  ## Specifies the sampler object whose parameter to modify.
  glCallTemplate(cglSamplerParameteri(sampler, pname, param), "glSamplerParameteri")
proc glSamplerParameteriv*(sampler: GLuint, pname: GLenum, param: ptr GLint): void =
  ## Set sampler parameters
  ## Specifies the sampler object whose parameter to modify.
  glCallTemplate(cglSamplerParameteriv(sampler, pname, param), "glSamplerParameteriv")
proc glVertexAttribI1i*(index: GLuint, x: GLint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribI1i(index, x), "glVertexAttribI1i")
proc glScalex*(x: GLfixed, y: GLfixed, z: GLfixed): void =
  ## Multiply the current matrix by a general scaling matrix
  ## Specify scale factors along the x, y, and zaxes, respectively.
  glCallTemplate(cglScalex(x, y, z), "glScalex")
proc glScissor*(x: GLint, y: GLint, width: GLsizei, height: GLsizei): void =
  ## Define the scissor box
  ## Specify the lower left corner of the scissor box.
  ## Initially (0, 0).
  glCallTemplate(cglScissor(x, y, width, height), "glScissor")
proc glScissorArrayv*(first: GLuint, count: GLsizei, v: ptr GLint): void =
  ## Define the scissor box for multiple viewports
  ## Specifies the index of the first viewport whose scissor box to modify.
  glCallTemplate(cglScissorArrayv(first, count, v), "glScissorArrayv")
proc glScissorIndexed*(index: GLuint, left: GLint, bottom: GLint, width: GLsizei, height: GLsizei): void =
  ## Define the scissor box for a specific viewport
  ## Specifies the index of the viewport whose scissor box to modify.
  glCallTemplate(cglScissorIndexed(index, left, bottom, width, height), "glScissorIndexed")
proc glScissorIndexedv*(index: GLuint, v: ptr GLint): void =
  ## Define the scissor box for a specific viewport
  ## Specifies the index of the viewport whose scissor box to modify.
  glCallTemplate(cglScissorIndexedv(index, v), "glScissorIndexedv")
proc glVertexAttrib3fv*(index: GLuint, v: ptr GLfloat): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib3fv(index, v), "glVertexAttrib3fv")
proc glVertexAttrib3f*(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib3f(index, x, y, z), "glVertexAttrib3f")
proc glVertexAttrib3dv*(index: GLuint, v: ptr GLdouble): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib3dv(index, v), "glVertexAttrib3dv")
proc glVertexAttrib3d*(index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib3d(index, x, y, z), "glVertexAttrib3d")
proc glSecondaryColorP3ui*(`type`: GLenum, color: GLuint): void =
  ## Set the current secondary color
  ## Specify new red, green, and blue values for the current secondary color.
  glCallTemplate(cglSecondaryColorP3ui(`type`, color), "glSecondaryColorP3ui")
proc glSecondaryColorP3uiv*(`type`: GLenum, color: ptr GLuint): void =
  ## Set the current secondary color
  ## Specify new red, green, and blue values for the current secondary color.
  glCallTemplate(cglSecondaryColorP3uiv(`type`, color), "glSecondaryColorP3uiv")
proc glVertexAttrib2sv*(index: GLuint, v: ptr GLshort): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib2sv(index, v), "glVertexAttrib2sv")
proc glVertexAttribP2uiv*(index: GLuint, `type`: GLenum, normalized: GLboolean, value: ptr GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribP2uiv(index, `type`, normalized, value), "glVertexAttribP2uiv")
proc glShaderBinary*(count: GLsizei, shaders: ptr GLuint, binaryformat: GLenum, binary: pointer, length: GLsizei): void =
  ## Load pre-compiled shader binaries
  ## Specifies the number of shader object handles contained in shaders.
  glCallTemplate(cglShaderBinary(count, shaders, binaryformat, binary, length), "glShaderBinary")
proc glShaderSource*(shader: GLuint, count: GLsizei, string: ptr cstring, length: ptr GLint): void =
  ## Replaces the source code in a shader object
  ## Specifies the handle of the shader object
  glCallTemplate(cglShaderSource(shader, count, string, length), "glShaderSource")
proc glShaderStorageBlockBinding*(program: GLuint, storageBlockIndex: GLuint, storageBlockBinding: GLuint): void =
  ## Change an active shader storage block binding
  ## The name of the program containing the block whose binding to change.
  glCallTemplate(cglShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding), "glShaderStorageBlockBinding")
proc glSpecializeShader*(shader: GLuint, pEntryPoint: cstring, numSpecializationConstants: GLuint, pConstantIndex: ptr GLuint, pConstantValue: ptr GLuint): void =
  ## Specializing a SPIR-V shader is analogous to compiling a GLSL shader. So if this function completes successfully, the shader object's compile status is GL_TRUE. If specialization fails, then the shader infolog has information explaining why and an OpenGL Error is generated.
  ## pEntryPoint​ must name a valid entry point. Also, the entry point's "execution model" (SPIR-V speak for "Shader Stage") must match the stage the shader object was created with. Specialization can also fail if pConstantIndex​ references a specialization constant index that the SPIR-V binary does not use. If specialization fails, the shader's info log is updated appropriately.
  ## Once specialized, SPIR-V shaders cannot be re-specialized. However, you can reload the SPIR-V binary data into them, which will allow them to be specialized again.
  glCallTemplate(cglSpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue), "glSpecializeShader")
proc glStencilFunc*(`func`: GLenum, `ref`: GLint, mask: GLuint): void =
  ## Set front and back function and reference value for stencil testing
  ## Specifies the test function.
  ## Eight symbolic constants are valid:
  ## GL_NEVER,
  ## GL_LESS,
  ## GL_LEQUAL,
  ## GL_GREATER,
  ## GL_GEQUAL,
  ## GL_EQUAL,
  ## GL_NOTEQUAL, and
  ## GL_ALWAYS. The initial value is GL_ALWAYS.
  glCallTemplate(cglStencilFunc(`func`, `ref`, mask), "glStencilFunc")
proc glStencilFuncSeparate*(face: GLenum, `func`: GLenum, `ref`: GLint, mask: GLuint): void =
  ## Set front and/or back function and reference value for stencil testing
  ## Specifies whether front and/or back stencil state is updated.
  ## Three symbolic constants are valid:
  ## GL_FRONT,
  ## GL_BACK, and
  ## GL_FRONT_AND_BACK.
  glCallTemplate(cglStencilFuncSeparate(face, `func`, `ref`, mask), "glStencilFuncSeparate")
proc glStencilMask*(mask: GLuint): void =
  ## Control the front and back writing of individual bits in the stencil planes
  ## Specifies a bit mask to enable and disable writing of individual bits
  ## in the stencil planes.
  ## Initially, the mask is all 1's.
  glCallTemplate(cglStencilMask(mask), "glStencilMask")
proc glStencilMaskSeparate*(face: GLenum, mask: GLuint): void =
  ## Control the front and/or back writing of individual bits in the stencil planes
  ## Specifies whether the front and/or back stencil writemask is updated.
  ## Three symbolic constants are valid:
  ## GL_FRONT,
  ## GL_BACK, and
  ## GL_FRONT_AND_BACK.
  glCallTemplate(cglStencilMaskSeparate(face, mask), "glStencilMaskSeparate")
proc glStencilOp*(fail: GLenum, zfail: GLenum, zpass: GLenum): void =
  ## Set front and back stencil test actions
  ## Specifies the action to take when the stencil test fails.
  ## Eight symbolic constants are accepted:
  ## GL_KEEP,
  ## GL_ZERO,
  ## GL_REPLACE,
  ## GL_INCR,
  ## GL_INCR_WRAP,
  ## GL_DECR,
  ## GL_DECR_WRAP, and
  ## GL_INVERT. The initial value is GL_KEEP.
  glCallTemplate(cglStencilOp(fail, zfail, zpass), "glStencilOp")
proc glStencilOpSeparate*(face: GLenum, sfail: GLenum, dpfail: GLenum, dppass: GLenum): void =
  ## Set front and/or back stencil test actions
  ## Specifies whether front and/or back stencil state is updated.
  ## Three symbolic constants are valid:
  ## GL_FRONT,
  ## GL_BACK, and
  ## GL_FRONT_AND_BACK.
  glCallTemplate(cglStencilOpSeparate(face, sfail, dpfail, dppass), "glStencilOpSeparate")
proc glTexBuffer*(target: GLenum, internalformat: GLenum, buffer: GLuint): void =
  ## Attach a buffer object's data store to a buffer texture object
  ## Specifies the target to which the texture is bound for
  ## glTexBuffer. Must be
  ## GL_TEXTURE_BUFFER.
  glCallTemplate(cglTexBuffer(target, internalformat, buffer), "glTexBuffer")
proc glTexBufferRange*(target: GLenum, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr): void =
  ## Attach a range of a buffer object's data store to a buffer texture object
  ## Specifies the target to which the texture object is
  ## bound for glTexBufferRange. Must be
  ## GL_TEXTURE_BUFFER.
  glCallTemplate(cglTexBufferRange(target, internalformat, buffer, offset, size), "glTexBufferRange")
proc glTexCoordP1ui*(`type`: GLenum, coords: GLuint): void =
  ## Set the current texture coordinates
  ## Specify s, t, r, and qtexture coordinates.
  ## Not all parameters are present in all forms of the command.
  glCallTemplate(cglTexCoordP1ui(`type`, coords), "glTexCoordP1ui")
proc glTexCoordP1uiv*(`type`: GLenum, coords: ptr GLuint): void =
  ## Set the current texture coordinates
  ## Specify s, t, r, and qtexture coordinates.
  ## Not all parameters are present in all forms of the command.
  glCallTemplate(cglTexCoordP1uiv(`type`, coords), "glTexCoordP1uiv")
proc glTexCoordP2ui*(`type`: GLenum, coords: GLuint): void =
  ## Set the current texture coordinates
  ## Specify s, t, r, and qtexture coordinates.
  ## Not all parameters are present in all forms of the command.
  glCallTemplate(cglTexCoordP2ui(`type`, coords), "glTexCoordP2ui")
proc glTexCoordP2uiv*(`type`: GLenum, coords: ptr GLuint): void =
  ## Set the current texture coordinates
  ## Specify s, t, r, and qtexture coordinates.
  ## Not all parameters are present in all forms of the command.
  glCallTemplate(cglTexCoordP2uiv(`type`, coords), "glTexCoordP2uiv")
proc glTexCoordP3ui*(`type`: GLenum, coords: GLuint): void =
  ## Set the current texture coordinates
  ## Specify s, t, r, and qtexture coordinates.
  ## Not all parameters are present in all forms of the command.
  glCallTemplate(cglTexCoordP3ui(`type`, coords), "glTexCoordP3ui")
proc glTexCoordP3uiv*(`type`: GLenum, coords: ptr GLuint): void =
  ## Set the current texture coordinates
  ## Specify s, t, r, and qtexture coordinates.
  ## Not all parameters are present in all forms of the command.
  glCallTemplate(cglTexCoordP3uiv(`type`, coords), "glTexCoordP3uiv")
proc glTexCoordP4ui*(`type`: GLenum, coords: GLuint): void =
  ## Set the current texture coordinates
  ## Specify s, t, r, and qtexture coordinates.
  ## Not all parameters are present in all forms of the command.
  glCallTemplate(cglTexCoordP4ui(`type`, coords), "glTexCoordP4ui")
proc glTexCoordP4uiv*(`type`: GLenum, coords: ptr GLuint): void =
  ## Set the current texture coordinates
  ## Specify s, t, r, and qtexture coordinates.
  ## Not all parameters are present in all forms of the command.
  glCallTemplate(cglTexCoordP4uiv(`type`, coords), "glTexCoordP4uiv")
proc glVertexAttribP2ui*(index: GLuint, `type`: GLenum, normalized: GLboolean, value: GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribP2ui(index, `type`, normalized, value), "glVertexAttribP2ui")
proc glVertexAttribP1uiv*(index: GLuint, `type`: GLenum, normalized: GLboolean, value: ptr GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribP1uiv(index, `type`, normalized, value), "glVertexAttribP1uiv")
proc glVertexAttribP1ui*(index: GLuint, `type`: GLenum, normalized: GLboolean, value: GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribP1ui(index, `type`, normalized, value), "glVertexAttribP1ui")
proc glTexEnvx*(target: GLenum, pname: GLenum, param: GLfixed): void =
  ## Set texture environment parameters
  ## Specifies a texture environment.
  ## May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROLor GL_POINT_SPRITE.
  glCallTemplate(cglTexEnvx(target, pname, param), "glTexEnvx")
proc glTexEnvxv*(target: GLenum, pname: GLenum, params: ptr GLfixed): void =
  ## Set texture environment parameters
  ## Specifies a texture environment.
  ## May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROLor GL_POINT_SPRITE.
  glCallTemplate(cglTexEnvxv(target, pname, params), "glTexEnvxv")
proc glVertexAttribLPointer*(index: GLuint, size: GLint, `type`: GLenum, stride: GLsizei, pointer: pointer): void =
  ## Define an array of generic vertex attribute data
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttribLPointer(index, size, `type`, stride, pointer), "glVertexAttribLPointer")
proc glVertexAttribLFormat*(attribindex: GLuint, size: GLint, `type`: GLenum, relativeoffset: GLuint): void =
  ## Specify the organization of vertex arrays
  ## Specifies the name of the vertex array object for
  glCallTemplate(cglVertexAttribLFormat(attribindex, size, `type`, relativeoffset), "glVertexAttribLFormat")
proc glTexImage1D*(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, border: GLint, format: GLenum, `type`: GLenum, pixels: pointer): void =
  ## Specify a one-dimensional texture image
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_1Dor GL_PROXY_TEXTURE_1D.
  glCallTemplate(cglTexImage1D(target, level, internalformat, width, border, format, `type`, pixels), "glTexImage1D")
proc glTexImage2D*(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, `type`: GLenum, pixels: pointer): void =
  ## Specify a two-dimensional texture image
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or
  ## GL_PROXY_TEXTURE_CUBE_MAP.
  glCallTemplate(cglTexImage2D(target, level, internalformat, width, height, border, format, `type`, pixels), "glTexImage2D")
proc glTexImage2DMultisample*(target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean): void =
  ## Establish the data storage, format, dimensions, and number of samples of a multisample texture's image
  ## Specifies the target of the operation. targetmust be GL_TEXTURE_2D_MULTISAMPLEor GL_PROXY_TEXTURE_2D_MULTISAMPLE.
  glCallTemplate(cglTexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations), "glTexImage2DMultisample")
proc glTexImage3D*(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, `type`: GLenum, pixels: pointer): void =
  ## Specify a three-dimensional texture image
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_3Dor GL_PROXY_TEXTURE_3D.
  glCallTemplate(cglTexImage3D(target, level, internalformat, width, height, depth, border, format, `type`, pixels), "glTexImage3D")
proc glTexImage3DMultisample*(target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean): void =
  ## Establish the data storage, format, dimensions, and number of samples of a multisample texture's image
  ## Specifies the target of the operation. targetmust be GL_TEXTURE_2D_MULTISAMPLE_ARRAYor GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.
  glCallTemplate(cglTexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations), "glTexImage3DMultisample")
proc glTexParameterIiv*(target: GLenum, pname: GLenum, params: ptr GLint): void =
  ## Set texture parameters
  ## Specifies the target texture,
  ## which must be either GL_TEXTURE_1D, GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
  glCallTemplate(cglTexParameterIiv(target, pname, params), "glTexParameterIiv")
proc glTexParameterIuiv*(target: GLenum, pname: GLenum, params: ptr GLuint): void =
  ## Set texture parameters
  ## Specifies the target texture,
  ## which must be either GL_TEXTURE_1D, GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
  glCallTemplate(cglTexParameterIuiv(target, pname, params), "glTexParameterIuiv")
proc glTexParameterf*(target: GLenum, pname: GLenum, param: GLfloat): void =
  ## Set texture parameters
  ## Specifies the target texture,
  ## which must be either GL_TEXTURE_1D, GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
  glCallTemplate(cglTexParameterf(target, pname, param), "glTexParameterf")
proc glTexParameterfv*(target: GLenum, pname: GLenum, params: ptr GLfloat): void =
  ## Set texture parameters
  ## Specifies the target texture,
  ## which must be either GL_TEXTURE_1D, GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
  glCallTemplate(cglTexParameterfv(target, pname, params), "glTexParameterfv")
proc glTexParameteri*(target: GLenum, pname: GLenum, param: GLint): void =
  ## Set texture parameters
  ## Specifies the target texture,
  ## which must be either GL_TEXTURE_1D, GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
  glCallTemplate(cglTexParameteri(target, pname, param), "glTexParameteri")
proc glTexParameteriv*(target: GLenum, pname: GLenum, params: ptr GLint): void =
  ## Set texture parameters
  ## Specifies the target texture,
  ## which must be either GL_TEXTURE_1D, GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
  glCallTemplate(cglTexParameteriv(target, pname, params), "glTexParameteriv")
proc glTexParameterx*(target: GLenum, pname: GLenum, param: GLfixed): void =
  ## Set texture parameters
  ## Specifies the target texture,
  ## which must be either GL_TEXTURE_1D, GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
  glCallTemplate(cglTexParameterx(target, pname, param), "glTexParameterx")
proc glTexParameterxv*(target: GLenum, pname: GLenum, params: ptr GLfixed): void =
  ## Set texture parameters
  ## Specifies the target texture,
  ## which must be either GL_TEXTURE_1D, GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
  glCallTemplate(cglTexParameterxv(target, pname, params), "glTexParameterxv")
proc glTexStorage1D*(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei): void =
  ## Simultaneously specify storage for all levels of a one-dimensional texture
  ## Specifies the target to which the texture object is
  ## bound for glTexStorage1D. Must be
  ## one of GL_TEXTURE_1Dor
  ## GL_PROXY_TEXTURE_1D.
  glCallTemplate(cglTexStorage1D(target, levels, internalformat, width), "glTexStorage1D")
proc glTexStorage2D*(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void =
  ## Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
  ## Specifies the target to which the texture object is
  ## bound for glTexStorage2D. Must be
  ## one of GL_TEXTURE_2D,
  ## GL_TEXTURE_1D_ARRAY,
  ## GL_TEXTURE_RECTANGLE,
  ## GL_TEXTURE_CUBE_MAP,
  ## GL_PROXY_TEXTURE_2D,
  ## GL_PROXY_TEXTURE_1D_ARRAY,
  ## GL_PROXY_TEXTURE_RECTANGLE, or
  ## GL_PROXY_TEXTURE_CUBE_MAP.
  glCallTemplate(cglTexStorage2D(target, levels, internalformat, width, height), "glTexStorage2D")
proc glTexStorage2DMultisample*(target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean): void =
  ## Specify storage for a two-dimensional multisample texture
  ## Specifies the target to which the texture object is
  ## bound for
  ## glTexStorage2DMultisample. Must be
  ## one of GL_TEXTURE_2D_MULTISAMPLEor
  ## GL_PROXY_TEXTURE_2D_MULTISAMPLE.
  glCallTemplate(cglTexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations), "glTexStorage2DMultisample")
proc glTexStorage3D*(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei): void =
  ## Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture
  ## Specifies the target to which the texture object is
  ## bound for glTexStorage3D. Must be
  ## one of GL_TEXTURE_3D,
  ## GL_TEXTURE_2D_ARRAY,
  ## GL_TEXTURE_CUBE_MAP_ARRAY,
  ## GL_PROXY_TEXTURE_3D,
  ## GL_PROXY_TEXTURE_2D_ARRAYor
  ## GL_PROXY_TEXTURE_CUBE_MAP_ARRAY.
  glCallTemplate(cglTexStorage3D(target, levels, internalformat, width, height, depth), "glTexStorage3D")
proc glTexStorage3DMultisample*(target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean): void =
  ## Specify storage for a two-dimensional multisample array texture
  ## Specifies the target to which the texture object is
  ## bound for
  ## glTexStorage3DMultisample. Must be
  ## one of
  ## GL_TEXTURE_2D_MULTISAMPLE_ARRAYor
  ## GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.
  glCallTemplate(cglTexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations), "glTexStorage3DMultisample")
proc glTexSubImage1D*(target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void =
  ## Specify a one-dimensional texture subimage
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_1D.
  glCallTemplate(cglTexSubImage1D(target, level, xoffset, width, format, `type`, pixels), "glTexSubImage1D")
proc glTexSubImage2D*(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void =
  ## Specify a two-dimensional texture subimage
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_2D,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
  glCallTemplate(cglTexSubImage2D(target, level, xoffset, yoffset, width, height, format, `type`, pixels), "glTexSubImage2D")
proc glTexSubImage3D*(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void =
  ## Specify a three-dimensional texture subimage
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_3D.
  glCallTemplate(cglTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, `type`, pixels), "glTexSubImage3D")
proc glTextureBarrier*(): void =
  ## Controls the ordering of reads and writes to rendered fragments across drawing commands
  ## The values of rendered fragments are undefined when a shader
  ## stage fetches texels and the same texels are written via
  ## fragment shader outputs, even if the reads and writes are not in
  ## the same drawing command. To safely read the result of a written
  ## texel via a texel fetch in a subsequent drawing command, call
  ## glTextureBarrierbetween the two drawing
  ## commands to guarantee that writes have completed and caches have
  ## been invalidated before subsequent drawing commands are
  ## executed.
  glCallTemplate(cglTextureBarrier(), "glTextureBarrier")
proc glTextureBuffer*(texture: GLuint, internalformat: GLenum, buffer: GLuint): void =
  ## Attach a buffer object's data store to a buffer texture object
  ## Specifies the target to which the texture is bound for
  ## glTexBuffer. Must be
  ## GL_TEXTURE_BUFFER.
  glCallTemplate(cglTextureBuffer(texture, internalformat, buffer), "glTextureBuffer")
proc glTextureBufferRange*(texture: GLuint, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr): void =
  ## Attach a range of a buffer object's data store to a buffer texture object
  ## Specifies the target to which the texture object is
  ## bound for glTexBufferRange. Must be
  ## GL_TEXTURE_BUFFER.
  glCallTemplate(cglTextureBufferRange(texture, internalformat, buffer, offset, size), "glTextureBufferRange")
proc glTextureParameterIiv*(texture: GLuint, pname: GLenum, params: ptr GLint): void =
  ## Set texture parameters
  ## Specifies the target texture,
  ## which must be either GL_TEXTURE_1D, GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
  glCallTemplate(cglTextureParameterIiv(texture, pname, params), "glTextureParameterIiv")
proc glTextureParameterIuiv*(texture: GLuint, pname: GLenum, params: ptr GLuint): void =
  ## Set texture parameters
  ## Specifies the target texture,
  ## which must be either GL_TEXTURE_1D, GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
  glCallTemplate(cglTextureParameterIuiv(texture, pname, params), "glTextureParameterIuiv")
proc glTextureParameterf*(texture: GLuint, pname: GLenum, param: GLfloat): void =
  ## Set texture parameters
  ## Specifies the target texture,
  ## which must be either GL_TEXTURE_1D, GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
  glCallTemplate(cglTextureParameterf(texture, pname, param), "glTextureParameterf")
proc glTextureParameterfv*(texture: GLuint, pname: GLenum, param: ptr GLfloat): void =
  ## Set texture parameters
  ## Specifies the target texture,
  ## which must be either GL_TEXTURE_1D, GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
  glCallTemplate(cglTextureParameterfv(texture, pname, param), "glTextureParameterfv")
proc glTextureParameteri*(texture: GLuint, pname: GLenum, param: GLint): void =
  ## Set texture parameters
  ## Specifies the target texture,
  ## which must be either GL_TEXTURE_1D, GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
  glCallTemplate(cglTextureParameteri(texture, pname, param), "glTextureParameteri")
proc glTextureParameteriv*(texture: GLuint, pname: GLenum, param: ptr GLint): void =
  ## Set texture parameters
  ## Specifies the target texture,
  ## which must be either GL_TEXTURE_1D, GL_TEXTURE_2D,
  ## GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
  glCallTemplate(cglTextureParameteriv(texture, pname, param), "glTextureParameteriv")
proc glTextureStorage1D*(texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei): void =
  ## Simultaneously specify storage for all levels of a one-dimensional texture
  ## Specifies the target to which the texture object is
  ## bound for glTexStorage1D. Must be
  ## one of GL_TEXTURE_1Dor
  ## GL_PROXY_TEXTURE_1D.
  glCallTemplate(cglTextureStorage1D(texture, levels, internalformat, width), "glTextureStorage1D")
proc glTextureStorage2D*(texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void =
  ## Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
  ## Specifies the target to which the texture object is
  ## bound for glTexStorage2D. Must be
  ## one of GL_TEXTURE_2D,
  ## GL_TEXTURE_1D_ARRAY,
  ## GL_TEXTURE_RECTANGLE,
  ## GL_TEXTURE_CUBE_MAP,
  ## GL_PROXY_TEXTURE_2D,
  ## GL_PROXY_TEXTURE_1D_ARRAY,
  ## GL_PROXY_TEXTURE_RECTANGLE, or
  ## GL_PROXY_TEXTURE_CUBE_MAP.
  glCallTemplate(cglTextureStorage2D(texture, levels, internalformat, width, height), "glTextureStorage2D")
proc glTextureStorage2DMultisample*(texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean): void =
  ## Specify storage for a two-dimensional multisample texture
  ## Specifies the target to which the texture object is
  ## bound for
  ## glTexStorage2DMultisample. Must be
  ## one of GL_TEXTURE_2D_MULTISAMPLEor
  ## GL_PROXY_TEXTURE_2D_MULTISAMPLE.
  glCallTemplate(cglTextureStorage2DMultisample(texture, samples, internalformat, width, height, fixedsamplelocations), "glTextureStorage2DMultisample")
proc glTextureStorage3D*(texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei): void =
  ## Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture
  ## Specifies the target to which the texture object is
  ## bound for glTexStorage3D. Must be
  ## one of GL_TEXTURE_3D,
  ## GL_TEXTURE_2D_ARRAY,
  ## GL_TEXTURE_CUBE_MAP_ARRAY,
  ## GL_PROXY_TEXTURE_3D,
  ## GL_PROXY_TEXTURE_2D_ARRAYor
  ## GL_PROXY_TEXTURE_CUBE_MAP_ARRAY.
  glCallTemplate(cglTextureStorage3D(texture, levels, internalformat, width, height, depth), "glTextureStorage3D")
proc glTextureStorage3DMultisample*(texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean): void =
  ## Specify storage for a two-dimensional multisample array texture
  ## Specifies the target to which the texture object is
  ## bound for
  ## glTexStorage3DMultisample. Must be
  ## one of
  ## GL_TEXTURE_2D_MULTISAMPLE_ARRAYor
  ## GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.
  glCallTemplate(cglTextureStorage3DMultisample(texture, samples, internalformat, width, height, depth, fixedsamplelocations), "glTextureStorage3DMultisample")
proc glTextureSubImage1D*(texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void =
  ## Specify a one-dimensional texture subimage
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_1D.
  glCallTemplate(cglTextureSubImage1D(texture, level, xoffset, width, format, `type`, pixels), "glTextureSubImage1D")
proc glTextureSubImage2D*(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void =
  ## Specify a two-dimensional texture subimage
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_2D,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  ## GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or
  ## GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
  glCallTemplate(cglTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, `type`, pixels), "glTextureSubImage2D")
proc glTextureSubImage3D*(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer): void =
  ## Specify a three-dimensional texture subimage
  ## Specifies the target texture.
  ## Must be GL_TEXTURE_3D.
  glCallTemplate(cglTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, `type`, pixels), "glTextureSubImage3D")
proc glTextureView*(texture: GLuint, target: GLenum, origtexture: GLuint, internalformat: GLenum, minlevel: GLuint, numlevels: GLuint, minlayer: GLuint, numlayers: GLuint): void =
  ## Initialize a texture as a data alias of another texture's data store
  ## Specifies the texture object to be initialized as a view.
  glCallTemplate(cglTextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers), "glTextureView")
proc glTransformFeedbackBufferBase*(xfb: GLuint, index: GLuint, buffer: GLuint): void =
  ## Bind a buffer object to a transform feedback buffer object
  ## Name of the transform feedback buffer object.
  glCallTemplate(cglTransformFeedbackBufferBase(xfb, index, buffer), "glTransformFeedbackBufferBase")
proc glTransformFeedbackBufferRange*(xfb: GLuint, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr): void =
  ## Bind a range within a buffer object to a transform feedback buffer object
  ## Name of the transform feedback buffer object.
  glCallTemplate(cglTransformFeedbackBufferRange(xfb, index, buffer, offset, size), "glTransformFeedbackBufferRange")
proc glTransformFeedbackVaryings*(program: GLuint, count: GLsizei, varyings: ptr cstring, bufferMode: GLenum): void =
  ## Specify values to record in transform feedback buffers
  ## The name of the target program object.
  glCallTemplate(cglTransformFeedbackVaryings(program, count, varyings, bufferMode), "glTransformFeedbackVaryings")
proc glVertexAttribFormat*(attribindex: GLuint, size: GLint, `type`: GLenum, normalized: GLboolean, relativeoffset: GLuint): void =
  ## Specify the organization of vertex arrays
  ## Specifies the name of the vertex array object for
  glCallTemplate(cglVertexAttribFormat(attribindex, size, `type`, normalized, relativeoffset), "glVertexAttribFormat")
proc glTranslatex*(x: GLfixed, y: GLfixed, z: GLfixed): void =
  ## Multiply the current matrix by a translation matrix
  ## Specify the x, y, and zcoordinates of a translation vector.
  glCallTemplate(cglTranslatex(x, y, z), "glTranslatex")
proc glUniform1d*(location: GLint, x: GLdouble): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform1d(location, x), "glUniform1d")
proc glUniform1dv*(location: GLint, count: GLsizei, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform1dv(location, count, value), "glUniform1dv")
proc glUniform1f*(location: GLint, v0: GLfloat): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform1f(location, v0), "glUniform1f")
proc glUniform1fv*(location: GLint, count: GLsizei, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform1fv(location, count, value), "glUniform1fv")
proc glUniform1i*(location: GLint, v0: GLint): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform1i(location, v0), "glUniform1i")
proc glUniform1iv*(location: GLint, count: GLsizei, value: ptr GLint): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform1iv(location, count, value), "glUniform1iv")
proc glUniform1ui*(location: GLint, v0: GLuint): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform1ui(location, v0), "glUniform1ui")
proc glUniform1uiv*(location: GLint, count: GLsizei, value: ptr GLuint): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform1uiv(location, count, value), "glUniform1uiv")
proc glUniform2d*(location: GLint, x: GLdouble, y: GLdouble): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform2d(location, x, y), "glUniform2d")
proc glUniform2dv*(location: GLint, count: GLsizei, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform2dv(location, count, value), "glUniform2dv")
proc glUniform2f*(location: GLint, v0: GLfloat, v1: GLfloat): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform2f(location, v0, v1), "glUniform2f")
proc glUniform2fv*(location: GLint, count: GLsizei, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform2fv(location, count, value), "glUniform2fv")
proc glUniform2i*(location: GLint, v0: GLint, v1: GLint): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform2i(location, v0, v1), "glUniform2i")
proc glUniform2iv*(location: GLint, count: GLsizei, value: ptr GLint): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform2iv(location, count, value), "glUniform2iv")
proc glUniform2ui*(location: GLint, v0: GLuint, v1: GLuint): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform2ui(location, v0, v1), "glUniform2ui")
proc glUniform2uiv*(location: GLint, count: GLsizei, value: ptr GLuint): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform2uiv(location, count, value), "glUniform2uiv")
proc glUniform3d*(location: GLint, x: GLdouble, y: GLdouble, z: GLdouble): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform3d(location, x, y, z), "glUniform3d")
proc glUniform3dv*(location: GLint, count: GLsizei, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform3dv(location, count, value), "glUniform3dv")
proc glUniform3f*(location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform3f(location, v0, v1, v2), "glUniform3f")
proc glUniform3fv*(location: GLint, count: GLsizei, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform3fv(location, count, value), "glUniform3fv")
proc glUniform3i*(location: GLint, v0: GLint, v1: GLint, v2: GLint): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform3i(location, v0, v1, v2), "glUniform3i")
proc glUniform3iv*(location: GLint, count: GLsizei, value: ptr GLint): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform3iv(location, count, value), "glUniform3iv")
proc glUniform3ui*(location: GLint, v0: GLuint, v1: GLuint, v2: GLuint): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform3ui(location, v0, v1, v2), "glUniform3ui")
proc glUniform3uiv*(location: GLint, count: GLsizei, value: ptr GLuint): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform3uiv(location, count, value), "glUniform3uiv")
proc glUniform4d*(location: GLint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform4d(location, x, y, z, w), "glUniform4d")
proc glUniform4dv*(location: GLint, count: GLsizei, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform4dv(location, count, value), "glUniform4dv")
proc glUniform4f*(location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform4f(location, v0, v1, v2, v3), "glUniform4f")
proc glUniform4fv*(location: GLint, count: GLsizei, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform4fv(location, count, value), "glUniform4fv")
proc glUniform4i*(location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform4i(location, v0, v1, v2, v3), "glUniform4i")
proc glUniform4iv*(location: GLint, count: GLsizei, value: ptr GLint): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform4iv(location, count, value), "glUniform4iv")
proc glUniform4ui*(location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform4ui(location, v0, v1, v2, v3), "glUniform4ui")
proc glUniform4uiv*(location: GLint, count: GLsizei, value: ptr GLuint): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniform4uiv(location, count, value), "glUniform4uiv")
proc glUniformBlockBinding*(program: GLuint, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint): void =
  ## Assign a binding point to an active uniform block
  ## The name of a program object containing the active uniform block whose binding to assign.
  glCallTemplate(cglUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding), "glUniformBlockBinding")
proc glUniformMatrix2dv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix2dv(location, count, transpose, value), "glUniformMatrix2dv")
proc glUniformMatrix2fv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix2fv(location, count, transpose, value), "glUniformMatrix2fv")
proc glUniformMatrix2x3dv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix2x3dv(location, count, transpose, value), "glUniformMatrix2x3dv")
proc glUniformMatrix2x3fv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix2x3fv(location, count, transpose, value), "glUniformMatrix2x3fv")
proc glUniformMatrix2x4dv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix2x4dv(location, count, transpose, value), "glUniformMatrix2x4dv")
proc glUniformMatrix2x4fv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix2x4fv(location, count, transpose, value), "glUniformMatrix2x4fv")
proc glUniformMatrix3dv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix3dv(location, count, transpose, value), "glUniformMatrix3dv")
proc glUniformMatrix3fv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix3fv(location, count, transpose, value), "glUniformMatrix3fv")
proc glUniformMatrix3x2dv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix3x2dv(location, count, transpose, value), "glUniformMatrix3x2dv")
proc glUniformMatrix3x2fv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix3x2fv(location, count, transpose, value), "glUniformMatrix3x2fv")
proc glUniformMatrix3x4dv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix3x4dv(location, count, transpose, value), "glUniformMatrix3x4dv")
proc glUniformMatrix3x4fv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix3x4fv(location, count, transpose, value), "glUniformMatrix3x4fv")
proc glUniformMatrix4dv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix4dv(location, count, transpose, value), "glUniformMatrix4dv")
proc glUniformMatrix4fv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix4fv(location, count, transpose, value), "glUniformMatrix4fv")
proc glUniformMatrix4x2dv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix4x2dv(location, count, transpose, value), "glUniformMatrix4x2dv")
proc glUniformMatrix4x2fv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix4x2fv(location, count, transpose, value), "glUniformMatrix4x2fv")
proc glUniformMatrix4x3dv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLdouble): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix4x3dv(location, count, transpose, value), "glUniformMatrix4x3dv")
proc glUniformMatrix4x3fv*(location: GLint, count: GLsizei, transpose: GLboolean, value: ptr GLfloat): void =
  ## Specify the value of a uniform variable for the current program object
  ## Specifies the location of the uniform variable
  glCallTemplate(cglUniformMatrix4x3fv(location, count, transpose, value), "glUniformMatrix4x3fv")
proc glUniformSubroutinesuiv*(shadertype: GLenum, count: GLsizei, indices: ptr GLuint): void =
  ## Load active subroutine uniforms
  ## Specifies the shader stage from which to query for subroutine uniform index.
  ## shadertypemust be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER,
  ## GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADERor
  ## GL_FRAGMENT_SHADER.
  glCallTemplate(cglUniformSubroutinesuiv(shadertype, count, indices), "glUniformSubroutinesuiv")
proc glUnmapBuffer*(target: GLenum): GLboolean =
  ## Release the mapping of a buffer object's data store into the client's address space
  ## Specifies the target to which the buffer object is bound
  ## for glUnmapBuffer, which must be
  ## one of the buffer binding targets in the following
  ## table:
  glTypedCallTemplate(cglUnmapBuffer(target), "glUnmapBuffer")
proc glUnmapNamedBuffer*(buffer: GLuint): GLboolean =
  ## Release the mapping of a buffer object's data store into the client's address space
  ## Specifies the target to which the buffer object is bound
  ## for glUnmapBuffer, which must be
  ## one of the buffer binding targets in the following
  ## table:
  glTypedCallTemplate(cglUnmapNamedBuffer(buffer), "glUnmapNamedBuffer")
proc glUseProgram*(program: GLuint): void =
  ## Installs a program object as part of current rendering state
  ## Specifies the handle of the program object
  ## whose executables are to be used as part of current
  glCallTemplate(cglUseProgram(program), "glUseProgram")
proc glUseProgramStages*(pipeline: GLuint, stages: GLbitfield, program: GLuint): void =
  ## Bind stages of a program object to a program pipeline
  ## Specifies the program pipeline object to which to bind stages from program.
  glCallTemplate(cglUseProgramStages(pipeline, stages, program), "glUseProgramStages")
proc glValidateProgram*(program: GLuint): void =
  ## Validates a program object
  ## Specifies the handle of the program object to
  glCallTemplate(cglValidateProgram(program), "glValidateProgram")
proc glValidateProgramPipeline*(pipeline: GLuint): void =
  ## Validate a program pipeline object against current GL state
  ## Specifies the name of a program pipeline object to validate.
  glCallTemplate(cglValidateProgramPipeline(pipeline), "glValidateProgramPipeline")
proc glVertexAttrib4uiv*(index: GLuint, v: ptr GLuint): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib4uiv(index, v), "glVertexAttrib4uiv")
proc glVertexP4uiv*(`type`: GLenum, value: ptr GLuint): void =
  ## Specify a vertex
  ## Specify x, y, z, and wcoordinates of a vertex.
  ## Not all parameters are present in all forms of the command.
  glCallTemplate(cglVertexP4uiv(`type`, value), "glVertexP4uiv")
proc glVertexP4ui*(`type`: GLenum, value: GLuint): void =
  ## Specify a vertex
  ## Specify x, y, z, and wcoordinates of a vertex.
  ## Not all parameters are present in all forms of the command.
  glCallTemplate(cglVertexP4ui(`type`, value), "glVertexP4ui")
proc glVertexP3uiv*(`type`: GLenum, value: ptr GLuint): void =
  ## Specify a vertex
  ## Specify x, y, z, and wcoordinates of a vertex.
  ## Not all parameters are present in all forms of the command.
  glCallTemplate(cglVertexP3uiv(`type`, value), "glVertexP3uiv")
proc glVertexP3ui*(`type`: GLenum, value: GLuint): void =
  ## Specify a vertex
  ## Specify x, y, z, and wcoordinates of a vertex.
  ## Not all parameters are present in all forms of the command.
  glCallTemplate(cglVertexP3ui(`type`, value), "glVertexP3ui")
proc glVertexP2uiv*(`type`: GLenum, value: ptr GLuint): void =
  ## Specify a vertex
  ## Specify x, y, z, and wcoordinates of a vertex.
  ## Not all parameters are present in all forms of the command.
  glCallTemplate(cglVertexP2uiv(`type`, value), "glVertexP2uiv")
proc glVertexP2ui*(`type`: GLenum, value: GLuint): void =
  ## Specify a vertex
  ## Specify x, y, z, and wcoordinates of a vertex.
  ## Not all parameters are present in all forms of the command.
  glCallTemplate(cglVertexP2ui(`type`, value), "glVertexP2ui")
proc glVertexBindingDivisor*(bindingindex: GLuint, divisor: GLuint): void =
  ## Modify the rate at which generic vertex attributes
  ## advance
  ## Specifies the name of the vertex array object for
  glCallTemplate(cglVertexBindingDivisor(bindingindex, divisor), "glVertexBindingDivisor")
proc glVertexArrayAttribBinding*(vaobj: GLuint, attribindex: GLuint, bindingindex: GLuint): void =
  ## Associate a vertex attribute and a vertex buffer binding for a vertex array object
  ## Specifies the name of the vertex array object for
  ## glVertexArrayAttribBinding.
  glCallTemplate(cglVertexArrayAttribBinding(vaobj, attribindex, bindingindex), "glVertexArrayAttribBinding")
proc glVertexArrayAttribFormat*(vaobj: GLuint, attribindex: GLuint, size: GLint, `type`: GLenum, normalized: GLboolean, relativeoffset: GLuint): void =
  ## Specify the organization of vertex arrays
  ## Specifies the name of the vertex array object for
  glCallTemplate(cglVertexArrayAttribFormat(vaobj, attribindex, size, `type`, normalized, relativeoffset), "glVertexArrayAttribFormat")
proc glVertexArrayAttribIFormat*(vaobj: GLuint, attribindex: GLuint, size: GLint, `type`: GLenum, relativeoffset: GLuint): void =
  ## Specify the organization of vertex arrays
  ## Specifies the name of the vertex array object for
  glCallTemplate(cglVertexArrayAttribIFormat(vaobj, attribindex, size, `type`, relativeoffset), "glVertexArrayAttribIFormat")
proc glVertexArrayAttribLFormat*(vaobj: GLuint, attribindex: GLuint, size: GLint, `type`: GLenum, relativeoffset: GLuint): void =
  ## Specify the organization of vertex arrays
  ## Specifies the name of the vertex array object for
  glCallTemplate(cglVertexArrayAttribLFormat(vaobj, attribindex, size, `type`, relativeoffset), "glVertexArrayAttribLFormat")
proc glVertexArrayBindingDivisor*(vaobj: GLuint, bindingindex: GLuint, divisor: GLuint): void =
  ## Modify the rate at which generic vertex attributes
  ## advance
  ## Specifies the name of the vertex array object for
  glCallTemplate(cglVertexArrayBindingDivisor(vaobj, bindingindex, divisor), "glVertexArrayBindingDivisor")
proc glVertexArrayElementBuffer*(vaobj: GLuint, buffer: GLuint): void =
  ## Configures element array buffer binding of a vertex array object
  ## Specifies the name of the vertex array object.
  glCallTemplate(cglVertexArrayElementBuffer(vaobj, buffer), "glVertexArrayElementBuffer")
proc glVertexArrayVertexBuffer*(vaobj: GLuint, bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei): void =
  ## Bind a buffer to a vertex buffer bind point
  ## Specifies the name of the vertex array object to be used by
  glCallTemplate(cglVertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride), "glVertexArrayVertexBuffer")
proc glVertexArrayVertexBuffers*(vaobj: GLuint, first: GLuint, count: GLsizei, buffers: ptr GLuint, offsets: ptr GLintptr, strides: ptr GLsizei): void =
  ## Bind a buffer to a vertex buffer bind point
  ## Specifies the name of the vertex array object to be used by
  glCallTemplate(cglVertexArrayVertexBuffers(vaobj, first, count, buffers, offsets, strides), "glVertexArrayVertexBuffers")
proc glVertexAttrib1d*(index: GLuint, x: GLdouble): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib1d(index, x), "glVertexAttrib1d")
proc glVertexAttrib1dv*(index: GLuint, v: ptr GLdouble): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib1dv(index, v), "glVertexAttrib1dv")
proc glVertexAttrib1f*(index: GLuint, x: GLfloat): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib1f(index, x), "glVertexAttrib1f")
proc glVertexAttrib1fv*(index: GLuint, v: ptr GLfloat): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib1fv(index, v), "glVertexAttrib1fv")
proc glVertexAttrib1s*(index: GLuint, x: GLshort): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib1s(index, x), "glVertexAttrib1s")
proc glVertexAttrib1sv*(index: GLuint, v: ptr GLshort): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib1sv(index, v), "glVertexAttrib1sv")
proc glVertexAttrib2d*(index: GLuint, x: GLdouble, y: GLdouble): void =
  ## Specifies the value of a generic vertex attribute
  ## Specifies the index of the generic vertex
  glCallTemplate(cglVertexAttrib2d(index, x, y), "glVertexAttrib2d")

proc glInit*(loader: GLPROCLOADERPROC = glfwGetProcAddress): bool =
  ## Gets the opengl version that is supported and loads the proper functions
  cglGetProcAddress = loader

  cglGetString = cast[proc (name: GLenum): ptr GLubyte {.cdecl.}](cglGetProcAddress("glGetString"))
  if cglGetProcAddress == nil: return false

  var glVersion = cast[cstring](glGetString(GL_VERSION))
  if glVersion.isNil: return false

  # Thanks to David Herberth who made this version verifier
  var prefixes = ["OpenGL ES-CM ", "OpenGL ES-CL ", "OpenGL ES "]

  var version: string = $glVersion
  for p in prefixes:
    if version.startsWith(p):
      version = version.replace(p)
      break

  var major = ord(glVersion[0]) - ord('0')
  var minor = ord(glVersion[2]) - ord('0')

  glVersionMajor = major
  glVersionMinor = minor

  if (major == 1 and minor >= 0) or major > 1: load1_0()
  if (major == 1 and minor >= 1) or major > 1: load1_1()
  if (major == 1 and minor >= 2) or major > 1: load1_2()
  if (major == 1 and minor >= 3) or major > 1: load1_3()
  if (major == 1 and minor >= 4) or major > 1: load1_4()
  if (major == 1 and minor >= 5) or major > 1: load1_5()
  if (major == 2 and minor >= 0) or major > 2: load2_0()
  if (major == 2 and minor >= 1) or major > 2: load2_1()
  if (major == 3 and minor >= 0) or major > 3: load3_0()
  if (major == 3 and minor >= 1) or major > 3: load3_1()
  if (major == 3 and minor >= 2) or major > 3: load3_2()
  if (major == 3 and minor >= 3) or major > 3: load3_3()
  if (major == 4 and minor >= 0) or major > 4: load4_0()
  if (major == 4 and minor >= 1) or major > 4: load4_1()
  if (major == 4 and minor >= 2) or major > 4: load4_2()
  if (major == 4 and minor >= 3) or major > 4: load4_3()
  if (major == 4 and minor >= 4) or major > 4: load4_4()
  if (major == 4 and minor >= 5) or major > 4: load4_5()
  if (major == 4 and minor >= 6) or major > 4: load4_6()
  return true
